<!doctype html><html><head><meta charset="utf-8"><title>Dependency Injection in Action - Angular 官方文档</title><base href="/"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="search" type="application/opensearchdescription+xml" href="assets/opensearch.xml"><link rel="icon" type="image/x-icon" href="assets/images/favicons/favicon.ico"><link rel="icon" type="image/png" href="assets/images/favicons/favicon-32x32.png" sizes="32x32"><link rel="icon" type="image/png" href="assets/images/favicons/favicon-194x194.png" sizes="194x194"><link rel="icon" type="image/png" href="assets/images/favicons/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/png" href="assets/images/favicons/favicon-16x16.png" sizes="16x16"><link rel="apple-touch-icon" sizes="144x144" href="assets/images/favicons/favicon-144x144.png"><link rel="apple-touch-icon-precomposed" sizes="144x144" href="assets/images/favicons/favicon-144x144.png"><link href="assets/fonts/Material_Icons.css" rel="stylesheet"><link href="assets/fonts/Droid_Sans_Mono.css" rel="stylesheet"><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="manifest" href="pwa-manifest.json"><meta name="theme-color" content="#1976d2"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="translucent"><script>!function(e,a,n,t,s,c,g){e.GoogleAnalyticsObject=s,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(n),g=a.getElementsByTagName(n)[0],c.async=1,c.src="assets/js/analytics.js",~e.name.indexOf("NG_DEFER_BOOTSTRAP")||g.parentNode.insertBefore(c,g)}(window,document,"script",0,"ga")</script><script>window.onerror=function(){ga("send","exception",{exDescription:function(e,r,n,a,c){var l;e=e.replace(/^Error: /,""),l=c?c.stack.replace(/^Error: /,"").replace(e+"\n","").replace(/^ +/gm,"").replace(/^at /gm,"").replace(/(?: \(|@)http.+\/([^/)]+)\)?(?:\n|$)/gm,"@$1\n").replace(/ *\(eval code(:\d+:\d+)\)(?:\n|$)/gm,"@???$1\n"):r+":"+(n=n||"?")+":"+(a=a||"?");return(e+"\n"+l).substr(0,150)}.apply(null,arguments),exFatal:!0})}</script><script nomodule src="generated/ie-polyfills.min.js"></script><link rel="stylesheet" href="styles.469e78ee8be0e98911ff.css"></head><body><aio-shell ng-version="7.0.0-rc.1" class="mode-stable sidenav-open page-docs folder-docs view-TopBar view-SideNav aio-notification-hide"><div id="top-of-page"></div><mat-toolbar class="app-toolbar no-print mat-toolbar mat-primary mat-toolbar-multiple-rows" color="primary"><mat-toolbar-row class="notification-container mat-toolbar-row"><aio-notification expirationdate="2018-07-01" notificationid="angular-v6-announcement" class="ng-tns-c2-0 ng-trigger ng-trigger-hideAnimation" style="height:0"><span class="content"><a href="https://blog.angular.io/version-6-0-0-of-angular-now-available-cc56b0efa7a4"><mat-icon aria-label="Announcement" class="icon mat-icon" role="img" svgicon="insert_comment" aria-hidden="true"><svg fill="#ffffff" focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></mat-icon><span class="message">Version 6 of Angular Now Available!</span><span class="action-button">Learn More</span></a></span><button class="close-button mat-icon-button" aria-label="Close" mat-icon-button=""><span class="mat-button-wrapper"><mat-icon aria-label="Dismiss notification" class="mat-icon ng-tns-c2-0" role="img" svgicon="close" aria-hidden="true"><svg fill="#ffffff" focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></mat-icon></span><div class="mat-button-ripple mat-ripple mat-button-ripple-round" matripple=""></div><div class="mat-button-focus-overlay"></div></button></aio-notification></mat-toolbar-row><mat-toolbar-row class="mat-toolbar-row"><button class="hamburger mat-button" mat-button="" title="Docs menu"><span class="mat-button-wrapper"><mat-icon class="mat-icon" role="img" svgicon="menu" aria-hidden="true"><svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg></mat-icon></span><div class="mat-button-ripple mat-ripple" matripple=""></div><div class="mat-button-focus-overlay"></div></button><a class="nav-link home" href="/"><img alt="Home" height="40" src="assets/images/logos/angular/logo-nav@2x.png" title="Home" width="150" class="ng-star-inserted"></a><aio-top-menu class="ng-star-inserted"><ul role="navigation"><li class="ng-star-inserted"><a class="nav-link" href="features" title="特性">特性</a></li><li class="ng-star-inserted"><a class="nav-link" href="docs" title="文档">文档</a></li><li class="ng-star-inserted"><a class="nav-link" href="resources" title="资源">资源</a></li><li class="ng-star-inserted"><a class="nav-link" href="events" title="会议">会议</a></li><li class="ng-star-inserted"><a class="nav-link" href="https://blog.angular.io/" title="博客">博客</a></li><li class="ng-star-inserted"><a class="nav-link" href="translations/cn/home" title="关于中文版">关于中文版</a></li></ul></aio-top-menu><aio-search-box class="search-container"><input aria-label="search" placeholder="搜索" type="search"></aio-search-box><div class="toolbar-external-icons-container"><a href="https://twitter.com/angular" title="Twitter"><img src="assets/images/logos/twitter-icon.svg"></a><a href="https://github.com/angular/angular" title="GitHub"><img src="assets/images/logos/github-icon.svg"></a></div></mat-toolbar-row></mat-toolbar><mat-sidenav-container class="sidenav-container mat-drawer-container mat-sidenav-container mat-drawer-transition" role="main"><div class="mat-drawer-backdrop ng-star-inserted"></div><div class="cdk-visually-hidden cdk-focus-trap-anchor"></div><mat-sidenav class="sidenav mat-drawer mat-sidenav ng-tns-c6-1 ng-trigger ng-trigger-transform mat-drawer-side ng-star-inserted" tabindex="-1" style="transform:none;visibility:visible"><div class="mat-drawer-inner-container"><aio-nav-menu><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-1 collapsed ng-star-inserted" style="position:relative" href="guide/quickstart" title="对 Angular 和 Angular CLI 基础知识的简短介绍" target="_self">快速上手</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><button class="vertical-menu-item heading level-1 collapsed ng-star-inserted" type="button" title="此《英雄指南》教程会带你用 TypeScript 一步步创建一个 Angular 应用。" aria-pressed="false">教程<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-1 collapsed"><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="tutorial" title="《英雄指南》教程简介" target="_self">简介</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="tutorial/toh-pt0" title="创建应用的外壳" target="_self">应用的“外壳”</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="tutorial/toh-pt1" title="第一部分：构建一个简单的英雄编辑器" target="_self">1. 英雄编辑器</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="tutorial/toh-pt2" title="第二部分：构建一个主从结构的页面，用于展现英雄列表。" target="_self">2. 显示英雄列表</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="tutorial/toh-pt3" title="第三部分：把主从结构的页面重构成多个组件。" target="_self">3. 主从组件</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="tutorial/toh-pt4" title="第四部分：创建一个可复用的服务来管理英雄数据。" target="_self">4. 服务</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="tutorial/toh-pt5" title="第五部分：添加 Angular 路由器，并且学习在视图之间导航。" target="_self">5. 路由</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="tutorial/toh-pt6" title="第六部分：通过 HTTP 来获取并保存英雄数据。" target="_self">6. HTTP</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><button class="vertical-menu-item heading level-1 collapsed ng-star-inserted" type="button" title="学习 Angular 的核心知识" aria-pressed="false">核心知识<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-1 collapsed"><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><button class="vertical-menu-item heading level-2 collapsed ng-star-inserted" type="button" title="Angular 应用的基本构造块。" aria-pressed="false">架构<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 collapsed"><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/architecture" title="Angular 应用的基本构造块" target="_self">架构概览</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/architecture-modules" title="关于模块。" target="_self">模块（NgModule）简介</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/architecture-components" title="关于组件、模板和视图。" target="_self">组件简介</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/architecture-services" title="关于服务与依赖注入。" target="_self">服务与 DI 简介</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/architecture-next-steps" title="学完基础知识之后……" target="_self">后续步骤</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><button class="vertical-menu-item heading level-2 collapsed ng-star-inserted" type="button" title="使用数据绑定构建动态视图" aria-pressed="false">组件与模板<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 collapsed"><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/displaying-data" title="属性绑定可以帮助应用把数据显示在界面上" target="_self">显示数据</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/template-syntax" title="学习如何写模板，以便借助数据绑定机制显示数据并响应事件。" target="_self">模板语法</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/user-input" title="用户输入会触发 DOM 事件。Angular 会通过事件绑定来监听那些事件，并把修改后的值传回应用的组件和模型中。" target="_self">用户输入</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/lifecycle-hooks" title="Angular 调用指令和组件的生命周期钩子函数，包括它的创建、变更和销毁时。" target="_self">生命周期钩子</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/component-interaction" title="在不同的指令和组件之间共享信息" target="_self">组件交互</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/component-styles" title="添加专属于某个组件的样式" target="_self">组件样式</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/elements" title="把组件转换成自定义元素。" target="_self">Angular 自定义元素</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/dynamic-component-loader" title="动态加载组件" target="_self">动态组件</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/attribute-directives" title="属性型指令把行为添加到现有元素上。" target="_self">属性型指令</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/structural-directives" title="结构型指令可以操纵页面的布局" target="_self">结构型指令</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/pipes" title="管道可以在模板中转换显示的内容。" target="_self">管道</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><button class="vertical-menu-item heading level-2 collapsed ng-star-inserted" type="button" title="Angular 的表单" aria-pressed="false">表单<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 collapsed"><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/forms-overview" title="表单可以创建集中、高效、引人注目的输入体验。Angular 表单可以协调一组数据绑定控件，跟踪变更，验证输入，并表达错误信息。" target="_self">简介</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/reactive-forms" title="使用 FormBuilder、表单组和表单数组创建响应式表单。" target="_self">响应式表单</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/forms" title="使用指令和 Angular 模板语法创建模板驱动表单。" target="_self">模板驱动表单</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/form-validation" title="验证用户的表单输入" target="_self">表单验证</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/dynamic-form" title="使用 FormGroup 渲染动态表单。" target="_self">动态表单</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><button class="vertical-menu-item heading level-2 collapsed ng-star-inserted" type="button" title="Observable 与 RxJS" aria-pressed="false">Observable 与 RxJS<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 collapsed"><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/observables" title="" target="_self">可观察对象(Observable)</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/rx-library" title="" target="_self">RxJS 库</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/observables-in-angular" title="" target="_self">Angular 中的可观察对象</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/practical-observable-usage" title="" target="_self">用法实战</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/comparing-observables" title="" target="_self">与其它技术的比较</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="guide/bootstrapping" title="在应用的根模块（AppModule）中告诉 Angular 如何构造并引导引用。" target="_self">引导启动</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><button class="vertical-menu-item heading level-2 collapsed ng-star-inserted" type="button" title="Angular 中的模块" aria-pressed="false">Angular 模块<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 collapsed"><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/ngmodules" title="使用 NgModule 让你的应用更高效" target="_self">NgModule 简介</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/ngmodule-vs-jsmodule" title="JavaScript 模块和 NgModule 之间的差异" target="_self">JS 模块 vs NgModule</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/frequent-ngmodules" title="介绍最常用的 Angular 模块" target="_self">常用模块</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/module-types" title="介绍特性模块的几种类型" target="_self">特性模块的分类</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/entry-components" title="关于 Angular 中入口组件的一切" target="_self">入口组件</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/feature-modules" title="创建特性模块，以组织你的代码" target="_self">特性模块</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/providers" title="服务提供商与 Angular 模块" target="_self">服务提供商</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/singleton-services" title="创建单例应用" target="_self">单例应用</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/lazy-loading-ngmodules" title="惰性加载模块，以提高应用的性能" target="_self">惰性加载的特性模块</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/sharing-ngmodules" title="共享 Angular 模块让你的应用现代化。" target="_self">共享 Angular 模块</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/ngmodule-api" title="理解 NgModule 的那些细节。" target="_self">NgModule API</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/ngmodule-faq" title="回答关于 NgModules 的常见问题。" target="_self">NgModule 常见问题</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><button class="vertical-menu-item heading level-2 collapsed ng-star-inserted" type="button" title="依赖注入：创建并注入各种服务。" aria-pressed="false">依赖注入<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 collapsed"><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/dependency-injection" title="Angular 的依赖注入系统能够为 Angular 创建的类创建并交付它们所依赖的服务。" target="_self">Angular 依赖注入</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/hierarchical-dependency-injection" title="与组件树平行的注入器树，并支持嵌套的依赖。" target="_self">多级注入器</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/dependency-injection-providers" title="各种提供商类型的更多知识。" target="_self">DI 提供商</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/dependency-injection-in-action" title="依赖注入的使用技巧" target="_self">DI 实战</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/dependency-injection-navtree" title="使用注入器树来查找父组件。" target="_self">在组件树中导航</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="guide/http" title="通过 HTTP 协议与远程服务器对话。" target="_self">HttpClient</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="guide/router" title="揭示如何通过 Angular 路由进行基本的屏幕导航。" target="_self">路由与导航</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><button class="vertical-menu-item heading level-2 collapsed ng-star-inserted" type="button" title="Angular 动画系统指南" aria-pressed="false">动画<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 collapsed"><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/animations" title="Angular 动画的基础技术。" target="_self">简介</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/transition-and-triggers" title="转场与触发器的高级技术。" target="_self">转场与触发器</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/complex-animation-sequences" title="复杂的 Angular 动画序列。" target="_self">复杂序列</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/reusable-animations" title="创建可复用的动画。" target="_self">可复用动画</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/route-animations" title="为路由提供转场动画。" target="_self">路由转场动画</a></div></aio-nav-item></div></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><button class="vertical-menu-item heading level-1 collapsed ng-star-inserted" type="button" title="把 Angular 用到你的实际工作中的一些技巧" aria-pressed="false">其它技术<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-1 collapsed"><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="guide/security" title="Angular 应用开发中的安全技术。" target="_self">安全</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="guide/i18n" title="把应用模板中的文本翻译成多种语言。" target="_self">国际化 (i18n)</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><button class="vertical-menu-item heading level-2 collapsed ng-star-inserted" type="button" title="Angular Service Worker: 控制应用资源的缓存。" aria-pressed="false">Service Worker 与 PWA<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 collapsed"><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/service-worker-intro" title="Angular 对 Service Worker 的实现提升了慢速或不稳定的网络连接下的用户体验。" target="_self">简介</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/service-worker-getting-started" title="在 CLI 项目中启用 Service Worker，并在浏览器中查看效果。" target="_self">快速起步</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/service-worker-communications" title="那些能让你和 Angular 的 Service Worker 通讯的服务类。" target="_self">与 Service Worker 通讯</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/service-worker-devops" title="使用 Service Worker 运行应用、管理应用更新、调试以及杀掉正在运行的应用。" target="_self">生产环境下的 Service Worker</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/service-worker-config" title="配置 Service Worker 的缓存行为。" target="_self">Service Worker 配置</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="guide/universal" title="使用 Angular Universal 在服务端渲染 HTML。" target="_self">服务端渲染</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><button class="vertical-menu-item heading level-2 collapsed ng-star-inserted" type="button" title="把 AngularJS 应用增量式的升级到 Angular。" aria-pressed="false">从 AngularJS 升级<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 collapsed"><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/upgrade" title="把 AngularJS 应用增量式的升级到 Angular。" target="_self">升级步骤</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/upgrade-performance" title="用更灵活的方式把 AngularJS 升级到 Angular" target="_self">提高升级效率</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/ajs-quick-reference" title="学习如何把 AngularJS 的概念映射到 Angular 中。" target="_self">AngularJS 与 Angular 的概念对照</a></div></aio-nav-item></div></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><button class="vertical-menu-item heading level-1 collapsed ng-star-inserted" type="button" title="关于环境搭建、构建、测试、部署环境与工具的信息。" aria-pressed="false">环境搭建与部署<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-1 collapsed"><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="guide/file-structure" title="Angular 工作空间在文件系统中是怎样的。" target="_self">项目文件结构</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="guide/npm-packages" title="会默认安装到项目中的 npm 包的说明。" target="_self">npm 包</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="guide/typescript-configuration" title="给 Angular 开发者的 TypeScript 配置。" target="_self">TypeScript 配置</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="guide/aot-compiler" title="了解为何以及如何使用预先（AOT）编译器。" target="_self">预先（AOT）编译</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="guide/build" title="构建应用及为应用启动开发服务器。" target="_self">构建与启动开发服务器</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="guide/testing" title="测试 Angular 应用的技巧与实践。" target="_self">测试</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="guide/deployment" title="了解如何部署 Angular 应用。" target="_self">发布</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="guide/browser-support" title="浏览器支持与腻子脚本指南。" target="_self">浏览器支持</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><button class="vertical-menu-item heading level-2 collapsed ng-star-inserted" type="button" title="整合开发环境和工具。" aria-pressed="false">开发工具集成<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 collapsed"><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/language-service" title="使用 Angular 语言服务加速开发。" target="_self">语言服务</a></div></aio-nav-item></div></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><button class="vertical-menu-item heading level-1 collapsed ng-star-inserted" type="button" title="Angular 的版本发布实践、更新与升级。" aria-pressed="false">发布信息<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-1 collapsed"><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="guide/releases" title="Angular 的版本、发布、支持、弃用策略与实践。" target="_self">Angular 发布策略与实践</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="guide/updating" title="如何把 Angular 应用和库升级到最新版本。" target="_self">保持最新</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><button class="vertical-menu-item heading level-2 collapsed ng-star-inserted" type="button" title="逐渐把 AngularJS 应用升级成 Angular。" aria-pressed="false">从 AngularJS 升级<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 collapsed"><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/upgrade" title="逐渐把 AngularJS 应用升级成 Angular。" target="_self">升级指南</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-3 collapsed ng-star-inserted" style="position:relative" href="guide/ajs-quick-reference" title="学习如何把 AngularJS 的概念映射到 Angular 中。" target="_self">AngularJS 与 Angular 的概念对照</a></div></aio-nav-item></div></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><button class="vertical-menu-item heading level-1 collapsed ng-star-inserted" type="button" title="Angular 语法、编码、术语汇总。" aria-pressed="false">快捷手册<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-1 collapsed"><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="guide/cheatsheet" title="关于 Angular 常用编码技术的快速指南。" target="_self">速查表</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="guide/styleguide" title="写出 Angular 风格的程序" target="_self">风格指南</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-2 collapsed ng-star-inserted" style="position:relative" href="guide/glossary" title="Angular 中最重要的词汇的简要定义。" target="_self">词汇表</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-1 collapsed ng-star-inserted" style="position:relative" href="api" title="关于 Angular 中类和值的详细信息。" target="_self">API 参考手册</a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><div class="mat-divider ng-star-inserted" style="margin:4px 20px;border-top:1px solid #d3d3d3"></div></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-1 collapsed ng-star-inserted" style="position:relative" href="https://github.com/ng-docs/ng-docs.github.io/issues" title="github 上的中文互助问答区" target="_blank">互助问答<mat-icon class="mat-icon material-icons ng-star-inserted" role="img" aria-hidden="true">open_in_new</mat-icon></a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-1 collapsed ng-star-inserted" style="position:relative" href="https://material.angular.cn" title="Angular Material 组件库的中文文档" target="_blank">官方 Material 组件库<mat-icon class="mat-icon material-icons ng-star-inserted" role="img" aria-hidden="true">open_in_new</mat-icon></a></div></aio-nav-item><aio-nav-item class="ng-star-inserted"><div class="ng-star-inserted"><a class="vertical-menu-item level-1 collapsed ng-star-inserted" style="position:relative" href="https://ng.ant.design/" title="Ant Design 的 Angular 实现，服务于企业级后台产品。" target="_blank">ng-zorro 组件库<mat-icon class="mat-icon material-icons ng-star-inserted" role="img" aria-hidden="true">open_in_new</mat-icon></a></div></aio-nav-item></aio-nav-menu><div class="doc-version"><aio-select><div class="form-select-menu"><button class="form-select-button"><strong></strong>stable (v7.0.0)</button></div></aio-select></div></div></mat-sidenav><div class="cdk-visually-hidden cdk-focus-trap-anchor"></div><mat-sidenav-content cdkscrollable="" class="mat-drawer-content mat-sidenav-content ng-star-inserted" style="margin-left:260px"><section class="sidenav-content" role="content" id="docs"><div class="github-links"><a href="https://github.com/angular/angular/edit/master/aio/content/guide/dependency-injection-in-action.md?message=docs%3A%20describe%20your%20change..." aria-label="提供编辑建议" title="提供编辑建议"><i class="material-icons" aria-hidden="true" role="img">mode_edit</i></a></div><div class="content"><h1 translation-result="on" id="依赖注入实战">依赖注入实战<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#依赖注入实战"><i class="material-icons">link</i></a></h1><h1 translation-origin="off" id="dependency-injection-in-action">Dependency Injection in Action<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#dependency-injection-in-action"><i class="material-icons">link</i></a></h1><p translation-result="on">本节将会涉及 Angular 依赖注入（DI）的很多特性。</p><p translation-origin="off">This section explores many of the features of dependency injection (DI) in Angular.</p><a id="toc"></a><p translation-result="on">要获取本文的代码，<strong>参见<live-example name="dependency-injection-in-action"></live-example></strong>。</p><p translation-origin="off">See the<live-example name="dependency-injection-in-action"></live-example>of the code in this cookbook.</p><a id="nested-dependencies"></a><h2 translation-result="on" id="嵌套的服务依赖">嵌套的服务依赖<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#嵌套的服务依赖"><i class="material-icons">link</i></a></h2><h2 translation-origin="off" id="nested-service-dependencies">Nested service dependencies<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#nested-service-dependencies"><i class="material-icons">link</i></a></h2><p translation-result="on">这些被注入服务的消费者不需要知道如何创建这个服务。新建和缓存这个服务是依赖注入器的工作。消费者只要让依赖注入框架知道它需要哪些依赖项就可以了。</p><p translation-origin="off">The <em>consumer</em> of an injected service doesn't need to know how to create that service. It's the job of the DI framework to create and cache dependencies. The consumer just needs to let the DI framework know which dependencies it needs.</p><p translation-result="on">有时候一个服务依赖其它服务...而其它服务可能依赖另外的更多服务。 依赖注入框架会负责正确的顺序解析这些嵌套的依赖项。 在每一步，依赖的使用者只要在它的构造函数里简单声明它需要什么，框架就会完成所有剩下的事情。</p><p translation-origin="off">Sometimes a service depends on other services, which may depend on yet other services. The dependency injection framework resolves these nested dependencies in the correct order. At each step, the consumer of dependencies declares what it requires in its constructor, and lets the framework provide them.</p><p translation-result="on">下面的例子往 <code>AppComponent</code> 里声明它依赖 <code>LoggerService</code> 和 <code>UserContext</code>。</p><p translation-origin="off">The following example shows that <code>AppComponent</code> declares its dependence on <code>LoggerService</code> and <code>UserContext</code>.</p><code-example path="dependency-injection-in-action/src/app/app.component.ts" region="ctor" header="src/app/app.component.ts" linenums="false">constructor(logger: LoggerService, public userContext: UserContextService) { userContext.loadUser(this.userId); logger.logInfo('AppComponent initialized'); }</code-example><p translation-result="on"><code>UserContext</code> 转而依赖 <code>LoggerService</code> 和 <code>UserService</code>（这个服务用来收集特定用户信息）。</p><p translation-origin="off"><code>UserContext</code> in turn depends on both <code>LoggerService</code> and <code>UserService</code>, another service that gathers information about a particular user.</p><code-example path="dependency-injection-in-action/src/app/user-context.service.ts" region="injectables" header="user-context.service.ts (injection)" linenums="false">@<a href="/api/core/Injectable" class="code-anchor">Injectable</a>({ <a href="/api/core/Injectable#providedIn" class="code-anchor">providedIn</a>: 'root' }) export class UserContextService { constructor(private userService: UserService, private loggerService: LoggerService) { } }</code-example><p translation-result="on">当 Angular 新建 <code>AppComponent</code> 时，依赖注入框架会先创建一个 <code>LoggerService</code> 的实例，然后创建 <code>UserContextService</code> 实例。 <code>UserContextService</code> 也需要框架刚刚创建的这个 <code>LoggerService</code> 实例，这样框架才能为它提供同一个实例。<code>UserContextService</code> 还需要框架创建过的 <code>UserService</code>。 <code>UserService</code> 没有其它依赖，所以依赖注入框架可以直接 <code>new</code> 出该类的一个实例，并把它提供给 <code>UserContextService</code> 的构造函数。</p><p translation-origin="off">When Angular creates <code>AppComponent</code>, the DI framework creates an instance of <code>LoggerService</code> and starts to create <code>UserContextService</code>. <code>UserContextService</code> also needs <code>LoggerService</code>, which the framework already has, so the framework can provide the same instance. <code>UserContextService</code> also needs <code>UserService</code>, which the framework has yet to create. <code>UserService</code> has no further dependencies, so the framework can simply use <code>new</code> to instantiate the class and provide the instance to the <code>UserContextService</code> constructor.</p><p translation-result="on">父组件 <code>AppComponent</code> 不需要了解这些依赖的依赖。 只要在构造函数中声明自己需要的依赖即可（这里是 <code>LoggerService</code> 和 <code>UserContextService</code>），框架会帮你解析这些嵌套的依赖。</p><p translation-origin="off">The parent <code>AppComponent</code> doesn't need to know about the dependencies of dependencies. Declare what's needed in the constructor (in this case <code>LoggerService</code> and <code>UserContextService</code>) and the framework resolves the nested dependencies.</p><p translation-result="on">当所有的依赖都就位之后，<code>AppComponent</code> 就会显示该用户的信息。</p><p translation-origin="off">When all dependencies are in place, <code>AppComponent</code> displays the user information.</p><figure><img src="generated/images/guide/dependency-injection-in-action/logged-in-user.png" alt="Logged In User" width="145" height="99"></figure><a id="service-scope"></a><h2 translation-result="on" id="把服务的范围限制到某个组件的子树下">把服务的范围限制到某个组件的子树下<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#把服务的范围限制到某个组件的子树下"><i class="material-icons">link</i></a></h2><h2 translation-origin="off" id="limit-service-scope-to-a-component-subtree">Limit service scope to a component subtree<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#limit-service-scope-to-a-component-subtree"><i class="material-icons">link</i></a></h2><p translation-result="on">Angular 应用程序有多个依赖注入器，组织成一个与组件树平行的树状结构。 每个注入器都会创建依赖的一个单例。在所有该注入器负责提供服务的地方，所提供的都是同一个实例。 可以在注入器树的任何层级提供和建立特定的服务。这意味着，如果在多个注入器中提供该服务，那么该服务也就会有多个实例。</p><p translation-origin="off">An Angular application has multiple injectors, arranged in a tree hierarchy that parallels the component tree. Each injector creates a singleton instance of a dependency. That same instance is injected wherever that injector provides that service. A particular service can be provided and created at any level of the injector hierarchy, which means that there can be multiple instances of a service if it is provided by multiple injectors.</p><p translation-result="on">由根注入器提供的依赖可以注入到应用中任何地方的任何组件中。 但有时候你可能希望把服务的有效性限制到应用程序的一个特定区域。 比如，你可能希望用户明确选择一个服务，而不是让根注入器自动提供它。</p><p translation-origin="off">Dependencies provided by the root injector can be injected into <em>any</em> component <em>anywhere</em> in the application. In some cases, you might want to restrict service availability to a particular region of the application. For instance, you might want to let users explicitly opt in to use a service, rather than letting the root injector provide it automatically.</p><p translation-result="on">通过<em>在组件树的子级根组件</em>中提供服务，可以把一个被注入服务的作用域局限在应用程序结构中的某个<em>分支</em>中。 这个例子中展示了如何通过把服务添加到子组件 <code>@<a href="/api/core/Component" class="code-anchor">Component</a>()</code> 装饰器的 <code>providers</code> 数组中，来为 <code>HeroesBaseComponent</code> 提供另一个 <code>HeroService</code> 实例：</p><p translation-origin="off">You can limit the scope of an injected service to a <em>branch</em> of the application hierarchy by providing that service <em>at the sub-root component for that branch</em>. This example shows how to make a different instance of <code>HeroService</code> available to <code>HeroesBaseComponent</code> by adding it to the <code>providers</code> array of the <code>@<a href="/api/core/Component" class="code-anchor">Component</a>()</code> decorator of the sub-component.</p><code-example path="dependency-injection-in-action/src/app/sorted-heroes.component.ts" region="injection" header="src/app/sorted-heroes.component.ts (HeroesBaseComponent excerpt)">@<a href="/api/core/Component" class="code-anchor">Component</a>({ selector: 'app-unsorted-heroes', <a href="/api/core/Component#template" class="code-anchor">template</a>: `&#x3C;div *<a href="/api/common/NgForOf" class="code-anchor">ngFor</a>="let hero of heroes">{{hero.name}}&#x3C;/div>`, providers: [HeroService] }) export class HeroesBaseComponent implements <a href="/api/core/OnInit" class="code-anchor">OnInit</a> { constructor(private heroService: HeroService) { } }</code-example><p translation-result="on">当 Angular 新建 <code>HeroBaseComponent</code> 的时候，它会同时新建一个 <code>HeroService</code> 实例，该实例只在该组件及其子组件(如果有)中可见。</p><p translation-origin="off">When Angular creates <code>HeroesBaseComponent</code>, it also creates a new instance of <code>HeroService</code> that is visible only to that component and its children, if any.</p><p translation-result="on">也可以在应用程序别处的另一个组件里提供 <code>HeroService</code>。这样就会导致在另一个注入器中存在该服务的另一个实例。</p><p translation-origin="off">You could also provide <code>HeroService</code> to a different component elsewhere in the application. That would result in a different instance of the service, living in a different injector.</p><div class="alert is-helpful"><p translation-result="on">这个例子中，局部化的 <code>HeroService</code> 单例，遍布整份范例代码，包括 <code>HeroBiosComponent</code>、<code>HeroOfTheMonthComponent</code> 和 <code>HeroBaseComponent</code>。 这些组件每个都有自己的 <code>HeroService</code> 实例，用来管理独立的英雄库。</p><p translation-origin="off">Examples of such scoped <code>HeroService</code> singletons appear throughout the accompanying sample code, including <code>HeroBiosComponent</code>, <code>HeroOfTheMonthComponent</code>, and <code>HeroesBaseComponent</code>. Each of these components has its own <code>HeroService</code> instance managing its own independent collection of heroes.</p></div><a id="multiple-service-instances"></a><h2 translation-result="on" id="多个服务实例沙箱式隔离">多个服务实例(沙箱式隔离)<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#多个服务实例沙箱式隔离"><i class="material-icons">link</i></a></h2><h2 translation-origin="off" id="multiple-service-instances-sandboxing">Multiple service instances (sandboxing)<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#multiple-service-instances-sandboxing"><i class="material-icons">link</i></a></h2><p translation-result="on">在组件树的<em>同一个级别</em>上，有时需要一个服务的多个实例。</p><p translation-origin="off">Sometimes you want multiple instances of a service at <em>the same level</em> of the component hierarchy.</p><p translation-result="on">一个用来保存其伴生组件的实例状态的服务就是个好例子。 每个组件都需要该服务的单独实例。 每个服务有自己的工作状态，与其它组件的服务和状态隔离。这叫做<em>沙箱化</em>，因为每个服务和组件实例都在自己的沙箱里运行。</p><p translation-origin="off">A good example is a service that holds state for its companion component instance. You need a separate instance of the service for each component. Each service has its own work-state, isolated from the service-and-state of a different component. This is called <em>sandboxing</em> because each service and component instance has its own sandbox to play in.</p><a id="hero-bios-component"></a><p translation-result="on">在这个例子中，<code>HeroBiosComponent</code> 呈现了 <code>HeroBioComponent</code> 的三个实例。</p><p translation-origin="off">In this example, <code>HeroBiosComponent</code> presents three instances of <code>HeroBioComponent</code>.</p><code-example path="dependency-injection-in-action/src/app/hero-bios.component.ts" region="simple" header="ap/hero-bios.component.ts">@<a href="/api/core/Component" class="code-anchor">Component</a>({ selector: 'app-hero-bios', <a href="/api/core/Component#template" class="code-anchor">template</a>: ` &#x3C;app-hero-bio [heroId]="1">&#x3C;/app-hero-bio> &#x3C;app-hero-bio [heroId]="2">&#x3C;/app-hero-bio> &#x3C;app-hero-bio [heroId]="3">&#x3C;/app-hero-bio>`, providers: [HeroService] }) export class HeroBiosComponent { }</code-example><p translation-result="on">每个 <code>HeroBioComponent</code> 都能编辑一个英雄的生平。<code>HeroBioComponent</code> 依赖 <code>HeroCacheService</code> 服务来对该英雄进行读取、缓存和执行其它持久化操作。</p><p translation-origin="off">Each <code>HeroBioComponent</code> can edit a single hero's biography. <code>HeroBioComponent</code> relies on <code>HeroCacheService</code> to fetch, cache, and perform other persistence operations on that hero.</p><code-example path="dependency-injection-in-action/src/app/hero-cache.service.ts" region="service" header="src/app/hero-cache.service.ts">@<a href="/api/core/Injectable" class="code-anchor">Injectable</a>() export class HeroCacheService { hero: Hero; constructor(private heroService: HeroService) {} fetchCachedHero(id: number) { if (!this.hero) { this.hero = this.heroService.getHeroById(id); } return this.hero; } }</code-example><p translation-result="on">这三个 <code>HeroBioComponent</code> 实例不能共享同一个 <code>HeroCacheService</code> 实例。否则它们会相互冲突，争相把自己的英雄放在缓存里面。</p><p translation-origin="off">Three instances of <code>HeroBioComponent</code> can't share the same instance of <code>HeroCacheService</code>, as they'd be competing with each other to determine which hero to cache.</p><p translation-result="on">它们应该通过在自己的元数据(metadata)<code>providers</code> 数组里面列出 <code>HeroCacheService</code>, 这样每个 <code>HeroBioComponent</code> 就能<em>拥有</em>自己独立的 <code>HeroCacheService</code> 实例了。</p><p translation-origin="off">Instead, each <code>HeroBioComponent</code> gets its <em>own</em> <code>HeroCacheService</code> instance by listing <code>HeroCacheService</code> in its metadata <code>providers</code> array.</p><code-example path="dependency-injection-in-action/src/app/hero-bio.component.ts" region="component" header="src/app/hero-bio.component.ts">@<a href="/api/core/Component" class="code-anchor">Component</a>({ selector: 'app-hero-bio', <a href="/api/core/Component#template" class="code-anchor">template</a>: ` &#x3C;h4>{{hero.name}}&#x3C;/h4> &#x3C;ng-content>&#x3C;/ng-content> &#x3C;<a href="/api/forms/DefaultValueAccessor" class="code-anchor">textarea</a> cols="25" [(<a href="/api/forms/NgModel" class="code-anchor">ngModel</a>)]="hero.description">&#x3C;/<a href="/api/forms/DefaultValueAccessor" class="code-anchor">textarea</a>>`, providers: [HeroCacheService] }) export class HeroBioComponent implements <a href="/api/core/OnInit" class="code-anchor">OnInit</a> { @<a href="/api/core/Input" class="code-anchor">Input</a>() heroId: number; constructor(private heroCache: HeroCacheService) { } ngOnInit() { this.heroCache.fetchCachedHero(this.heroId); } get hero() { return this.heroCache.hero; } }</code-example><p translation-result="on">父组件 <code>HeroBiosComponent</code> 把一个值绑定到 <code>heroId</code>。<code>ngOnInit</code> 把该 <code>id</code> 传递到服务，然后服务获取和缓存英雄。<code>hero</code> 属性的 getter 从服务里面获取缓存的英雄，并在模板里显示它绑定到属性值。</p><p translation-origin="off">The parent <code>HeroBiosComponent</code> binds a value to <code>heroId</code>. <code>ngOnInit</code> passes that ID to the service, which fetches and caches the hero. The getter for the <code>hero</code> property pulls the cached hero from the service. The template displays this data-bound property.</p><p translation-result="on">到<live-example name="dependency-injection-in-action">在线例子</live-example>中找到这个例子，确认三个 <code>HeroBioComponent</code> 实例拥有自己独立的英雄数据缓存。</p><p translation-origin="off">Find this example in<live-example name="dependency-injection-in-action">live code</live-example>and confirm that the three <code>HeroBioComponent</code> instances have their own cached hero data.</p><figure><img src="generated/images/guide/dependency-injection-in-action/hero-bios.png" alt="Bios" width="199" height="317"></figure><a id="qualify-dependency-lookup"></a><h2 translation-result="on" id="使用参数装饰器来限定依赖查找方式">使用参数装饰器来限定依赖查找方式<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#使用参数装饰器来限定依赖查找方式"><i class="material-icons">link</i></a></h2><h2 translation-origin="off" id="qualify-dependency-lookup-with-parameter-decorators">Qualify dependency lookup with parameter decorators<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#qualify-dependency-lookup-with-parameter-decorators"><i class="material-icons">link</i></a></h2><p translation-result="on">当类需要某个依赖项时，该依赖项就会作为参数添加到类的构造函数中。 当 Angular 需要实例化该类时，就会调用 DI 框架来提供该依赖。 默认情况下，DI 框架会在注入器树中查找一个提供商，从该组件的局部注入器开始，如果需要，则沿着注入器树向上冒泡，直到根注入器。</p><p translation-origin="off">When a class requires a dependency, that dependency is added to the constructor as a parameter. When Angular needs to instantiate the class, it calls upon the DI framework to supply the dependency. By default, the DI framework searches for a provider in the injector hierarchy, starting at the component's local injector of the component, and if necessary bubbling up through the injector tree until it reaches the root injector.</p><ul><li><p translation-result="on">第一个配置了该提供商的注入器就会把依赖（服务实例或值）提供给这个构造函数。</p><p translation-origin="off">The first injector configured with a provider supplies the dependency (a service instance or value) to the constructor.</p></li><li><p translation-result="on">如果在根注入器中也没有找到提供商，则 DI 框架将会给构造函数返回一个 null。</p><p translation-origin="off">If no provider is found in the root injector, the DI framework returns null to the constructor.</p></li></ul><p translation-result="on">通过在类的构造函数中对服务参数使用<em>参数装饰器</em>，可以提供一些选项来修改默认的搜索行为。</p><p translation-origin="off">There are a number of options for modifying the default search behavior, using <em>parameter decorators</em> on the service-valued parameters of a class constructor.</p><a id="optional"></a><h3 translation-result="on" id="用-optional-来让依赖是可选的，以及使用-host-来限定搜索方式">用 <code>@<a href="/api/core/Optional" class="code-anchor">Optional</a></code> 来让依赖是可选的，以及使用 <code>@<a href="/api/core/Host" class="code-anchor">Host</a></code> 来限定搜索方式<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#用-optional-来让依赖是可选的，以及使用-host-来限定搜索方式"><i class="material-icons">link</i></a></h3><h3 translation-origin="off" id="make-a-dependency-optional-and-limit-search-with-host">Make a dependency <code>@<a href="/api/core/Optional" class="code-anchor">Optional</a></code> and limit search with <code>@<a href="/api/core/Host" class="code-anchor">Host</a></code><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#make-a-dependency-optional-and-limit-search-with-host"><i class="material-icons">link</i></a></h3><p translation-result="on">依赖可以注册在组件树的任何层级上。 当组件请求某个依赖时，Angular 会从该组件的注入器找起，沿着注入器树向上，直到找到了第一个满足要求的提供商。如果没找到依赖，Angular 就会抛出一个错误。</p><p translation-origin="off">Dependencies can be registered at any level in the component hierarchy. When a component requests a dependency, Angular starts with that component's injector and walks up the injector tree until it finds the first suitable provider.<br>Angular throws an error if it can't find the dependency during that walk.</p><p translation-result="on">某些情况下，你需要限制搜索，或容忍依赖项的缺失。 你可以使用组件构造函数参数上的 <code>@<a href="/api/core/Host" class="code-anchor">Host</a></code> 和 <code>@<a href="/api/core/Optional" class="code-anchor">Optional</a></code> 这两个限定装饰器来修改 Angular 的搜索行为。</p><p translation-origin="off">In some cases, you need to limit the search or accommodate a missing dependency. You can modify Angular's search behavior with the <code>@<a href="/api/core/Host" class="code-anchor">Host</a></code> and <code>@<a href="/api/core/Optional" class="code-anchor">Optional</a></code> qualifying decorators on a service-valued parameter of the component's constructor.</p><ul><li><p translation-result="on"><code>@<a href="/api/core/Optional" class="code-anchor">Optional</a></code> 属性装饰器告诉 Angular 当找不到依赖时就返回 null。</p><p translation-origin="off">The <code>@<a href="/api/core/Optional" class="code-anchor">Optional</a></code> property decorator tells Angular to return null when it can't find the dependency.</p></li><li><p translation-result="on"> <code>@<a href="/api/core/Host" class="code-anchor">Host</a></code> 属性装饰器会禁止在<em>宿主组件</em>以上的搜索。宿主组件通常就是请求该依赖的那个组件。 不过，当该组件投影进某个<em>父</em>组件时，那个父组件就会变成宿主。下面的例子中介绍了第二种情况。</p><p translation-origin="off">The <code>@<a href="/api/core/Host" class="code-anchor">Host</a></code> property decorator stops the upward search at the <em>host component</em>. The host component is typically the component requesting the dependency. However, when this component is projected into a <em>parent</em> component, that parent component becomes the host. The following example covers this second case.</p></li></ul><p translation-result="on">如下例所示，这些装饰器可以独立使用，也可以同时使用。这个<a href="/guide/dependency-injection-in-action#hero-bios-component" translation-result="on">以前</a><code translation-origin="off">HeroBiosAndContactsComponent</code> 是你见过的那个 <code>HeroBiosComponent</code> 的修改版。</p><p translation-origin="off">These decorators can be used individually or together, as shown in the example. This <code>HeroBiosAndContactsComponent</code> is a revision of <code>HeroBiosComponent</code> which you looked at <a href="/guide/dependency-injection-in-action#hero-bios-component">above</a>.</p><code-example path="dependency-injection-in-action/src/app/hero-bios.component.ts" region="hero-bios-and-contacts" header="src/app/hero-bios.component.ts (HeroBiosAndContactsComponent)">@<a href="/api/core/Component" class="code-anchor">Component</a>({ selector: 'app-hero-bios-and-contacts', <a href="/api/core/Component#template" class="code-anchor">template</a>: ` &#x3C;app-hero-bio [heroId]="1"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio> &#x3C;app-hero-bio [heroId]="2"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio> &#x3C;app-hero-bio [heroId]="3"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio>`, providers: [HeroService] }) export class HeroBiosAndContactsComponent { constructor(logger: LoggerService) { logger.logInfo('Creating HeroBiosAndContactsComponent'); } }</code-example><p translation-result="on">注意看模板：</p><p translation-origin="off">Focus on the template:</p><code-example path="dependency-injection-in-action/src/app/hero-bios.component.ts" region="template" header="dependency-injection-in-action/src/app/hero-bios.component.ts" linenums="false"><a href="/api/core/Component#template" class="code-anchor">template</a>: ` &#x3C;app-hero-bio [heroId]="1"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio> &#x3C;app-hero-bio [heroId]="2"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio> &#x3C;app-hero-bio [heroId]="3"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio>`,</code-example><p translation-result="on">在 <code>&#x3C;hero-bio></code> 标签中是一个新的 <code>&#x3C;hero-contact></code> 元素。Angular 就会把相应的 <code>HeroContactComponent</code><em>投影</em>(<em>transclude</em>)进 <code>HeroBioComponent</code> 的视图里， 将它放在 <code>HeroBioComponent</code> 模板的 <code>&#x3C;ng-content></code> 标签槽里。</p><p translation-origin="off">Now there's a new <code>&#x3C;hero-contact></code> element between the <code>&#x3C;hero-bio></code> tags. Angular <em>projects</em>, or <em>transcludes</em>, the corresponding <code>HeroContactComponent</code> into the <code>HeroBioComponent</code> view, placing it in the <code>&#x3C;ng-content></code> slot of the <code>HeroBioComponent</code> template.</p><code-example path="dependency-injection-in-action/src/app/hero-bio.component.ts" region="template" header="src/app/hero-bio.component.ts (template)" linenums="false"><a href="/api/core/Component#template" class="code-anchor">template</a>: ` &#x3C;h4>{{hero.name}}&#x3C;/h4> &#x3C;ng-content>&#x3C;/ng-content> &#x3C;<a href="/api/forms/DefaultValueAccessor" class="code-anchor">textarea</a> cols="25" [(<a href="/api/forms/NgModel" class="code-anchor">ngModel</a>)]="hero.description">&#x3C;/<a href="/api/forms/DefaultValueAccessor" class="code-anchor">textarea</a>>`,</code-example><p translation-result="on">从 <code>HeroContactComponent</code> 获得的英雄电话号码，被投影到上面的英雄描述里，结果如下：</p><p translation-origin="off">The result is shown below, with the hero's telephone number from <code>HeroContactComponent</code> projected above the hero description.</p><figure><img src="generated/images/guide/dependency-injection-in-action/hero-bio-and-content.png" alt="bio and contact" width="199" height="92"></figure><p translation-result="on">这里的 <code>HeroContactComponent</code> 演示了限定型装饰器。</p><p translation-origin="off">Here's <code>HeroContactComponent</code>, which demonstrates the qualifying decorators.</p><code-example path="dependency-injection-in-action/src/app/hero-contact.component.ts" region="component" header="src/app/hero-contact.component.ts">@<a href="/api/core/Component" class="code-anchor">Component</a>({ selector: 'app-hero-contact', <a href="/api/core/Component#template" class="code-anchor">template</a>: ` &#x3C;div>Phone #: {{phoneNumber}} &#x3C;span *<a href="/api/common/NgIf" class="code-anchor">ngIf</a>="hasLogger">!!!&#x3C;/span>&#x3C;/div>` }) export class HeroContactComponent { hasLogger = false; constructor( @<a href="/api/core/Host" class="code-anchor">Host</a>() // <a href="/api/animations/AnimationQueryOptions#limit" class="code-anchor">limit</a> to the <a href="/api/core/Directive#host" class="code-anchor">host</a> component's instance of the HeroCacheService private heroCache: HeroCacheService, @<a href="/api/core/Host" class="code-anchor">Host</a>() // <a href="/api/animations/AnimationQueryOptions#limit" class="code-anchor">limit</a> <a href="/api/common/PlatformLocation#search" class="code-anchor">search</a> for logger; hides the application-wide logger @<a href="/api/core/Optional" class="code-anchor">Optional</a>() // ok if the logger doesn't exist private loggerService: LoggerService ) { if (loggerService) { this.hasLogger = true; loggerService.logInfo('HeroContactComponent can <a href="/api/animations/browser/testing/MockAnimationDriver#log" class="code-anchor">log</a>!'); } } get phoneNumber() { return this.heroCache.hero.phone; } }</code-example><p translation-result="on">注意构造函数的参数。</p><p translation-origin="off">Focus on the constructor parameters.</p><code-example path="dependency-injection-in-action/src/app/hero-contact.component.ts" region="ctor-params" header="src/app/hero-contact.component.ts" linenums="false">@<a href="/api/core/Host" class="code-anchor">Host</a>() // <a href="/api/animations/AnimationQueryOptions#limit" class="code-anchor">limit</a> to the <a href="/api/core/Directive#host" class="code-anchor">host</a> component's instance of the HeroCacheService private heroCache: HeroCacheService, @<a href="/api/core/Host" class="code-anchor">Host</a>() // <a href="/api/animations/AnimationQueryOptions#limit" class="code-anchor">limit</a> <a href="/api/common/PlatformLocation#search" class="code-anchor">search</a> for logger; hides the application-wide logger @<a href="/api/core/Optional" class="code-anchor">Optional</a>() // ok if the logger doesn't exist private loggerService: LoggerService</code-example><p translation-result="on"><code>@<a href="/api/core/Host" class="code-anchor">Host</a>()</code> 函数是构造函数属性 <code>heroCache</code> 的装饰器，确保从其父组件 <code>HeroBioComponent</code> 得到一个缓存服务。如果该父组件不存在这个服务，Angular 就会抛出错误，即使组件树里的再上级有某个组件拥有这个服务，Angular 也会抛出错误。</p><p translation-origin="off">The <code>@<a href="/api/core/Host" class="code-anchor">Host</a>()</code> function decorating the <code>heroCache</code> constructor property ensures that you get a reference to the cache service from the parent <code>HeroBioComponent</code>. Angular throws an error if the parent lacks that service, even if a component higher in the component tree includes it.</p><p translation-result="on">另一个 <code>@<a href="/api/core/Host" class="code-anchor">Host</a>()</code> 函数是构造函数属性 <code>loggerService</code> 的装饰器。 在本应用程序中只有一个在 <code>AppComponent</code> 级提供的 <code>LoggerService</code> 实例。 该宿主 <code>HeroBioComponent</code> 没有自己的 <code>LoggerService</code> 提供商。</p><p translation-origin="off">A second <code>@<a href="/api/core/Host" class="code-anchor">Host</a>()</code> function decorates the <code>loggerService</code> constructor property. The only <code>LoggerService</code> instance in the app is provided at the <code>AppComponent</code> level. The host <code>HeroBioComponent</code> doesn't have its own <code>LoggerService</code> provider.</p><p translation-result="on">如果没有同时使用 <code>@<a href="/api/core/Optional" class="code-anchor">Optional</a>()</code> 装饰器的话，Angular 就会抛出错误。当该属性带有 <code>@<a href="/api/core/Optional" class="code-anchor">Optional</a>()</code> 标记时，Angular 就会把 <code>loggerService</code> 设置为 null，并继续执行组件而不会抛出错误。</p><p translation-origin="off">Angular throws an error if you haven't also decorated the property with <code>@<a href="/api/core/Optional" class="code-anchor">Optional</a>()</code>. When the property is marked as optional, Angular sets <code>loggerService</code> to null and the rest of the component adapts.</p><p translation-result="on">下面是 <code>HeroBiosAndContactsComponent</code> 的执行结果：</p><p translation-origin="off">Here's <code>HeroBiosAndContactsComponent</code> in action.</p><figure><img src="generated/images/guide/dependency-injection-in-action/hero-bios-and-contacts.png" alt="Bios with contact into" width="206" height="393"></figure><p translation-result="on">如果注释掉 <code>@<a href="/api/core/Host" class="code-anchor">Host</a>()</code> 装饰器，Angular 就会沿着注入器树往上走，直到在 <code>AppComponent</code> 中找到该日志服务。日志服务的逻辑加了进来，所显示的英雄信息增加了 "!!!" 标记，这表明确实找到了日志服务。</p><p translation-origin="off">If you comment out the <code>@<a href="/api/core/Host" class="code-anchor">Host</a>()</code> decorator, Angular walks up the injector ancestor tree until it finds the logger at the <code>AppComponent</code> level. The logger logic kicks in and the hero display updates with the "!!!" marker to indicate that the logger was found.</p><figure><img src="generated/images/guide/dependency-injection-in-action/hero-bio-contact-no-host.png" alt="Without @Host" width="199" height="93"></figure><p translation-result="on">如果你恢复了 <code>@<a href="/api/core/Host" class="code-anchor">Host</a>()</code> 装饰器，并且注释掉 <code>@<a href="/api/core/Optional" class="code-anchor">Optional</a></code> 装饰器，应用就会抛出一个错误，因为它在宿主组件这一层找不到所需的 <code>Logger</code>。<code>EXCEPTION: No provider for LoggerService! (HeroContactComponent -> LoggerService)</code></p><p translation-origin="off">If you restore the <code>@<a href="/api/core/Host" class="code-anchor">Host</a>()</code> decorator and comment out <code>@<a href="/api/core/Optional" class="code-anchor">Optional</a></code>, the app throws an exception when it cannot find the required logger at the host component level. <code>EXCEPTION: No provider for LoggerService! (HeroContactComponent -> LoggerService)</code></p><h3 translation-result="on" id="使用-inject-指定自定义提供商">使用 <code>@<a href="/api/core/Inject" class="code-anchor">Inject</a></code> 指定自定义提供商<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#使用-inject-指定自定义提供商"><i class="material-icons">link</i></a></h3><h3 translation-origin="off" id="supply-a-custom-provider-with-inject">Supply a custom provider with <code>@<a href="/api/core/Inject" class="code-anchor">Inject</a></code><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#supply-a-custom-provider-with-inject"><i class="material-icons">link</i></a></h3><p translation-result="on">自定义提供商让你可以为隐式依赖提供一个具体的实现，比如内置浏览器 API。下面的例子使用 <code><a href="/api/core/InjectionToken" class="code-anchor">InjectionToken</a></code> 来提供 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage">localStorage</a>，将其作为 <code>BrowserStorageService</code> 的依赖项。</p><p translation-origin="off">Using a custom provider allows you to provide a concrete implementation for implicit dependencies, such as built-in browser APIs. The following example uses an <code><a href="/api/core/InjectionToken" class="code-anchor">InjectionToken</a></code> to provide the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage">localStorage</a> browser API as a dependency in the <code>BrowserStorageService</code>.</p><code-example path="dependency-injection-in-action/src/app/storage.service.ts" header="src/app/storage.service.ts">import { <a href="/api/core/Inject" class="code-anchor">Inject</a>, <a href="/api/core/Injectable" class="code-anchor">Injectable</a>, <a href="/api/core/InjectionToken" class="code-anchor">InjectionToken</a> } from '@angular/core'; export const BROWSER_STORAGE = new <a href="/api/core/InjectionToken" class="code-anchor">InjectionToken</a>&#x3C;Storage>('Browser Storage', { <a href="/api/core/Injectable#providedIn" class="code-anchor">providedIn</a>: 'root', <a href="/api/core/ResolvedReflectiveFactory#factory" class="code-anchor">factory</a>: () => localStorage }); @<a href="/api/core/Injectable" class="code-anchor">Injectable</a>({ <a href="/api/core/Injectable#providedIn" class="code-anchor">providedIn</a>: 'root' }) export class BrowserStorageService { constructor(@<a href="/api/core/Inject" class="code-anchor">Inject</a>(BROWSER_STORAGE) public storage: Storage) {} get(key: string) { this.storage.getItem(key); } set(key: string, value: string) { this.storage.setItem(key, value); } remove(key: string) { this.storage.removeItem(key); } clear() { this.storage.clear(); } }</code-example><p translation-result="on"><code><a href="/api/core/ResolvedReflectiveFactory#factory" class="code-anchor">factory</a></code> 函数返回 window 对象上的 <code>localStorage</code> 属性。<code><a href="/api/core/Inject" class="code-anchor">Inject</a></code> 装饰器修饰一个构造函数参数，用于为某个依赖提供自定义提供商。现在，就可以在测试期间使用 <code>localStorage</code> 的 Mock API 来覆盖这个提供商了，而不必与真实的浏览器 API 进行交互。</p><p translation-origin="off">The <code><a href="/api/core/ResolvedReflectiveFactory#factory" class="code-anchor">factory</a></code> function returns the <code>localStorage</code> property that is attached to the browser window object. The <code><a href="/api/core/Inject" class="code-anchor">Inject</a></code> decorator is a constructor parameter used to specify a custom provider of a dependency. This custom provider can now be overridden during testing with a mock API of <code>localStorage</code> instead of interactive with real browser APIs.</p><h3 translation-result="on" id="使用-self-和-skipself-来修改提供商的搜索方式">使用 <code>@<a href="/api/core/Self" class="code-anchor">Self</a></code> 和 <code>@<a href="/api/core/SkipSelf" class="code-anchor">SkipSelf</a></code> 来修改提供商的搜索方式<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#使用-self-和-skipself-来修改提供商的搜索方式"><i class="material-icons">link</i></a></h3><h3 translation-origin="off" id="modify-the-provider-search-with-self-and-skipself">Modify the provider search with <code>@<a href="/api/core/Self" class="code-anchor">Self</a></code> and <code>@<a href="/api/core/SkipSelf" class="code-anchor">SkipSelf</a></code><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#modify-the-provider-search-with-self-and-skipself"><i class="material-icons">link</i></a></h3><p translation-result="on">注入器也可以通过构造函数的参数装饰器来指定范围。下面的例子就在 <code><a href="/api/core/Component" class="code-anchor">Component</a></code> 类的 <code>providers</code> 中使用浏览器的 <code>sessionStorage</code> API 覆盖了 <code>BROWSER_STORAGE</code> 令牌。同一个 <code>BrowserStorageService</code> 在构造函数中使用 <code>@<a href="/api/core/Self" class="code-anchor">Self</a></code> 和 <code>@<a href="/api/core/SkipSelf" class="code-anchor">SkipSelf</a></code> 装饰器注入了两次，来分别指定由哪个注入器来提供依赖。</p><p translation-origin="off">Providers can also be scoped by injector through constructor parameter decorators. The following example overrides the <code>BROWSER_STORAGE</code> token in the <code><a href="/api/core/Component" class="code-anchor">Component</a></code> class <code>providers</code> with the <code>sessionStorage</code> browser API. The same <code>BrowserStorageService</code> is injected twice in the constructor, decorated with <code>@<a href="/api/core/Self" class="code-anchor">Self</a></code> and <code>@<a href="/api/core/SkipSelf" class="code-anchor">SkipSelf</a></code> to define which injector handles the provider dependency.</p><code-example path="dependency-injection-in-action/src/app/storage.component.ts" header="src/app/storage.component.ts">import { <a href="/api/core/Component" class="code-anchor">Component</a>, <a href="/api/core/OnInit" class="code-anchor">OnInit</a>, <a href="/api/core/Self" class="code-anchor">Self</a>, <a href="/api/core/SkipSelf" class="code-anchor">SkipSelf</a> } from '@angular/core'; import { BROWSER_STORAGE, BrowserStorageService } from './storage.service'; @<a href="/api/core/Component" class="code-anchor">Component</a>({ selector: 'app-storage', <a href="/api/core/Component#template" class="code-anchor">template</a>: ` <a href="/api/http/ReadyState#Open" class="code-anchor">Open</a> the inspector to see the local/session storage <a href="/api/router/ParamMap#keys" class="code-anchor">keys</a>: &#x3C;h3>Session Storage&#x3C;/h3> &#x3C;button (click)="setSession()">Set Session Storage&#x3C;/button> &#x3C;h3>Local Storage&#x3C;/h3> &#x3C;button (click)="setLocal()">Set Local Storage&#x3C;/button> `, providers: [ BrowserStorageService, { provide: BROWSER_STORAGE, useFactory: () => sessionStorage } ] }) export class StorageComponent implements <a href="/api/core/OnInit" class="code-anchor">OnInit</a> { constructor( @<a href="/api/core/Self" class="code-anchor">Self</a>() private sessionStorageService: BrowserStorageService, @<a href="/api/core/SkipSelf" class="code-anchor">SkipSelf</a>() private localStorageService: BrowserStorageService, ) { } ngOnInit() { } setSession() { this.sessionStorageService.set('hero', 'Mr. Nice - Session'); } setLocal() { this.localStorageService.set('hero', 'Mr. Nice - Local'); } }</code-example><p translation-result="on">使用 <code>@<a href="/api/core/Self" class="code-anchor">Self</a></code> 装饰器时，注入器只在该组件的注入器中查找提供商。<code>@<a href="/api/core/SkipSelf" class="code-anchor">SkipSelf</a></code> 装饰器可以让你跳过局部注入器，并在注入器树中向上查找，以发现哪个提供商满足该依赖。 <code>sessionStorageService</code> 实例使用浏览器的 <code>sessionStorage</code> 来跟 <code>BrowserStorageService</code> 打交道，而 <code>localStorageService</code> 跳过了局部注入器，使用根注入器提供的 <code>BrowserStorageService</code>，它使用浏览器的 <code>localStorage</code> API。</p><p translation-origin="off">Using the <code>@<a href="/api/core/Self" class="code-anchor">Self</a></code> decorator, the injector only looks at the component's injector for its providers. The <code>@<a href="/api/core/SkipSelf" class="code-anchor">SkipSelf</a></code> decorator allows you to skip the local injector and look up in the hierarchy to find a provider that satisfies this dependency. The <code>sessionStorageService</code> instance interacts with the <code>BrowserStorageService</code> using the <code>sessionStorage</code> browser API, while the <code>localStorageService</code> skips the local injector and uses the root <code>BrowserStorageService</code> that uses the <code>localStorage</code> browswer API.</p><a id="component-element"></a><h2 translation-result="on" id="注入组件的-dom-元素">注入组件的 DOM 元素<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#注入组件的-dom-元素"><i class="material-icons">link</i></a></h2><h2 translation-origin="off" id="inject-the-components-dom-element">Inject the component's DOM element<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#inject-the-components-dom-element"><i class="material-icons">link</i></a></h2><p translation-result="on">即便开发者极力避免，仍然会有很多视觉效果和第三方工具 (比如 jQuery) 需要访问 DOM。这会让你不得不访问组件所在的 DOM 元素。</p><p translation-origin="off">Although developers strive to avoid it, many visual effects and third-party tools, such as jQuery, require DOM access. As a result, you might need to access a component's DOM element.</p><p translation-result="on">要说明这一点，请在<a href="/guide/attribute-directives">属性型指令</a><code>HighlightDirective</code> 的基础上，编写一个简化版。</p><p translation-origin="off">To illustrate, here's a simplified version of <code>HighlightDirective</code> from the <a href="/guide/attribute-directives">Attribute Directives</a> page.</p><code-example path="dependency-injection-in-action/src/app/highlight.directive.ts" header="src/app/highlight.directive.ts">import { <a href="/api/core/Directive" class="code-anchor">Directive</a>, <a href="/api/core/ElementRef" class="code-anchor">ElementRef</a>, <a href="/api/core/HostListener" class="code-anchor">HostListener</a>, <a href="/api/core/Input" class="code-anchor">Input</a> } from '@angular/core'; @<a href="/api/core/Directive" class="code-anchor">Directive</a>({ selector: '[appHighlight]' }) export class HighlightDirective { @<a href="/api/core/Input" class="code-anchor">Input</a>('appHighlight') highlightColor: string; private el: HTMLElement; constructor(el: <a href="/api/core/ElementRef" class="code-anchor">ElementRef</a>) { this.el = el.nativeElement; } @<a href="/api/core/HostListener" class="code-anchor">HostListener</a>('mouseenter') onMouseEnter() { this.highlight(this.highlightColor || 'cyan'); } @<a href="/api/core/HostListener" class="code-anchor">HostListener</a>('mouseleave') onMouseLeave() { this.highlight(null); } private highlight(color: string) { this.el.style.backgroundColor = color; } }</code-example><p translation-result="on">当用户把鼠标移到 DOM 元素上时，指令将指令所在的元素的背景设置为一个高亮颜色。</p><p translation-origin="off">The directive sets the background to a highlight color when the user mouses over the DOM element to which the directive is applied.</p><p translation-result="on">Angular 把构造函数参数 <code>el</code> 设置为注入的 <code><a href="/api/core/ElementRef" class="code-anchor">ElementRef</a></code>，该 <code><a href="/api/core/ElementRef" class="code-anchor">ElementRef</a></code> 代表了宿主的 DOM 元素， 它的 <code>nativeElement</code> 属性把该 DOM 元素暴露给了指令。</p><p translation-origin="off">Angular sets the constructor's <code>el</code> parameter to the injected <code><a href="/api/core/ElementRef" class="code-anchor">ElementRef</a></code>. (An <code><a href="/api/core/ElementRef" class="code-anchor">ElementRef</a></code> is a wrapper around a DOM element, whose <code>nativeElement</code> property exposes the DOM element for the directive to manipulate.)</p><p translation-result="on">下面的代码把指令的 <code>myHighlight</code> 属性(Attribute)填加到两个 <code>&#x3C;div></code> 标签里，一个没有赋值，一个赋值了颜色。</p><p translation-origin="off">The sample code applies the directive's <code>myHighlight</code> attribute to two <code>&#x3C;div></code> tags, first without a value (yielding the default color) and then with an assigned color value.</p><code-example path="dependency-injection-in-action/src/app/app.component.html" region="highlight" header="src/app/app.component.html (highlight)" linenums="false">&#x3C;div id="highlight" class="di-component" appHighlight> &#x3C;h3>Hero Bios and Contacts&#x3C;/h3> &#x3C;div appHighlight="yellow"> &#x3C;app-hero-bios-and-contacts>&#x3C;/app-hero-bios-and-contacts> &#x3C;/div> &#x3C;/div></code-example><p translation-result="on">下图显示了鼠标移到 <code>&#x3C;hero-bios-and-contacts></code> 标签的效果：</p><p translation-origin="off">The following image shows the effect of mousing over the <code>&#x3C;hero-bios-and-contacts></code> tag.</p><figure><img src="generated/images/guide/dependency-injection-in-action/highlight.png" alt="Highlighted bios" width="318" height="196"></figure><a id="providers"></a><h2 translation-result="on" id="使用提供商来定义依赖">使用提供商来定义依赖<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#使用提供商来定义依赖"><i class="material-icons">link</i></a></h2><h2 translation-origin="off" id="define-dependencies-with-providers">Define dependencies with providers<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#define-dependencies-with-providers"><i class="material-icons">link</i></a></h2><p translation-result="on">本节会示范如何编写提供商来交付被依赖的服务。</p><p translation-origin="off">This section demonstrates how to write providers that deliver dependent services.</p><p translation-result="on">为了从依赖注入器中获取服务，你必须传给它一个<a href="/guide/glossary#token">令牌</a>。 Angular 通常会通过指定构造函数参数以及参数的类型来处理它。 参数的类型可以用作注入器的查阅令牌。 Angular 会把该令牌传给注入器，并把它的结果赋给相应的参数。</p><p translation-origin="off">In order to get a service from a dependency injector, you have to give it a <a href="/guide/glossary#token">token</a>. Angular usually handles this transaction by specifying a constructor parameter and its type. The parameter type serves as the injector lookup token. Angular passes this token to the injector and assigns the result to the parameter.</p><p translation-result="on">下面是一个典型的例子。</p><p translation-origin="off">The following is a typical example.</p><code-example path="dependency-injection-in-action/src/app/hero-bios.component.ts" region="ctor" header="src/app/hero-bios.component.ts (component constructor injection)" linenums="false">constructor(logger: LoggerService) { logger.logInfo('Creating HeroBiosComponent'); }</code-example><p translation-result="on">Angular 会要求注入器提供与 <code>LoggerService</code> 相关的服务，并把返回的值赋给 <code>logger</code> 参数。</p><p translation-origin="off">Angular asks the injector for the service associated with <code>LoggerService</code> and assigns the returned value to the <code>logger</code> parameter.</p><p translation-result="on">如果注入器已经缓存了与该令牌相关的服务实例，那么它就会直接提供此实例。 如果它没有，它就要使用与该令牌相关的提供商来创建一个。</p><p translation-origin="off">If the injector has already cached an instance of the service associated with the token, it provides that instance. If it doesn't, it needs to make one using the provider associated with the token.</p><div class="alert is-helpful"><p translation-result="on">如果注入器无法根据令牌在自己内部找到对应的提供商，它便将请求移交给它的父级注入器，这个过程不断重复，直到没有更多注入器为止。 如果没找到，注入器就抛出一个错误...除非这个请求是<a href="/guide/dependency-injection-in-action#optional">可选的</a>。</p><p translation-origin="off">If the injector doesn't have a provider for a requested token, it delegates the request to its parent injector, where the process repeats until there are no more injectors. If the search fails, the injector throws an error—unless the request was <a href="/guide/dependency-injection-in-action#optional">optional</a>.</p></div><p translation-result="on">新的注入器没有提供商。 Angular 会使用一组首选提供商来初始化它本身的注入器。 你必须为自己应用程序特有的依赖项来配置提供商。</p><p translation-origin="off">A new injector has no providers. Angular initializes the injectors it creates with a set of preferred providers. You have to configure providers for your own app-specific dependencies.</p><a id="defining-providers"></a><h3 translation-result="on" id="定义提供商">定义提供商<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#定义提供商"><i class="material-icons">link</i></a></h3><h3 translation-origin="off" id="defining-providers">Defining providers<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#defining-providers"><i class="material-icons">link</i></a></h3><p translation-result="on">用于实例化类的默认方法不一定总适合用来创建依赖。你可以到<a href="/guide/dependency-injection-providers">依赖提供商</a>部分查看其它方法。 <code>HeroOfTheMonthComponent</code> 例子示范了一些替代方案，展示了为什么需要它们。 它看起来很简单：一些属性和一些由 logger 生成的日志。</p><p translation-origin="off">A dependency can't always be created by the default method of instantiating a class. You learned about some other methods in <a href="/guide/dependency-injection-providers">Dependency Providers</a>. The following <code>HeroOfTheMonthComponent</code> example demonstrates many of the alternatives and why you need them. It's visually simple: a few properties and the logs produced by a logger.</p><figure><img src="generated/images/guide/dependency-injection-in-action/hero-of-month.png" alt="Hero of the month" width="300" height="165"></figure><p translation-result="on">它背后的代码定制了 DI 框架提供依赖项的方法和位置。 这个例子阐明了通过<a href="/guide/dependency-injection-providers#provide"><em>提供</em>对象字面量</a>来把对象的定义和 DI 令牌关联起来的另一种方式。</p><p translation-origin="off">The code behind it customizes how and where the DI framework provides dependencies. The use cases illustrate different ways to use the <a href="/guide/dependency-injection-providers#provide"><em>provide</em> object literal</a> to associate a definition object with a DI token.</p><code-example path="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" region="hero-of-the-month" header="hero-of-the-month.component.ts">import { <a href="/api/core/Component" class="code-anchor">Component</a>, <a href="/api/core/Inject" class="code-anchor">Inject</a> } from '@angular/core'; import { DateLoggerService } from './date-logger.service'; import { Hero } from './hero'; import { HeroService } from './hero.service'; import { LoggerService } from './logger.service'; import { MinimalLogger } from './minimal-logger.service'; import { RUNNERS_UP, runnersUpFactory } from './runners-up'; @<a href="/api/core/Component" class="code-anchor">Component</a>({ selector: 'app-hero-of-the-month', templateUrl: './hero-of-the-month.component.html', providers: [ { provide: Hero, useValue: someHero }, { provide: TITLE, useValue: 'Hero of the Month' }, { provide: HeroService, useClass: HeroService }, { provide: LoggerService, useClass: DateLoggerService }, { provide: MinimalLogger, useExisting: LoggerService }, { provide: RUNNERS_UP, useFactory: runnersUpFactory(2), <a href="/api/core/ConstructorSansProvider#deps" class="code-anchor">deps</a>: [Hero, HeroService] } ] }) export class HeroOfTheMonthComponent { logs: string[] = []; constructor( logger: MinimalLogger, public heroOfTheMonth: Hero, @<a href="/api/core/Inject" class="code-anchor">Inject</a>(RUNNERS_UP) public runnersUp: string, @<a href="/api/core/Inject" class="code-anchor">Inject</a>(TITLE) public title: string) { this.logs = logger.logs; logger.logInfo('starting up'); } }</code-example><p translation-result="on"><code>providers</code> 数组展示了你可以如何使用其它的键来定义提供商：<code>useValue</code>、<code>useClass</code>、<code>useExisting</code> 或 <code>useFactory</code>。</p><p translation-origin="off">The <code>providers</code> array shows how you might use the different provider-definition keys; <code>useValue</code>, <code>useClass</code>, <code>useExisting</code>, or <code>useFactory</code>.</p><a id="usevalue"></a><h4 translation-result="on" id="值提供商：usevalue">值提供商：<code>useValue</code><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#值提供商：usevalue"><i class="material-icons">link</i></a></h4><h4 translation-origin="off" id="value-providers-usevalue">Value providers: <code>useValue</code><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#value-providers-usevalue"><i class="material-icons">link</i></a></h4><p translation-result="on"><code>useValue</code> 键让你可以为 DI 令牌关联一个固定的值。 使用该技巧来进行<em>运行期常量设置</em>，比如网站的基础地址和功能标志等。 你也可以在单元测试中使用<em>值提供商</em>，来用一个 Mock 数据来代替一个生产环境下的数据服务。</p><p translation-origin="off">The <code>useValue</code> key lets you associate a fixed value with a DI token. Use this technique to provide <em>runtime configuration constants</em> such as website base addresses and feature flags. You can also use a value provider in a unit test to provide mock data in place of a production data service.</p><p translation-result="on"><code>HeroOfTheMonthComponent</code> 例子中有两个<em>值-提供商</em>。</p><p translation-origin="off">The <code>HeroOfTheMonthComponent</code> example has two value providers.</p><code-example path="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" region="use-value" header="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" linenums="false">{ provide: Hero, useValue: someHero }, { provide: TITLE, useValue: 'Hero of the Month' },</code-example><ul><li><p translation-result="on">第一处提供了用于 <code>Hero</code> 令牌的 <code>Hero</code> 类的现有实例，而不是要求注入器使用 <code>new</code> 来创建一个新实例或使用它自己的缓存实例。这里令牌就是这个类本身。</p><p translation-origin="off">The first provides an existing instance of the <code>Hero</code> class to use for the <code>Hero</code> token, rather than requiring the injector to create a new instance with <code>new</code> or use its own cached instance. Here, the token is the class itself.</p></li><li><p translation-result="on">第二处为 <code>TITLE</code> 令牌指定了一个字符串字面量资源。 <code>TITLE</code> 提供商的令牌<em>不是一个类</em>，而是一个特别的提供商查询键，名叫<a href="/guide/dependency-injection-in-action#injection-token">InjectionToken</a>，表示一个 <code><a href="/api/core/InjectionToken" class="code-anchor">InjectionToken</a></code> 实例。</p><p translation-origin="off">The second specifies a literal string resource to use for the <code>TITLE</code> token. The <code>TITLE</code> provider token is <em>not</em> a class, but is instead a special kind of provider lookup key called an <a href="/guide/dependency-injection-in-action#injection-token">injection token</a>, represented by an <code><a href="/api/core/InjectionToken" class="code-anchor">InjectionToken</a></code> instance.</p></li></ul><p translation-result="on">你可以把 <code><a href="/api/core/InjectionToken" class="code-anchor">InjectionToken</a></code> 用作任何类型的提供商的令牌，但是当依赖是简单类型（比如字符串、数字、函数）时，它会特别有用。</p><p translation-origin="off">You can use an injection token for any kind of provider but it's particularly helpful when the dependency is a simple value like a string, a number, or a function.</p><p translation-result="on">一个<em>值-提供商</em>的值必须在指定之前定义。 比如标题字符串就是立即可用的。 该例中的 <code>someHero</code> 变量是以前在如下的文件中定义的。 你不能使用那些要等以后才能定义其值的变量。</p><p translation-origin="off">The value of a <em>value provider</em> must be defined before you specify it here. The title string literal is immediately available. The <code>someHero</code> variable in this example was set earlier in the file as shown below. You can't use a variable whose value will be defined later.</p><code-example path="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" region="some-hero" header="dependency-injection-in-action/src/app/hero-of-the-month.component.ts">const someHero = new Hero(42, 'Magma', 'Had <a href="/api/router/RouterLinkWithHref" class="code-anchor">a</a> great month!', '555-555-5555');</code-example><p translation-result="on">其它类型的提供商都会<em>惰性创建</em>它们的值，也就是说只在需要注入它们的时候才创建。</p><p translation-origin="off">Other types of providers can create their values <em>lazily</em>; that is, when they're needed for injection.</p><a id="useclass"></a><h4 translation-result="on" id="类提供商：useclass">类提供商：<code>useClass</code><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#类提供商：useclass"><i class="material-icons">link</i></a></h4><h4 translation-origin="off" id="class-providers-useclass">Class providers: <code>useClass</code><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#class-providers-useclass"><i class="material-icons">link</i></a></h4><p translation-result="on"><code>useClass</code> 提供的键让你可以创建并返回指定类的新实例。</p><p translation-origin="off">The <code>useClass</code> provider key lets you create and return a new instance of the specified class.</p><p translation-result="on">你可以使用这类提供商来为公共类或默认类换上一个<em>替代实现</em>。比如，这个替代实现可以实现一种不同的策略来扩展默认类，或在测试环境中模拟真实类的行为。</p><p translation-origin="off">You can use this type of provider to substitute an <em>alternative implementation</em> for a common or default class. The alternative implementation could, for example, implement a different strategy, extend the default class, or emulate the behavior of the real class in a test case.</p><p translation-result="on">请看下面 <code>HeroOfTheMonthComponent</code> 里的两个例子：</p><p translation-origin="off">The following code shows two examples in <code>HeroOfTheMonthComponent</code>.</p><code-example path="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" region="use-class" header="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" linenums="false">{ provide: HeroService, useClass: HeroService }, { provide: LoggerService, useClass: DateLoggerService },</code-example><p translation-result="on">第一个提供商是<em>展开了语法糖的</em>，是一个典型情况的展开。一般来说，被新建的类(<code>HeroService</code>)同时也是该提供商的注入令牌。 通常都选用缩写形式，完整形式可以让细节更明确。</p><p translation-origin="off">The first provider is the <em>de-sugared</em>, expanded form of the most typical case in which the class to be created (<code>HeroService</code>) is also the provider's dependency injection token. The short form is generally preferred; this long form makes the details explicit.</p><p translation-result="on">第二个提供商使用 <code>DateLoggerService</code> 来满足 <code>LoggerService</code>。该 <code>LoggerService</code> 在 <code>AppComponent</code> 级别已经被注册。当<em>这个组件</em>要求 <code>LoggerService</code> 的时候，它得到的却是 <code>DateLoggerService</code> 服务的实例。</p><p translation-origin="off">The second provider substitutes <code>DateLoggerService</code> for <code>LoggerService</code>. <code>LoggerService</code> is already registered at the <code>AppComponent</code> level. When this child component requests <code>LoggerService</code>, it receives a <code>DateLoggerService</code> instance instead.</p><div class="alert is-helpful"><p translation-result="on">这个组件及其子组件会得到 <code>DateLoggerService</code> 实例。这个组件树之外的组件得到的仍是 <code>LoggerService</code> 实例。</p><p translation-origin="off">This component and its tree of child components receive <code>DateLoggerService</code> instance. Components outside the tree continue to receive the original <code>LoggerService</code> instance.</p></div><p translation-result="on"><code>DateLoggerService</code> 从 <code>LoggerService</code> 继承；它把当前的日期/时间附加到每条信息上。</p><p translation-origin="off"><code>DateLoggerService</code> inherits from <code>LoggerService</code>; it appends the current date/time to each message:</p><code-example path="dependency-injection-in-action/src/app/date-logger.service.ts" region="date-logger-service" header="src/app/date-logger.service.ts" linenums="false">@<a href="/api/core/Injectable" class="code-anchor">Injectable</a>({ <a href="/api/core/Injectable#providedIn" class="code-anchor">providedIn</a>: 'root' }) export class DateLoggerService extends LoggerService { logInfo(msg: any) { super.logInfo(stamp(msg)); } logDebug(msg: any) { super.logInfo(stamp(msg)); } logError(msg: any) { super.logError(stamp(msg)); } } function stamp(msg: any) { return msg + ' at ' + new Date(); }</code-example><a id="useexisting"></a><h4 translation-result="on" id="别名提供商：useexisting">别名提供商：<code>useExisting</code><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#别名提供商：useexisting"><i class="material-icons">link</i></a></h4><h4 translation-origin="off" id="alias-providers-useexisting">Alias providers: <code>useExisting</code><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#alias-providers-useexisting"><i class="material-icons">link</i></a></h4><p translation-result="on"><code>useExisting</code> 提供了一个键，让你可以把一个令牌映射成另一个令牌。实际上，第一个令牌就是第二个令牌所关联的服务的<em>别名</em>，这样就创建了访问同一个服务对象的两种途径。</p><p translation-origin="off">The <code>useExisting</code> provider key lets you map one token to another. In effect, the first token is an <em>alias</em> for the service associated with the second token, creating two ways to access the same service object.</p><code-example path="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" region="use-existing" header="dependency-injection-in-action/src/app/hero-of-the-month.component.ts">{ provide: MinimalLogger, useExisting: LoggerService },</code-example><p translation-result="on">你可以使用别名接口来窄化 API。下面的例子中使用别名就是为了这个目的。</p><p translation-origin="off">You can use this technique to narrow an API through an aliasing interface. The following example shows an alias introduced for that purpose.</p><p translation-result="on">想象 <code>LoggerService</code> 有个很大的 API 接口，远超过现有的三个方法和一个属性。你可能希望把 API 接口收窄到只有两个你确实需要的成员。在这个例子中，<a href="/guide/dependency-injection-in-action#class-interface" translation-result="on"><em>类-接口</em></a><code translation-origin="off">MinimalLogger</code>，就这个 API 成功缩小到了只有两个成员：</p><p translation-origin="off">Imagine that <code>LoggerService</code> had a large API, much larger than the actual three methods and a property. You might want to shrink that API surface to just the members you actually need. In this example, the <code>MinimalLogger</code> <a href="/guide/dependency-injection-in-action#class-interface">class-interface</a> reduces the API to two members:</p><code-example path="dependency-injection-in-action/src/app/minimal-logger.service.ts" header="src/app/minimal-logger.service.ts" linenums="false">// Class used as <a href="/api/router/RouterLinkWithHref" class="code-anchor">a</a> "narrowing" interface that exposes <a href="/api/router/RouterLinkWithHref" class="code-anchor">a</a> minimal logger // <a href="/api/common/Plural#Other" class="code-anchor">Other</a> members of the actual implementation are invisible export abstract class MinimalLogger { logs: string[]; logInfo: (msg: string) => void; }</code-example><p translation-result="on">下面的例子在一个简化版的 <code>HeroOfTheMonthComponent</code> 中使用 <code>MinimalLogger</code>。</p><p translation-origin="off">The following example puts <code>MinimalLogger</code> to use in a simplified version of <code>HeroOfTheMonthComponent</code>.</p><code-example path="dependency-injection-in-action/src/app/hero-of-the-month.component.1.ts" header="src/app/hero-of-the-month.component.ts (minimal version)" linenums="false">@<a href="/api/core/Component" class="code-anchor">Component</a>({ selector: 'app-hero-of-the-month', templateUrl: './hero-of-the-month.component.html', // TODO: move this aliasing, `useExisting` provider to the AppModule providers: [{ provide: MinimalLogger, useExisting: LoggerService }] }) export class HeroOfTheMonthComponent { logs: string[] = []; constructor(logger: MinimalLogger) { logger.logInfo('starting up'); } }</code-example><p translation-result="on"><code>HeroOfTheMonthComponent</code> 构造函数的 <code>logger</code> 参数是一个 <code>MinimalLogger</code> 类型，支持 TypeScript 的编辑器里，只能看到它的两个成员 <code>logs</code> 和 <code>logInfo</code>：</p><p translation-origin="off">The <code>HeroOfTheMonthComponent</code> constructor's <code>logger</code> parameter is typed as <code>MinimalLogger</code>, so only the <code>logs</code> and <code>logInfo</code> members are visible in a TypeScript-aware editor.</p><figure><img src="generated/images/guide/dependency-injection-in-action/minimal-logger-intellisense.png" alt="MinimalLogger restricted API" width="532" height="60"></figure><p translation-result="on">实际上，Angular 把 <code>logger</code> 参数设置为注入器里 <a href="/guide/dependency-injection-in-action#useclass" translation-result="on">以前提供的那个</a><code translation-origin="off">LoggerService</code> 令牌下注册的完整服务，该令牌恰好是 <code>DateLoggerService</code> 实例。</p><p translation-origin="off">Behind the scenes, Angular sets the <code>logger</code> parameter to the full service registered under the <code>LoggingService</code> token, which happens to be the <code>DateLoggerService</code> instance that was <a href="/guide/dependency-injection-in-action#useclass">provided above</a>.</p><div class="alert is-helpful"><p translation-result="on">在下面的图片中，显示了日志日期，可以确认这一点：</p><p translation-origin="off">This is illustrated in the following image, which displays the logging date.</p><figure><img src="generated/images/guide/dependency-injection-in-action/date-logger-entry.png" alt="DateLoggerService entry" width="300" height="32"></figure></div><a id="usefactory"></a><h4 translation-result="on" id="工厂提供商：usefactory">工厂提供商：<code>useFactory</code><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#工厂提供商：usefactory"><i class="material-icons">link</i></a></h4><h4 translation-origin="off" id="factory-providers-usefactory">Factory providers: <code>useFactory</code><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#factory-providers-usefactory"><i class="material-icons">link</i></a></h4><p translation-result="on"><code>useFactory</code> 提供了一个键，让你可以通过调用一个工厂函数来创建依赖实例，如下面的例子所示。</p><p translation-origin="off">The <code>useFactory</code> provider key lets you create a dependency object by calling a factory function, as in the following example.</p><code-example path="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" region="use-factory" header="dependency-injection-in-action/src/app/hero-of-the-month.component.ts">{ provide: RUNNERS_UP, useFactory: runnersUpFactory(2), <a href="/api/core/ConstructorSansProvider#deps" class="code-anchor">deps</a>: [Hero, HeroService] }</code-example><p translation-result="on">注入器通过调用你用 <code>useFactory</code> 键指定的工厂函数来提供该依赖的值。 注意，提供商的这种形态还有第三个键 <code><a href="/api/core/ConstructorSansProvider#deps" class="code-anchor">deps</a></code>，它指定了供 <code>useFactory</code> 函数使用的那些依赖。</p><p translation-origin="off">The injector provides the dependency value by invoking a factory function, that you provide as the value of the <code>useFactory</code> key. Notice that this form of provider has a third key, <code><a href="/api/core/ConstructorSansProvider#deps" class="code-anchor">deps</a></code>, which specifies dependencies for the <code>useFactory</code> function.</p><p translation-result="on">使用这项技术，可以用包含了一些<strong><em>依赖服务和本地状态</em></strong>输入的工厂函数来<strong><em>建立一个依赖对象</em></strong>。</p><p translation-origin="off">Use this technique to create a dependency object with a factory function whose inputs are a combination of <em>injected services</em> and <em>local state</em>.</p><p translation-result="on">这个依赖对象（由工厂函数返回的）通常是一个类实例，不过也可以是任何其它东西。 在这个例子中，依赖对象是一个表示 "月度英雄" 参赛者名称的字符串。</p><p translation-origin="off">The dependency object (returned by the factory function) is typically a class instance, but can be other things as well. In this example, the dependency object is a string of the names of the runners up to the "Hero of the Month" contest.</p><p translation-result="on">在这个例子中，局部状态是数字 <code>2</code>，也就是组件应该显示的参赛者数量。 该状态的值传给了 <code>runnersUpFactory()</code> 作为参数。 <code>runnersUpFactory()</code> 返回了<em>提供商的工厂函数</em>，它可以使用传入的状态值和注入的服务 <code>Hero</code> 和 <code>HeroService</code>。</p><p translation-origin="off">In the example, the local state is the number <code>2</code>, the number of runners up that the component should show. The state value is passed as an argument to <code>runnersUpFactory()</code>. The <code>runnersUpFactory()</code> returns the <em>provider factory function</em>, which can use both the passed-in state value and the injected services <code>Hero</code> and <code>HeroService</code>.</p><code-example path="dependency-injection-in-action/src/app/runners-up.ts" region="factory-synopsis" header="runners-up.ts (excerpt)" linenums="false">export function runnersUpFactory(take: number) { return (winner: Hero, heroService: HeroService): string => { /* ... */ }; };</code-example><p translation-result="on">由 <code>runnersUpFactory()</code> 返回的提供商的工厂函数返回了实际的依赖对象，也就是表示名字的字符串。</p><p translation-origin="off">The provider factory function (returned by <code>runnersUpFactory()</code>) returns the actual dependency object, the string of names.</p><ul><li><p translation-result="on">这个返回的函数需要一个 <code>Hero</code> 和一个 <code>HeroService</code> 参数。</p><p translation-origin="off">The function takes a winning <code>Hero</code> and a <code>HeroService</code> as arguments.</p></li></ul><p translation-result="on">Angular 根据 <code><a href="/api/core/ConstructorSansProvider#deps" class="code-anchor">deps</a></code> 数组中指定的两个<em>令牌</em>来获得这些注入参数。</p><p translation-origin="off">Angular supplies these arguments from injected values identified by the two <em>tokens</em> in the <code><a href="/api/core/ConstructorSansProvider#deps" class="code-anchor">deps</a></code> array.</p><ul><li><p translation-result="on">该函数返回名字的字符串，Angular 可以把它们注入到 <code>HeroOfTheMonthComponent</code> 的 <code>runnersUp</code> 参数中。</p><p translation-origin="off">The function returns the string of names, which Angular than injects into the <code>runnersUp</code> parameter of <code>HeroOfTheMonthComponent</code>.</p></li></ul><div class="alert is-helpful"><p translation-result="on">该函数从 <code>HeroService</code> 中接受候选的英雄，从中取 <code>2</code> 个参加竞赛，并把他们的名字串接起来返回。 参见<live-example name="dependency-injection-in-action"></live-example>查看完整源码。</p><p translation-origin="off">The function retrieves candidate heroes from the <code>HeroService</code>, takes <code>2</code> of them to be the runners-up, and returns their concatenated names. Look at the<live-example name="dependency-injection-in-action"></live-example>for the full source code.</p></div><a id="tokens"></a><h2 translation-result="on" id="提供替代令牌：类接口与-injectiontoken">提供替代令牌：类接口与 'InjectionToken'<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#提供替代令牌：类接口与-injectiontoken"><i class="material-icons">link</i></a></h2><h2 translation-origin="off" id="provider-token-alternatives-class-interface-and-injectiontoken">Provider token alternatives: class interface and 'InjectionToken'<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#provider-token-alternatives-class-interface-and-injectiontoken"><i class="material-icons">link</i></a></h2><p translation-result="on">当使用类作为令牌，同时也把它作为返回依赖对象或服务的类型时，Angular 依赖注入使用起来最容易。</p><p translation-origin="off">Angular dependency injection is easiest when the provider token is a class that is also the type of the returned dependency object, or service.</p><p translation-result="on">但令牌不一定都是类，就算它是一个类，它也不一定都返回类型相同的对象。这是下一节的主题。</p><p translation-origin="off">However, a token doesn't have to be a class and even when it is a class, it doesn't have to be the same type as the returned object. That's the subject of the next section.</p><a id="class-interface"></a><h3 translation-result="on" id="类-接口">类-接口<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#类-接口"><i class="material-icons">link</i></a></h3><h3 translation-origin="off" id="classinterface">Classinterface<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#classinterface"><i class="material-icons">link</i></a></h3><p translation-result="on">前面的<em>月度英雄</em>的例子使用了 <code>MinimalLogger</code> 类作为 <code>LoggerService</code> 提供商的令牌。</p><p translation-origin="off">The previous <em>Hero of the Month</em> example used the <code>MinimalLogger</code> class as the token for a provider of <code>LoggerService</code>.</p><code-example path="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" region="use-existing" header="dependency-injection-in-action/src/app/hero-of-the-month.component.ts">{ provide: MinimalLogger, useExisting: LoggerService },</code-example><p translation-result="on">该 <code>MinimalLogger</code> 是一个抽象类。</p><p translation-origin="off"> <code>MinimalLogger</code> is an abstract class.</p><code-example path="dependency-injection-in-action/src/app/minimal-logger.service.ts" header="dependency-injection-in-action/src/app/minimal-logger.service.ts" linenums="false">// Class used as <a href="/api/router/RouterLinkWithHref" class="code-anchor">a</a> "narrowing" interface that exposes <a href="/api/router/RouterLinkWithHref" class="code-anchor">a</a> minimal logger // <a href="/api/common/Plural#Other" class="code-anchor">Other</a> members of the actual implementation are invisible export abstract class MinimalLogger { logs: string[]; logInfo: (msg: string) => void; }</code-example><p translation-result="on">你通常从一个可扩展的抽象类继承。但这个应用中<em>并没有</em>类会继承 <code>MinimalLogger</code>。</p><p translation-origin="off">An abstract class is usually a base class that you can extend. In this app, however there is no class that inherits from <code>MinimalLogger</code>.</p><p translation-result="on"><code>LoggerService</code> 和 <code>DateLoggerService</code><em>本可以</em>从 <code>MinimalLogger</code> 中继承。 它们也可以实现 <code>MinimalLogger</code>，而不用单独定义接口。 但它们没有。 <code>MinimalLogger</code> 在这里仅仅被用作一个 "依赖注入令牌"。</p><p translation-origin="off">The <code>LoggerService</code> and the <code>DateLoggerService</code>could have inherited from <code>MinimalLogger</code>, or they could have implemented it instead, in the manner of an interface. But they did neither. <code>MinimalLogger</code> is used only as a dependency injection token.</p><p translation-result="on">当你通过这种方式使用类时，它称作<em>类接口</em>。</p><p translation-origin="off">When you use a class this way, it's called a <em>class interface</em>.</p><p translation-result="on">就像 <a href="/guide/dependency-injection-providers#interface-not-valid-token">DI 提供商</a>中提到的那样，接口不是有效的 DI 令牌，因为它是 TypeScript 自己用的，在运行期间不存在。使用这种抽象类接口不但可以获得像接口一样的强类型，而且可以像普通类一样把它用作提供商令牌。</p><p translation-origin="off">As mentioned in <a href="/guide/dependency-injection-providers#interface-not-valid-token">DI Providers</a>, an interface is not a valid DI token because it is a TypeScript artifact that doesn't exist at run time. Use this abstract class interface to get the strong typing of an interface, and also use it as a provider token in the way you would a normal class.</p><p translation-result="on">类接口应该<em>只</em>定义允许它的消费者调用的成员。窄的接口有助于解耦该类的具体实现和它的消费者。</p><p translation-origin="off">A class interface should define <em>only</em> the members that its consumers are allowed to call. Such a narrowing interface helps decouple the concrete class from its consumers.</p><div class="alert is-helpful"><p translation-result="on">用类作为接口可以让你获得真实 JavaScript 对象中的接口的特性。 但是，为了最小化内存开销，该类应该是<em>没有实现</em>的。 对于构造函数，<code>MinimalLogger</code> 会转译成未优化过的、预先最小化过的 JavaScript。</p><p translation-origin="off">Using a class as an interface gives you the characteristics of an interface in a real JavaScript object. To minimize memory cost, however, the class should have <em>no implementation</em>. The <code>MinimalLogger</code> transpiles to this unoptimized, pre-minified JavaScript for a constructor function.</p><code-example path="dependency-injection-in-action/src/app/minimal-logger.service.ts" region="minimal-logger-transpiled" header="dependency-injection-in-action/src/app/minimal-logger.service.ts" linenums="false">var MinimalLogger = (function () { function MinimalLogger() {} return MinimalLogger; }()); <a href="/api/core/NgModule#exports" class="code-anchor">exports</a>("MinimalLogger", MinimalLogger);</code-example><p translation-result="on">注意，<strong><em>只要不实现它</em></strong>，不管添加多少成员，它永远不会增长大小，因为这些成员虽然是有类型的，但却没有实现。你可以再看看 TypeScript 的 <code>MinimalLogger</code> 类，确定一下它是没有实现的。</p><p translation-origin="off">Notice that it doesn't have any members. It never grows no matter how many members you add to the class, as long as those members are typed but not implemented. Look again at the TypeScript <code>MinimalLogger</code> class to confirm that it has no implementation.</p></div><a id="injection-token"></a><h3 translation-result="on" id="injectiontoken-对象">'InjectionToken' 对象<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#injectiontoken-对象"><i class="material-icons">link</i></a></h3><h3 translation-origin="off" id="injectiontoken-objects">'InjectionToken' objects<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#injectiontoken-objects"><i class="material-icons">link</i></a></h3><p translation-result="on">依赖对象可以是一个简单的值，比如日期，数字和字符串，或者一个无形的对象，比如数组和函数。</p><p translation-origin="off">Dependency objects can be simple values like dates, numbers and strings, or shapeless objects like arrays and functions.</p><p translation-result="on">这样的对象没有应用程序接口，所以不能用一个类来表示。更适合表示它们的是：唯一的和符号性的令牌，一个 JavaScript 对象，拥有一个友好的名字，但不会与其它的同名令牌发生冲突。</p><p translation-origin="off">Such objects don't have application interfaces and therefore aren't well represented by a class. They're better represented by a token that is both unique and symbolic, a JavaScript object that has a friendly name but won't conflict with another token that happens to have the same name.</p><p translation-result="on"><code><a href="/api/core/InjectionToken" class="code-anchor">InjectionToken</a></code> 具有这些特征。在<em>Hero of the Month</em>例子中遇见它们两次，一个是 <em>title</em> 的值，一个是 <em>runnersUp</em> 工厂提供商。</p><p translation-origin="off"><code><a href="/api/core/InjectionToken" class="code-anchor">InjectionToken</a></code> has these characteristics. You encountered them twice in the <em>Hero of the Month</em> example, in the <em>title</em> value provider and in the <em>runnersUp</em> factory provider.</p><code-example path="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" region="provide-injection-token" header="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" linenums="false">{ provide: TITLE, useValue: 'Hero of the Month' }, { provide: RUNNERS_UP, useFactory: runnersUpFactory(2), <a href="/api/core/ConstructorSansProvider#deps" class="code-anchor">deps</a>: [Hero, HeroService] }</code-example><p translation-result="on">这样创建 <code>TITLE</code> 令牌：</p><p translation-origin="off">You created the <code>TITLE</code> token like this:</p><code-example path="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" region="injection-token" header="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" linenums="false">import { <a href="/api/core/InjectionToken" class="code-anchor">InjectionToken</a> } from '@angular/core'; export const TITLE = new <a href="/api/core/InjectionToken" class="code-anchor">InjectionToken</a>&#x3C;string>('title');</code-example><p translation-result="on">类型参数，虽然是可选的，但可以向开发者和开发工具传达类型信息。 而且这个令牌的描述信息也可以为开发者提供帮助。</p><p translation-origin="off">The type parameter, while optional, conveys the dependency's type to developers and tooling. The token description is another developer aid.</p><a id="di-inheritance"></a><h2 translation-result="on" id="注入到派生类">注入到派生类<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#注入到派生类"><i class="material-icons">link</i></a></h2><h2 translation-origin="off" id="inject-into-a-derived-class">Inject into a derived class<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#inject-into-a-derived-class"><i class="material-icons">link</i></a></h2><p translation-result="on">当编写一个继承自另一个组件的组件时，要格外小心。如果基础组件有依赖注入，必须要在派生类中重新提供和重新注入它们，并将它们通过构造函数传给基类。</p><p translation-origin="off">Take care when writing a component that inherits from another component. If the base component has injected dependencies, you must re-provide and re-inject them in the derived class and then pass them down to the base class through the constructor.</p><p translation-result="on">在这个刻意生成的例子里，<code>SortedHeroesComponent</code> 继承自 <code>HeroesBaseComponent</code>，显示一个<em>被排序</em>的英雄列表。</p><p translation-origin="off">In this contrived example, <code>SortedHeroesComponent</code> inherits from <code>HeroesBaseComponent</code> to display a <em>sorted</em> list of heroes.</p><figure><img src="generated/images/guide/dependency-injection-in-action/sorted-heroes.png" alt="Sorted Heroes" width="135" height="107"></figure><p translation-result="on"><code>HeroesBaseComponent</code> 能自己独立运行。它在自己的实例里要求 <code>HeroService</code>，用来得到英雄，并将他们按照数据库返回的顺序显示出来。</p><p translation-origin="off">The <code>HeroesBaseComponent</code> can stand on its own. It demands its own instance of <code>HeroService</code> to get heroes and displays them in the order they arrive from the database.</p><code-example path="dependency-injection-in-action/src/app/sorted-heroes.component.ts" region="heroes-base" header="src/app/sorted-heroes.component.ts (HeroesBaseComponent)">@<a href="/api/core/Component" class="code-anchor">Component</a>({ selector: 'app-unsorted-heroes', <a href="/api/core/Component#template" class="code-anchor">template</a>: `&#x3C;div *<a href="/api/common/NgForOf" class="code-anchor">ngFor</a>="let hero of heroes">{{hero.name}}&#x3C;/div>`, providers: [HeroService] }) export class HeroesBaseComponent implements <a href="/api/core/OnInit" class="code-anchor">OnInit</a> { constructor(private heroService: HeroService) { } heroes: Array&#x3C;Hero>; ngOnInit() { this.heroes = this.heroService.getAllHeroes(); this.afterGetHeroes(); } // Post-process heroes in derived class override. protected afterGetHeroes() {} }</code-example><div class="alert is-helpful"><h3 translation-result="on" id="让构造函数保持简单">让构造函数保持简单<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#让构造函数保持简单"><i class="material-icons">link</i></a></h3><h3 translation-origin="off" id="keep-constructors-simple">Keep constructors simple<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#keep-constructors-simple"><i class="material-icons">link</i></a></h3><p translation-result="on">构造函数应该只用来初始化变量。 这条规则让组件在测试环境中可以放心地构造组件，以免在构造它们时，无意中做出一些非常戏剧化的动作(比如与服务器进行会话)。 这就是为什么你要在 <code>ngOnInit</code> 里面调用 <code>HeroService</code>，而不是在构造函数中。</p><p translation-origin="off">Constructors should do little more than initialize variables. This rule makes the component safe to construct under test without fear that it will do something dramatic like talk to the server. That's why you call the <code>HeroService</code> from within the <code>ngOnInit</code> rather than the constructor.</p></div><p translation-result="on">用户希望看到英雄按字母顺序排序。与其修改原始的组件，不如派生它，新建 <code>SortedHeroesComponent</code>，以便展示英雄之前进行排序。 <code>SortedHeroesComponent</code> 让基类来获取英雄。</p><p translation-origin="off">Users want to see the heroes in alphabetical order. Rather than modify the original component, sub-class it and create a <code>SortedHeroesComponent</code> that sorts the heroes before presenting them. The <code>SortedHeroesComponent</code> lets the base class fetch the heroes.</p><p translation-result="on">可惜，Angular 不能直接在基类里直接注入 <code>HeroService</code>。必须在<em>这个</em>组件里再次提供 <code>HeroService</code>，然后通过构造函数传给基类。</p><p translation-origin="off">Unfortunately, Angular cannot inject the <code>HeroService</code> directly into the base class. You must provide the <code>HeroService</code> again for <em>this</em> component, then pass it down to the base class inside the constructor.</p><code-example path="dependency-injection-in-action/src/app/sorted-heroes.component.ts" region="sorted-heroes" header="src/app/sorted-heroes.component.ts (SortedHeroesComponent)">@<a href="/api/core/Component" class="code-anchor">Component</a>({ selector: 'app-sorted-heroes', <a href="/api/core/Component#template" class="code-anchor">template</a>: `&#x3C;div *<a href="/api/common/NgForOf" class="code-anchor">ngFor</a>="let hero of heroes">{{hero.name}}&#x3C;/div>`, providers: [HeroService] }) export class SortedHeroesComponent extends HeroesBaseComponent { constructor(heroService: HeroService) { super(heroService); } protected afterGetHeroes() { this.heroes = this.heroes.sort((h1, h2) => { return h1.name &#x3C; h2.name ? -1 : (h1.name > h2.name ? 1 : 0); }); } }</code-example><p translation-result="on">现在，请注意 <code>afterGetHeroes()</code> 方法。 你的第一反应是在 <code>SortedHeroesComponent</code> 组件里面建一个 <code>ngOnInit</code> 方法来做排序。但是 Angular 会先调用<em>派生</em>类的 <code>ngOnInit</code>，后调用基类的 <code>ngOnInit</code>， 所以可能在<em>英雄到达之前</em>就开始排序。这就产生了一个讨厌的错误。</p><p translation-origin="off">Now take note of the <code>afterGetHeroes()</code> method. Your first instinct might have been to create an <code>ngOnInit</code> method in <code>SortedHeroesComponent</code> and do the sorting there. But Angular calls the <em>derived</em> class's <code>ngOnInit</code> <em>before</em> calling the base class's <code>ngOnInit</code> so you'd be sorting the heroes array <em>before they arrived</em>. That produces a nasty error.</p><p translation-result="on">覆盖基类的 <code>afterGetHeroes()</code> 方法可以解决这个问题。</p><p translation-origin="off">Overriding the base class's <code>afterGetHeroes()</code> method solves the problem.</p><p translation-result="on">分析上面的这些复杂性是为了强调<em>避免使用组件继承</em>这一点。</p><p translation-origin="off">These complications argue for <em>avoiding component inheritance</em>.</p><a id="forwardref"></a><h2 translation-result="on" id="使用一个前向引用forwardref来打破循环">使用一个前向引用(<em>forwardRef</em>)来打破循环<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#使用一个前向引用forwardref来打破循环"><i class="material-icons">link</i></a></h2><h2 translation-origin="off" id="break-circularities-with-a-forward-class-reference-forwardref">Break circularities with a forward class reference (<em>forwardRef</em>)<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#break-circularities-with-a-forward-class-reference-forwardref"><i class="material-icons">link</i></a></h2><p translation-result="on">在 TypeScript 里面，类声明的顺序是很重要的。如果一个类尚未定义，就不能引用它。</p><p translation-origin="off">The order of class declaration matters in TypeScript. You can't refer directly to a class until it's been defined.</p><p translation-result="on">这通常不是一个问题，特别是当你遵循<em>一个文件一个类</em>规则的时候。 但是有时候循环引用可能不能避免。当一个类<em>A 引用类 B</em>，同时'B'引用'A'的时候，你就陷入困境了：它们中间的某一个必须要先定义。</p><p translation-origin="off">This isn't usually a problem, especially if you adhere to the recommended <em>one class per file</em> rule. But sometimes circular references are unavoidable. You're in a bind when class 'A' refers to class 'B' and 'B' refers to 'A'. One of them has to be defined first.</p><p translation-result="on">Angular 的 <code><a href="/api/core/forwardRef" class="code-anchor">forwardRef</a>()</code> 函数建立一个<em>间接地</em>引用，Angular 可以随后解析。</p><p translation-origin="off">The Angular <code><a href="/api/core/forwardRef" class="code-anchor">forwardRef</a>()</code> function creates an <em>indirect</em> reference that Angular can resolve later.</p><p translation-result="on">这个关于<em>父查找器</em>的例子中全都是没办法打破的循环类引用。</p><p translation-origin="off">The <em>Parent Finder</em> sample is full of circular class references that are impossible to break.</p><p translation-result="on">当一个类<em>需要引用自身</em>的时候，你面临同样的困境，就像在 <code>AlexComponent</code> 的 <code>provdiers</code> 数组中遇到的困境一样。 该 <code>providers</code> 数组是一个 <code>@<a href="/api/core/Component" class="code-anchor">Component</a>()</code> 装饰器函数的一个属性，它必须在类定义<em>之前</em>出现。</p><p translation-origin="off">You face this dilemma when a class makes <em>a reference to itself</em> as does <code>AlexComponent</code> in its <code>providers</code> array. The <code>providers</code> array is a property of the <code>@<a href="/api/core/Component" class="code-anchor">Component</a>()</code> decorator function which must appear <em>above</em> the class definition.</p><p translation-result="on">使用 <code><a href="/api/core/forwardRef" class="code-anchor">forwardRef</a></code> 来打破这种循环：</p><p translation-origin="off">Break the circularity with <code><a href="/api/core/forwardRef" class="code-anchor">forwardRef</a></code>.</p><code-example path="dependency-injection-in-action/src/app/parent-finder.component.ts" region="alex-providers" header="parent-finder.component.ts (AlexComponent providers)" linenums="false">providers: [{ provide: Parent, useExisting: <a href="/api/core/forwardRef" class="code-anchor">forwardRef</a>(() => AlexComponent) }],</code-example></div></section></mat-sidenav-content></mat-sidenav-container><footer class="no-print"><aio-footer><div class="grid-fluid"><div class="footer-block ng-star-inserted"><h3>资源</h3><ul><li class="ng-star-inserted"><a class="link" href="about" title="Angular 贡献者。">关于</a></li><li class="ng-star-inserted"><a class="link" href="resources" title="网络上的 Angular 工具、培训、博客等">资源列表</a></li><li class="ng-star-inserted"><a class="link" href="presskit" title="我们的联系方式、LOGO 和品牌">宣传资料</a></li><li class="ng-star-inserted"><a class="link" href="https://blog.angular.io/" title="Angular 官方博客">博客</a></li></ul></div><div class="footer-block ng-star-inserted"><h3>帮助</h3><ul><li class="ng-star-inserted"><a class="link" href="https://stackoverflow.com/questions/tagged/angular" title="Stack Overflow: 这里的社区会回答你关于 Angular 的技术问题">Stack Overflow</a></li><li class="ng-star-inserted"><a class="link" href="https://gitter.im/angular/angular" title="和老鸟聊 Angular">Gitter</a></li><li class="ng-star-inserted"><a class="link" href="https://github.com/angular/angular/issues" title="在 github 上报告问题和建议。">报告问题</a></li><li class="ng-star-inserted"><a class="link" href="https://github.com/angular/code-of-conduct/blob/master/CODE_OF_CONDUCT.md" title="让我们彼此尊重">行为规范</a></li></ul></div><div class="footer-block ng-star-inserted"><h3>社区</h3><ul><li class="ng-star-inserted"><a class="link" href="events" title="Post issues and suggestions on github.">活动</a></li><li class="ng-star-inserted"><a class="link" href="http://www.meetup.com/topics/angularjs/" title="参加聚会，向别的开发人员学习">聚会</a></li><li class="ng-star-inserted"><a class="link" href="https://twitter.com/angular" title="Twitter">Twitter</a></li><li class="ng-star-inserted"><a class="link" href="https://github.com/angular/angular" title="GitHub">GitHub</a></li><li class="ng-star-inserted"><a class="link" href="contribute" title="向 Angular 做贡献">做贡献</a></li></ul></div><div class="footer-block ng-star-inserted"><h3>多语言</h3><ul><li class="ng-star-inserted"><a class="link" href="https://angular.io/" title="English Version.">English Version</a></li><li class="ng-star-inserted"><a class="link" href="https://angular.jp/" title="日本語版">日本語版</a></li></ul></div></div><p>Powered by Google ©2010-2018. 代码授权方式：<a href="license" title="License text">MIT-style License</a>. 文档授权方式：<a href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.</p><p>当前版本：7.0.1-local+sha.3ff4bedd0c.</p></aio-footer></footer></aio-shell><noscript><div class="background-sky hero"></div><section id="intro" style="text-shadow:1px 1px #1976d2"><div class="hero-logo"><img src="assets/images/logos/angular/angular.svg" width="250" height="250"></div><div class="homepage-container"><div class="hero-headline">一套框架，多种平台<br>移动 &amp; 桌面</div></div></section><h2 style="color:red;margin-top:40px;position:relative;text-align:center;text-shadow:1px 1px #fafafa"><b><i>该网站需要浏览器支持 JavaScript</i></b></h2></noscript><script src="runtime.77c03f4a0637c9ae63bb.js"></script><script src="polyfills.484bababb6e0f3a2b3fc.js"></script><script src="main.6bc769c43c358bc5a651.js"></script></body></html>