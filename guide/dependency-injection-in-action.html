<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <title>依赖注入 - Angular 官方文档</title>
  <base href="/">

  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link rel="icon" type="image/x-icon" href="assets/images/favicons/favicon.ico">
  <link rel="icon" type="image/png" href="assets/images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="assets/images/favicons/favicon-194x194.png" sizes="194x194">
  <link rel="icon" type="image/png" href="assets/images/favicons/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="assets/images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="apple-touch-icon" sizes="144x144" href="assets/images/favicons/favicon-144x144.png">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="assets/images/favicons/favicon-144x144.png">

  <!-- NOTE: These need to be kept in sync with `ngsw-manifest.json`. -->
  <link href="assets/fonts/Material_Icons.css" rel="stylesheet">
  <link href="assets/fonts/Droid_Sans_Mono.css" rel="stylesheet">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  

  <link rel="manifest" href="pwa-manifest.json">
  <meta name="theme-color" content="#1976d2">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="translucent">

  <script>
    // Dynamically, pre-emptively, add `noindex`, which will be removed when the doc is ready and valid
    tag = document.createElement('meta'); tag.name = 'robots'; tag.content = 'noindex';
    document.head.appendChild(tag);
  </script>

  <!-- Google Analytics -->
  <script>
  // Note this is a customised version of the GA tracking snippet
  // See the comments below for more info
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;
  ~i.name.indexOf('NG_DEFER_BOOTSTRAP')|| // only load library if not running e2e tests
  m.parentNode.insertBefore(a,m)
  })(window,document,'script','assets/js/analytics.js','ga');
  </script>
  <!-- End Google Analytics -->

  <script>
    // Report fatal errors to Google Analytics
    window.onerror = function() {
      ga('send', 'exception', {exDescription: formatError.apply(null, arguments), exFatal: true});

      function formatError(msg, url, line, col, e) {
        var stack;
        msg = msg.replace(/^Error: /, '');
        if (e) {
          stack = e.stack
              // strip the leading "Error: " from the stack trace
              .replace(/^Error: /, '')
              // strip the message from the stack trace, if present
              .replace(msg + '\n', '')
              // strip leading spaces
              .replace(/^ +/gm, '')
              // strip all leading "at " for each frame
              .replace(/^at /gm, '')
              // replace long urls with just the last segment: `filename:line:column`
              .replace(/(?: \(|@)http.+\/([^/)]+)\)?(?:\n|$)/gm, '@$1\n')
              // replace "eval code" in Edge
              .replace(/ *\(eval code(:\d+:\d+)\)(?:\n|$)/gm, '@???$1\n')
        } else {
          line = line || '?';
          col = col || '?';
          stack = url + ':' + line + ':' + col;
        }
        return (msg + '\n' + stack).substr(0, 150);
      }
    };
  </script>

  <script nomodule="" src="generated/ie-polyfills.min.js"></script>

  <script>
    //load CE polyfill
    //HACK: webpack's html plugin mangles the document.write calls if we don't trick it.

    //load the ES5 shim for browsers with native CE support
    function loadCustomElementsShim(){
      document.write('<scri' + 'pt src="assets/js/native-shim.js"><' + '/script>');
    }

    //load the full custom elements polyfill for browsers without support
    function loadCustomElementsPolyfill(){
      document.write('<scri' + 'pt src="assets/js/custom-elements.min.js"><' + '/script>');
    }
    //detect if we have native CE support
    if(!window.customElements){
      loadCustomElementsPolyfill();
    }
    else {
      loadCustomElementsShim();
    }
  </script>

<link rel="stylesheet" href="styles.8619b418e94a3136fcaf.css"></head>
<body>

  <aio-shell ng-version="6.0.0" class="mode-stable sidenav-open page-guide-template-syntax folder-guide view-SideNav aio-notification-hide"><div id="top-of-page"></div><mat-toolbar class="app-toolbar no-print mat-toolbar mat-primary mat-toolbar-multiple-rows" color="primary"><mat-toolbar-row class="notification-container mat-toolbar-row"><aio-notification actionurl="https://blog.angular.io/version-6-0-0-of-angular-now-available-cc56b0efa7a4" buttontext="Learn More" expirationdate="2018-07-01" icon="insert_comment" iconlabel="Announcement" notificationid="angular-v6-announcement" class="ng-tns-c2-0 ng-trigger ng-trigger-hideAnimation" style="height: 0px;"><a class="content" href="https://blog.angular.io/version-6-0-0-of-angular-now-available-cc56b0efa7a4"><mat-icon class="icon mat-icon" role="img" aria-hidden="true" aria-label="Announcement"><svg fill="#FFFFFF" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M20 2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></mat-icon><span class="message">Version 6 of Angular Now Available! </span><span class="action-button">Learn More</span></a> <button class="close-button mat-icon-button" aria-label="Close" mat-icon-button=""><span class="mat-button-wrapper"><mat-icon aria-label="Dismiss notification" class="mat-icon ng-tns-c2-0" role="img" svgicon="close" aria-hidden="true"><svg fill="#ffffff" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></mat-icon></span><div class="mat-button-ripple mat-ripple mat-button-ripple-round" matripple=""></div><div class="mat-button-focus-overlay"></div></button></aio-notification></mat-toolbar-row><mat-toolbar-row class="mat-toolbar-row"><button class="hamburger mat-button" mat-button="" title="Docs menu"><span class="mat-button-wrapper"><mat-icon class="mat-icon" role="img" svgicon="menu" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" focusable="false" viewBox="0 0 24 24"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg></mat-icon></span><div class="mat-button-ripple mat-ripple" matripple=""></div><div class="mat-button-focus-overlay"></div></button> <a class="nav-link home" href="/"><img alt="Home" height="40" src="assets/images/logos/angular/logo-nav@2x.png" title="Home" width="150"></a><aio-top-menu><ul role="navigation"><li><a class="nav-link" href="/features" title="特性">特性</a></li><li><a class="nav-link" href="/docs" title="文档">文档</a></li><li><a class="nav-link" href="/resources" title="资源">资源</a></li><li><a class="nav-link" href="/events" title="会议">会议</a></li><li><a class="nav-link" href="https://blog.angular.io/" title="博客">博客</a></li><li><a class="nav-link" href="/translations/cn/home" title="关于中文版">关于中文版</a></li></ul></aio-top-menu><aio-search-box class="search-container"><input aria-label="search" placeholder="搜索" type="search"></aio-search-box><div class="toolbar-external-icons-container"><a href="https://twitter.com/angular" title="Twitter"><img src="assets/images/logos/twitter-icon.svg"></a><a href="https://github.com/angular/angular" title="GitHub"><img src="assets/images/logos/github-icon.svg"></a></div></mat-toolbar-row></mat-toolbar><mat-sidenav-container class="sidenav-container mat-drawer-container mat-sidenav-container mat-drawer-transition has-floating-toc" role="main"><div class="mat-drawer-backdrop"></div><div tabindex="-1" class="cdk-visually-hidden cdk-focus-trap-anchor"></div><mat-sidenav class="sidenav mat-drawer mat-sidenav ng-tns-c6-1 ng-trigger ng-trigger-transform mat-drawer-side" tabindex="-1" style="transform: translate3d(0px, 0px, 0px); visibility: visible;"><aio-nav-menu><aio-nav-item><div><a class="vertical-menu-item level-1 collapsed" style="position: relative" href="/guide/quickstart" title="Angular 破冰" target="_self">快速上手</a></div></aio-nav-item><aio-nav-item><div><button class="vertical-menu-item heading level-1 expanded" type="button" title="此《英雄指南》教程会带你用 TypeScript 一步步创建一个 Angular 应用。" aria-pressed="true">教程<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" focusable="false" viewBox="0 0 24 24"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-1 expanded"><aio-nav-item><div><a class="vertical-menu-item level-2 collapsed" style="position: relative" href="/tutorial" title="第一部分：《英雄指南》教程简介" target="_self">1. 简介</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-2 collapsed" style="position: relative" href="/tutorial/toh-pt0" title="第二部分：创建应用的外壳" target="_self">2. 应用的“外壳”</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-2 collapsed" style="position: relative" href="/tutorial/toh-pt1" title="第三部分：构建一个简单的英雄编辑器" target="_self">3. 英雄编辑器</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-2 collapsed" style="position: relative" href="/tutorial/toh-pt2" title="第四部分：构建一个主从结构的页面，用于展现英雄列表" target="_self">4. 显示英雄列表</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-2 collapsed" style="position: relative" href="/tutorial/toh-pt3" title="第五部分：把主从结构的页面重构成多个组件" target="_self">5. 主从组件</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-2 collapsed" style="position: relative" href="/tutorial/toh-pt4" title="第六部分：创建一个可复用的服务来管理英雄数据" target="_self">6. 服务</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-2 collapsed" style="position: relative" href="/tutorial/toh-pt5" title="第七部分：添加 Angular 路由器，并且学习在视图之间导航" target="_self">7. 路由</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-2 collapsed" style="position: relative" href="/tutorial/toh-pt6" title="第八部分：通过 HTTP 来获取并保存英雄数据" target="_self">8. HTTP</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item><div><button class="vertical-menu-item heading level-1 expanded selected" type="button" title="学习 Angular 的核心知识" aria-pressed="true">核心知识<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" focusable="false" viewBox="0 0 24 24"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-1 expanded selected"><aio-nav-item><div><button class="vertical-menu-item heading level-2 expanded" type="button" title="Angular 应用的基本构造块。" aria-pressed="true">架构<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" focusable="false" viewBox="0 0 24 24"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 expanded"><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/architecture" title="Angular 应用的基本构造块" target="_self">架构概览</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/architecture-modules" title="关于模块。" target="_self">模块（NgModule）简介</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/architecture-components" title="关于组件、模板和视图。" target="_self">组件简介</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/architecture-services" title="关于服务与依赖注入。" target="_self">服务与 DI 简介</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/architecture-next-steps" title="学完基础知识之后……" target="_self">后续步骤</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item><div><button class="vertical-menu-item heading level-2 expanded selected" type="button" title="使用数据绑定构建动态视图" aria-pressed="true">组件与模板<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" focusable="false" viewBox="0 0 24 24"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 expanded selected"><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/displaying-data" title="属性绑定可以帮助应用把数据显示在界面上" target="_self">显示数据</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 expanded selected" style="position: relative" href="/guide/template-syntax" title="学习如何写模板，以便借助数据绑定机制显示数据并响应事件。" target="_self">模板语法</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/lifecycle-hooks" title="Angular 调用指令和组件的生命周期钩子函数，包括它的创建、变更和销毁时。" target="_self">生命周期钩子</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/component-interaction" title="在不同的指令和组件之间共享信息" target="_self">组件交互</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/component-styles" title="添加专属于某个组件的样式" target="_self">组件样式</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/elements" title="把组件转换成自定义元素。" target="_self">Angular 自定义元素</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/dynamic-component-loader" title="动态加载组件" target="_self">动态组件</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/attribute-directives" title="属性型指令把行为添加到现有元素上。" target="_self">属性型指令</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/structural-directives" title="结构型指令可以操纵页面的布局" target="_self">结构型指令</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/pipes" title="管道可以在模板中转换显示的内容。" target="_self">管道</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/animations" title="Angular 动画体系指南" target="_self">动画</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item><div><button class="vertical-menu-item heading level-2 expanded" type="button" title="Angular 的表单" aria-pressed="true">表单<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" focusable="false" viewBox="0 0 24 24"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 expanded"><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/user-input" title="用户输入触发 DOM 事件。我们通过事件绑定来监听它们，把更新过的数据导入回我们的组件和 model。" target="_self">用户输入</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/forms" title="表单可以创建集中、高效、引人注目的输入体验。Angular 表单可以协调一组数据绑定控件，跟踪变更，验证输入，并表达错误信息。" target="_self">模板驱动表单</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/form-validation" title="验证用户的表单输入" target="_self">表单验证</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/reactive-forms" title="使用 FormBuilder 、分组和数组创建响应式表单。" target="_self">响应式表单</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/dynamic-form" title="使用FormGroup渲染动态表单" target="_self">动态表单</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item><div><button class="vertical-menu-item heading level-2 expanded" type="button" title="Observable 与 RxJS" aria-pressed="true">Observable 与 RxJS<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" focusable="false" viewBox="0 0 24 24"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 expanded"><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/observables" title="" target="_self">可观察对象(Observable)</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/rx-library" title="" target="_self">RxJS 库</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/observables-in-angular" title="" target="_self">Angular 中的可观察对象</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/practical-observable-usage" title="" target="_self">用法实战</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/comparing-observables" title="" target="_self">与其它技术的比较</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-2 collapsed" style="position: relative" href="/guide/bootstrapping" title="在应用的根模块（AppModule）中告诉 Angular 如何构造并引导引用。" target="_self">引导启动</a></div></aio-nav-item><aio-nav-item><div><button class="vertical-menu-item heading level-2 expanded" type="button" title="Angular 中的模块" aria-pressed="true">Angular 模块<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" focusable="false" viewBox="0 0 24 24"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 expanded"><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/ngmodules" title="使用 NgModule 让你的应用更高效" target="_self">NgModule 简介</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/ngmodule-vs-jsmodule" title="JavaScript 模块和 NgModule 之间的差异" target="_self">JS 模块 vs NgModule</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/frequent-ngmodules" title="介绍最常用的 Angular 模块" target="_self">常用模块</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/module-types" title="介绍特性模块的几种类型" target="_self">特性模块的分类</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/entry-components" title="关于 Angular 中入口组件的一切" target="_self">入口组件</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/feature-modules" title="创建特性模块，以组织你的代码" target="_self">特性模块</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/providers" title="服务提供商与 Angular 模块" target="_self">服务提供商</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/singleton-services" title="创建单例应用" target="_self">单例应用</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/lazy-loading-ngmodules" title="惰性加载模块，以提高应用的性能" target="_self">惰性加载的特性模块</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/sharing-ngmodules" title="共享 Angular 模块让你的应用现代化。" target="_self">共享 Angular 模块</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/ngmodule-api" title="理解 NgModule 的那些细节。" target="_self">NgModule API</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/ngmodule-faq" title="回答关于 NgModules 的常见问题。" target="_self">NgModule 常见问题</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item><div><button class="vertical-menu-item heading level-2 expanded" type="button" title="依赖注入：创建并注入各种服务。" aria-pressed="true">依赖注入<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" focusable="false" viewBox="0 0 24 24"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 expanded"><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/dependency-injection-pattern" title="学习 Angular 依赖注入系统背后的依赖注入模式" target="_self">依赖注入模式</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/dependency-injection" title="Angular 的依赖注入系统能够为 Angular 创建的类创建并交付它们所依赖的服务。" target="_self">Angular 依赖注入</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/hierarchical-dependency-injection" title="Angular 的多级注入体系会建立与组件平行的注入器树。" target="_self">多级注入器</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/dependency-injection-in-action" title="依赖注入的使用技巧" target="_self">DI 实用技巧</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-2 collapsed" style="position: relative" href="/guide/http" title="通过 HTTP 协议与远程服务器对话。" target="_self">HttpClient</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-2 collapsed" style="position: relative" href="/guide/router" title="揭示如何通过 Angular 路由进行基本的屏幕导航。" target="_self">路由与导航</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-2 collapsed" style="position: relative" href="/guide/testing" title="测试 Angular 应用的技巧与实践。" target="_self">测试</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-2 collapsed" style="position: relative" href="/guide/cheatsheet" title="关于 Angular 常用编码技术的快速指南。" target="_self">速查表</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item><div><button class="vertical-menu-item heading level-1 expanded" type="button" title="把 Angular 用到你的实际工作中的一些技巧" aria-pressed="true">其它技术<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" focusable="false" viewBox="0 0 24 24"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-1 expanded"><aio-nav-item><div><a class="vertical-menu-item level-2 collapsed" style="position: relative" href="/guide/i18n" title="把应用模板中的文本翻译成多种语言。" target="_self">国际化 (i18n)</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-2 collapsed" style="position: relative" href="/guide/language-service" title="使用 Angular 语言服务来为开发提速。" target="_self">语言服务</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-2 collapsed" style="position: relative" href="/guide/security" title="Angular 应用开发中的安全技术。" target="_self">安全</a></div></aio-nav-item><aio-nav-item><div><button class="vertical-menu-item heading level-2 expanded" type="button" title="环境准备与部署" aria-pressed="true">环境准备与部署<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" focusable="false" viewBox="0 0 24 24"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 expanded"><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/setup" title="在你自己的机器上安装 Angular QuickStart 种子，以便更快、更高效的开发。" target="_self">搭建本地开发环境</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/setup-systemjs-anatomy" title="基于 SystemJS 的本地开发环境内幕。" target="_self">搭建方式剖析</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/browser-support" title="浏览器支持与 Polyfills 指南" target="_self">浏览器支持</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/npm-packages" title="建议的 npm 包，以及如何指定包的依赖。" target="_self">npm 包</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/typescript-configuration" title="给 Angular 开发者的 TypeScript 配置。" target="_self">TypeScript 配置</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/aot-compiler" title="学习如何使用 AOT 预编译器。" target="_self">预先（AOT）编译</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/deployment" title="学习如何部署你的 Angular 应用。" target="_self">部署</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item><div><button class="vertical-menu-item heading level-2 expanded" type="button" title="Angular 的 Service Worker：控制应用的资源缓存。" aria-pressed="true">Service Worker<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" focusable="false" viewBox="0 0 24 24"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 expanded"><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/service-worker-intro" title="Angular 对 Service Worker 的实现提升了慢速或不稳定的网络连接下的用户体验。" target="_self">简介</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/service-worker-getting-started" title="在 CLI 项目中启用 Service Worker，并在浏览器中查看效果。" target="_self">快速起步</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/service-worker-communications" title="那些能让你和 Angular 的 Service Worker 通讯的服务类。" target="_self">与 Service Worker 通讯</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/service-worker-devops" title="使用 Service Worker 运行应用、管理应用更新、调试以及杀掉正在运行的应用。" target="_self">生产环境下的 Service Worker</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/service-worker-config" title="配置 Service Worker 的缓存行为。" target="_self">Service Worker 配置</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item><div><button class="vertical-menu-item heading level-2 expanded" type="button" title="Angular 的发布实践，更新计划以及与更新有关的资源。" aria-pressed="true">保持最新<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" focusable="false" viewBox="0 0 24 24"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 expanded"><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/updating" title="关于如何把 Angular 应用升级到最新版的信息。" target="_self">更新你的项目</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/releases" title="Angular 的版本、发布、支持与弃用策略。" target="_self">Angular 的版本发布</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item><div><button class="vertical-menu-item heading level-2 expanded" type="button" title="把 AngularJS 应用增量式的升级到 Angular。" aria-pressed="true">从 AngularJS 升级<mat-icon class="rotating-icon mat-icon" role="img" svgicon="keyboard_arrow_right" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" focusable="false" viewBox="0 0 24 24"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></svg></mat-icon></button><div class="heading-children level-2 expanded"><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/upgrade" title="把 AngularJS 应用增量式的升级到 Angular。" target="_self">升级步骤</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/upgrade-performance" title="Upgrade from AngularJS to Angular in a more flexible way." target="_self">Upgrading for Performance</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-3 collapsed" style="position: relative" href="/guide/ajs-quick-reference" title="学习如何把 AngularJS 的概念映射到 Angular 中。" target="_self">AngularJS 与 Angular 的概念对照</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-2 expanded" style="position: relative" href="/guide/universal" title="使用 Angular Universal 在服务端渲染 HTML。" target="_self">服务端渲染</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-2 collapsed" style="position: relative" href="/guide/visual-studio-2015" title="在 Visual Studio 2015 中使用快速起步中的文件" target="_self">Visual Studio 2015 快速上手</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-2 collapsed" style="position: relative" href="/guide/styleguide" title="写出 Angular 风格的程序" target="_self">风格指南</a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-2 collapsed" style="position: relative" href="/guide/glossary" title="Angular 中最重要的词汇的简要定义。" target="_self">词汇表</a></div></aio-nav-item></div></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-1 collapsed" style="position: relative" href="/api" title="关于 Angular 中类和值的详细信息。" target="_self">API 参考手册</a></div></aio-nav-item><aio-nav-item><div><div class="mat-divider" style="margin: 4px 20px; border-top: 1px solid lightgray"></div></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-1 collapsed" style="position: relative" href="https://github.com/ng-docs/ng-docs.github.io/issues" title="github 上的中文互助问答区" target="_blank">互助问答<mat-icon class="mat-icon material-icons" role="img" aria-hidden="true">open_in_new</mat-icon></a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-1 collapsed" style="position: relative" href="https://material.angular.cn" title="Angular Material 组件库的中文文档" target="_blank">官方 Material 组件库<mat-icon class="mat-icon material-icons" role="img" aria-hidden="true">open_in_new</mat-icon></a></div></aio-nav-item><aio-nav-item><div><a class="vertical-menu-item level-1 collapsed" style="position: relative" href="https://ng.ant.design/" title="Ant Design 的 Angular 实现，服务于企业级后台产品。" target="_blank">ng-zorro 组件库<mat-icon class="mat-icon material-icons" role="img" aria-hidden="true">open_in_new</mat-icon></a></div></aio-nav-item></aio-nav-menu><div class="doc-version"><aio-select><div class="form-select-menu"><button class="form-select-button"><strong></strong>stable (v6.1.0)</button></div></aio-select></div></mat-sidenav><div tabindex="-1" class="cdk-visually-hidden cdk-focus-trap-anchor"></div><mat-sidenav-content cdkscrollable="" class="mat-drawer-content mat-sidenav-content" style="margin-left: 264px; margin-right: 0px;">
<div class="content">
<h1 translation-origin="off" id="dependency-injection">Dependency Injection<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#dependency-injection"><i class="material-icons">link</i></a></h1>
<h1 translation-result="" id="dependency-injection-3">依赖注入<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#dependency-injection-3"><i class="material-icons">link</i></a></h1>
<p translation-origin="off">Dependency Injection is a powerful pattern for managing code dependencies.
This cookbook explores many of the features of Dependency Injection (DI) in Angular.</p>
<p translation-result="">依赖注入是一个用来管理代码依赖的强大模式。本文会讨论 Angular 依赖注入的许多特性。</p>
<a id="toc"></a>
<p translation-origin="off">See the <live-example name="dependency-injection-in-action"></live-example>
of the code in this cookbook.</p>
<p translation-result="">要获取本文的代码，<strong>参见<live-example name="dependency-injection-in-action"></live-example></strong>。</p>
<a id="app-wide-dependencies"></a>
<h2 translation-origin="off" id="application-wide-dependencies">Application-wide dependencies<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#application-wide-dependencies"><i class="material-icons">link</i></a></h2>
<h2 translation-result="" id="application-wide-dependencies">应用程序全局依赖<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#application-wide-dependencies"><i class="material-icons">link</i></a></h2>
<p translation-origin="off">Register providers for dependencies used throughout the application
in the <code>@<a href="/api/core/Injectable" class="code-anchor">Injectable</a>()</code> decorator of the service itself. </p>
<p translation-result="">在服务本身的 <code>@<a href="/api/core/Injectable" class="code-anchor">Injectable</a>()</code> 装饰器中注册那些将被应用程序全局使用的依赖提供商。</p>
<code-example path="dependency-injection/src/app/heroes/hero.service.3.ts" title="src/app/heroes/hero.service.3.ts" linenums="false">
import { <a href="/api/core/Injectable" class="code-anchor">Injectable</a> } from '@angular/core';
import { HEROES }     from './mock-heroes';

@<a href="/api/core/Injectable" class="code-anchor">Injectable</a>({
  // we declare that this service should be created
  // by the root application injector.

  <a href="/api/core/Injectable#providedIn" class="code-anchor">providedIn</a>: 'root',
})
export class HeroService {
  getHeroes() { return HEROES; }
}


</code-example>
<p translation-origin="off"><code><a href="/api/core/Injectable#providedIn" class="code-anchor">providedIn</a></code> here tells Angular that the root injector is responsible for creating an instance of the <code>HeroService</code>.
Services that are provided this way are automatically made available to the entire
application and don't need to be listed in any module.</p>
<p translation-result="">这里的 <code><a href="/api/core/Injectable#providedIn" class="code-anchor">providedIn</a></code> 告诉 Angular，要由根注入器负责创建 <code>HeroService</code> 的实例。
所有用这种方式提供的服务，都会自动在整个应用中可用，而不必把它们显式列在任何模块中。</p>
<p translation-origin="off">Service classes can act as their own providers which is why defining them in the <code>@<a href="/api/core/Injectable" class="code-anchor">Injectable</a></code> decorator
is all the registration you need.</p>
<p translation-result="">这些服务类可以充当自己的提供商，因此你只要把它们定义在 <code>@<a href="/api/core/Injectable" class="code-anchor">Injectable</a></code> 装饰器中就算注册成功了。</p>
<div class="alert is-helpful">
<p translation-origin="off">A <em>provider</em> is something that can create or deliver a service.
Angular creates a service instance from a class provider by using <code>new</code>.
Read more about providers in the <a href="/guide/dependency-injection#register-providers-ngmodule">Dependency Injection</a>
guide.</p>
<p translation-result=""><em>提供商</em>是用来新建或者交付服务的。
Angular 拿到“类提供商”之后，会通过 <code>new</code> 操作来新建服务实例。
从<a href="/guide/dependency-injection#register-providers-ngmodule">依赖注入</a>一章可以学到关于提供商的更多知识。</p>
</div>
<p translation-origin="off">Now that you've registered these services,
Angular can inject them into the constructor of <em>any</em> component or service, <em>anywhere</em> in the application.</p>
<p translation-result="">现在你已经注册了这些服务，这样 Angular 就能在应用程序的<em>任何地方</em>，把它们注入到<em>任何</em>组件和服务的构造函数里。</p>
<a id="external-module-configuration"></a>
<h2 translation-origin="off" id="external-module-configuration">External module configuration<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#external-module-configuration"><i class="material-icons">link</i></a></h2>
<h2 translation-result="" id="external-module-configuration">外部模块配置<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#external-module-configuration"><i class="material-icons">link</i></a></h2>
<p translation-origin="off">If a provider cannot be configured in the <code>@<a href="/api/core/Injectable" class="code-anchor">Injectable</a></code> decorator of the service, then register application-wide providers in the root <code>AppModule</code>, not in the <code>AppComponent</code>. Generally, register providers in the <code><a href="/api/core/NgModule" class="code-anchor">NgModule</a></code> rather than in the root application component.</p>
<p translation-result="">如果某个提供商不是在服务的 <code>@<a href="/api/core/Injectable" class="code-anchor">Injectable</a></code> 装饰器中配置的，那么就要在根模块 <code>AppModule</code> 中把它注册为全应用级的提供商，而不是在 <code>AppComponent</code> 中。
一般来说，要在 <code><a href="/api/core/NgModule" class="code-anchor">NgModule</a></code> 中注册提供商，而不是在应用程序根组件中。</p>
<p translation-origin="off">Do this when users should explicitly opt-in to use a service, or the service should be
provided in a lazily-loaded context,
or when you are configuring another application global service <em>before the application starts</em>.</p>
<p translation-result="">下列情况下会用到这种方法：1. 当用户应该明确选择所用的服务时。2. 当你要在惰性加载的上下文中提供该服务时。3. 当你要在应用启动之前配置应用中的另一个全局服务时。</p>
<p translation-origin="off">Here is an example of the case where the component router configuration includes a non-default
<a href="/guide/router#location-strategy">location strategy</a> by listing its provider
in the <code>providers</code> list of the <code>AppModule</code>.</p>
<p translation-result="">下面的例子就属于这些情况，它为组件路由器配置了一个非默认的<a href="/guide/router#location-strategy">地址策略（location strategy）</a>，并把它加入到 <code>AppModule</code> 的 <code>providers</code> 数组中。</p>
<code-example path="dependency-injection-in-action/src/app/app.module.ts" region="providers" title="src/app/app.module.ts (providers)" linenums="false">
providers: [
  { provide: <a href="/api/common/LocationStrategy" class="code-anchor">LocationStrategy</a>, useClass: <a href="/api/common/HashLocationStrategy" class="code-anchor">HashLocationStrategy</a> }
]

</code-example>
<a id="injectable"></a>
<a id="nested-dependencies"></a>
<h2 translation-origin="off" id="injectable-and-nested-service-dependencies"><em>@Injectable()</em> and nested service dependencies<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#injectable-and-nested-service-dependencies"><i class="material-icons">link</i></a></h2>
<h2 translation-result="" id="eminjectableem-and-nested-service-dependencies"><em>@Injectable</em>和嵌套服务依赖<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#eminjectableem-and-nested-service-dependencies"><i class="material-icons">link</i></a></h2>
<p translation-origin="off">The consumer of an injected service does not know how to create that service.
It shouldn't care.
It's the dependency injection's job to create and cache that service.</p>
<p translation-result="">这些被注入服务的消费者不需要知道如何创建这个服务，它也不应该在乎。新建和缓存这个服务是依赖注入器的工作。</p>
<p translation-origin="off">Sometimes a service depends on other services, which may depend on yet other services.
Resolving these nested dependencies in the correct order is also the framework's job.
At each step, the consumer of dependencies simply declares what it requires in its
constructor and the framework takes over.</p>
<p translation-result="">有时候一个服务依赖其它服务...而其它服务可能依赖另外的更多服务。按正确的顺序解析这些嵌套依赖也是框架的工作。
在每一步，依赖的使用者只要在它的构造函数里简单声明它需要什么，框架就会完成所有剩下的事情。</p>
<p translation-origin="off">The following example shows injecting both the <code>LoggerService</code> and the <code>UserContext</code> in the <code>AppComponent</code>.</p>
<p translation-result="">下面的例子往 <code>AppComponent</code> 里注入的 <code>LoggerService</code> 和 <code>UserContext</code>。</p>
<code-example path="dependency-injection-in-action/src/app/app.component.ts" region="ctor" title="src/app/app.component.ts" linenums="false">
constructor(logger: LoggerService, public userContext: UserContextService) {
  userContext.loadUser(this.userId);
  logger.logInfo('AppComponent initialized');
}

</code-example>
<p translation-origin="off">The <code>UserContext</code> in turn has its own dependencies on both the <code>LoggerService</code> and
a <code>UserService</code> that gathers information about a particular user.</p>
<p translation-result=""><code>UserContext</code> 有两个依赖 <code>LoggerService</code>(再一次)和负责获取特定用户信息的 <code>UserService</code>。</p>
<code-example path="dependency-injection-in-action/src/app/user-context.service.ts" region="injectables" title="user-context.service.ts (injection)" linenums="false">
@<a href="/api/core/Injectable" class="code-anchor">Injectable</a>()
export class UserContextService {
  constructor(private userService: UserService, private loggerService: LoggerService) {
  }
}

</code-example>
<p translation-origin="off">When Angular creates the <code>AppComponent</code>, the dependency injection framework creates an instance of the <code>LoggerService</code> and
starts to create the <code>UserContextService</code>.
The <code>UserContextService</code> needs the <code>LoggerService</code>, which the framework already has, and the <code>UserService</code>, which it has yet to create.
The <code>UserService</code> has no dependencies so the dependency injection framework can just
use <code>new</code> to instantiate one.</p>
<p translation-result="">当 Angular 新建 <code>AppComponent</code> 时，依赖注入框架先创建一个 <code>LoggerService</code> 的实例，然后创建 <code>UserContextService</code> 实例。
<code>UserContextService</code> 需要框架已经创建好的 <code>LoggerService</code> 实例和尚未创建的 <code>UserService</code> 实例。
<code>UserService</code> 没有其它依赖，所以依赖注入框架可以直接 <code>new</code> 一个实例。</p>
<p translation-origin="off">The beauty of dependency injection is that <code>AppComponent</code> doesn't care about any of this.
You simply declare what is needed in the constructor (<code>LoggerService</code> and <code>UserContextService</code>)
and the framework does the rest.</p>
<p translation-result="">依赖注入最帅的地方在于，<code>AppComponent</code> 的作者不需要在乎这一切。作者只是在(<code>LoggerService</code> 和 <code>UserContextService</code> 的)构造函数里面简单的声明一下，框架就完成了剩下的工作。</p>
<p translation-origin="off">Once all the dependencies are in place, the <code>AppComponent</code> displays the user information:</p>
<p translation-result="">一旦所有依赖都准备好了，<code>AppComponent</code> 就会显示用户信息：</p>
<figure>
  <img src="generated/images/guide/dependency-injection-in-action/logged-in-user.png" alt="Logged In User" width="145" height="99">
</figure>
<a id="injectable-1"></a>
<h3 translation-origin="off" id="injectable"><em>@Injectable()</em><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#injectable"><i class="material-icons">link</i></a></h3>
<h3 translation-result="" id="eminjectableem"><em>@Injectable()</em> 注解<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#eminjectableem"><i class="material-icons">link</i></a></h3>
<p translation-origin="off">Notice the <code>@<a href="/api/core/Injectable" class="code-anchor">Injectable</a>()</code>decorator on the <code>UserContextService</code> class.</p>
<p translation-result="">注意在 <code>UserContextService</code> 类里面的 <code>@<a href="/api/core/Injectable" class="code-anchor">Injectable</a>()</code> 装饰器。</p>
<code-example path="dependency-injection-in-action/src/app/user-context.service.ts" region="injectable" title="user-context.service.ts (@Injectable)" linenums="false">
@<a href="/api/core/Injectable" class="code-anchor">Injectable</a>()
export class UserContextService {
}

</code-example>
<p translation-origin="off">The <code>@<a href="/api/core/Injectable" class="code-anchor">Injectable</a></code> decorator indicates that the Angular DI system is used to create one or more instances of <code>UserContextService</code>.</p>
<p translation-result=""><code>@<a href="/api/core/Injectable" class="code-anchor">Injectable</a></code> 装饰器会向 Angular DI 系统指明应该为 <code>UserContextService</code> 创建一个实例还是多个实例。</p>
<a id="service-scope"></a>
<h2 translation-origin="off" id="limit-service-scope-to-a-component-subtree">Limit service scope to a component subtree<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#limit-service-scope-to-a-component-subtree"><i class="material-icons">link</i></a></h2>
<h2 translation-result="" id="limit-service-scope-to-a-component-subtree">把服务作用域限制到一个组件支树<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#limit-service-scope-to-a-component-subtree"><i class="material-icons">link</i></a></h2>
<p translation-origin="off">All injected service dependencies are singletons meaning that,
for a given dependency injector, there is only one instance of service.</p>
<p translation-result="">所有被注入的服务依赖都是单例的，也就是说，在任意一个依赖注入器("injector")中，每个服务只有唯一的实例。</p>
<p translation-origin="off">But an Angular application has multiple dependency injectors, arranged in a tree hierarchy that parallels the component tree.
So a particular service can be <em>provided</em> and created at any component level and multiple times
if provided in multiple components.</p>
<p translation-result="">但是 Angular 应用程序有多个依赖注入器，组织成一个与组件树平行的树状结构。所以，可以在任何组件级别<em>提供</em>(和建立)特定的服务。如果在多个组件中注入，服务就会被新建出多个实例，分别提供给不同的组件。</p>
<p translation-origin="off">By default, a service dependency provided in one component is visible to all of its child components and
Angular injects the same service instance into all child components that ask for that service.</p>
<p translation-result="">默认情况下，一个组件中注入的服务依赖，会在该组件的所有子组件中可见，而且 Angular 会把同样的服务实例注入到需要该服务的子组件中。</p>
<p translation-origin="off">Accordingly, dependencies provided in the root <code>AppComponent</code> can be injected into <em>any</em> component <em>anywhere</em> in the application.</p>
<p translation-result="">所以，在根部的 <code>AppComponent</code> 提供的依赖单例就能被注入到应用程序中<em>任何地方</em>的<em>任何</em>组件。</p>
<p translation-origin="off">That isn't always desirable.
Sometimes you want to restrict service availability to a particular region of the application.</p>
<p translation-result="">但这不一定总是想要的。有时候你想要把服务的有效性限制到应用程序的一个特定区域。</p>
<p translation-origin="off">You can limit the scope of an injected service to a <em>branch</em> of the application hierarchy
by providing that service <em>at the sub-root component for that branch</em>.
This example shows how similar providing a service to a sub-root component is
to providing a service in the root <code>AppComponent</code>. The syntax is the same.
Here, the <code>HeroService</code> is available to the <code>HeroesBaseComponent</code> because it is in the <code>providers</code> array:</p>
<p translation-result="">通过<em>在组件树的子级根组件</em>中提供服务，可以把一个被注入服务的作用域局限在应用程序结构中的某个<em>分支</em>中。
这个例子中展示了为子组件和根组件 <code>AppComponent</code> 提供服务的相似之处，它们的语法是相同的。
这里通过列入 <code>providers</code> 数组，在 <code>HeroesBaseComponent</code> 中提供了 <code>HeroService</code>：</p>
<code-example path="dependency-injection-in-action/src/app/sorted-heroes.component.ts" region="injection" title="src/app/sorted-heroes.component.ts (HeroesBaseComponent excerpt)">
@<a href="/api/core/Component" class="code-anchor">Component</a>({
  selector: 'app-unsorted-heroes',
  <a href="/api/core/Component#template" class="code-anchor">template</a>: `&#x3C;div *<a href="/api/common/NgForOf" class="code-anchor">ngFor</a>="let hero of heroes">{{hero.name}}&#x3C;/div>`,
  providers: [HeroService]
})
export class HeroesBaseComponent implements <a href="/api/core/OnInit" class="code-anchor">OnInit</a> {
  constructor(private heroService: HeroService) { }
}

</code-example>
<p translation-origin="off">When Angular creates the <code>HeroesBaseComponent</code>, it also creates a new instance of <code>HeroService</code>
that is visible only to the component and its children, if any.</p>
<p translation-result="">当 Angular 新建 <code>HeroBaseComponent</code> 的时候，它会同时新建一个 <code>HeroService</code> 实例，该实例只在该组件及其子组件(如果有)中可见。</p>
<p translation-origin="off">You could also provide the <code>HeroService</code> to a <em>different</em> component elsewhere in the application.
That would result in a <em>different</em> instance of the service, living in a <em>different</em> injector.</p>
<p translation-result="">也可以在应用程序别处的<em>不同的</em>组件里提供 <code>HeroService</code>。这样就会导致在<em>不同</em>注入器中存在该服务的<em>不同</em>实例。</p>
<div class="alert is-helpful">
<p translation-origin="off">Examples of such scoped <code>HeroService</code> singletons appear throughout the accompanying sample code,
including the <code>HeroBiosComponent</code>, <code>HeroOfTheMonthComponent</code>, and <code>HeroesBaseComponent</code>.
Each of these components has its own <code>HeroService</code> instance managing its own independent collection of heroes.</p>
<p translation-result="">这个例子中，局部化的 <code>HeroService</code> 单例，遍布整份范例代码，包括 <code>HeroBiosComponent</code>、<code>HeroOfTheMonthComponent</code> 和 <code>HeroBaseComponent</code>。
这些组件每个都有自己的 <code>HeroService</code> 实例，用来管理独立的英雄库。</p>
</div>
<div class="alert is-helpful">
<h3 translation-origin="off" id="take-a-break">Take a break!<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#take-a-break"><i class="material-icons">link</i></a></h3>
<h3 translation-result="" id="take-a-break">休息一下！<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#take-a-break"><i class="material-icons">link</i></a></h3>
<p translation-origin="off">This much Dependency Injection knowledge may be all that many Angular developers
ever need to build their applications. It doesn't always have to be more complicated.</p>
<p translation-result="">对一些 Angular 开发者来说，这么多依赖注入知识可能已经是它们需要知道的全部了。不是每个人都需要更复杂的用法。</p>
</div>
<a id="multiple-service-instances"></a>
<h2 translation-origin="off" id="multiple-service-instances-sandboxing">Multiple service instances (sandboxing)<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#multiple-service-instances-sandboxing"><i class="material-icons">link</i></a></h2>
<h2 translation-result="" id="multiple-service-instances-sandboxing">多个服务实例(sandboxing)<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#multiple-service-instances-sandboxing"><i class="material-icons">link</i></a></h2>
<p translation-origin="off">Sometimes you want multiple instances of a service at <em>the same level of the component hierarchy</em>.</p>
<p translation-result="">在<em>同一个级别的组件树</em>里，有时需要一个服务的多个实例。</p>
<p translation-origin="off">A good example is a service that holds state for its companion component instance.
You need a separate instance of the service for each component.
Each service has its own work-state, isolated from the service-and-state of a different component.
This is called <em>sandboxing</em> because each service and component instance has its own sandbox to play in.</p>
<p translation-result="">一个用来保存其伴生组件的实例状态的服务就是个好例子。
每个组件都需要该服务的单独实例。
每个服务有自己的工作状态，与其它组件的服务和状态隔离。这叫做<em>沙箱化</em>，因为每个服务和组件实例都在自己的沙箱里运行。</p>
<a id="hero-bios-component"></a>
<p translation-origin="off">Imagine a <code>HeroBiosComponent</code> that presents three instances of the <code>HeroBioComponent</code>.</p>
<p translation-result="">想象一下，一个 <code>HeroBiosComponent</code> 组件显示三个 <code>HeroBioComponent</code> 的实例。</p>
<code-example path="dependency-injection-in-action/src/app/hero-bios.component.ts" region="simple" title="ap/hero-bios.component.ts">
@<a href="/api/core/Component" class="code-anchor">Component</a>({
  selector: 'app-hero-bios',
  <a href="/api/core/Component#template" class="code-anchor">template</a>: `
    &#x3C;app-hero-bio [heroId]="1">&#x3C;/app-hero-bio>
    &#x3C;app-hero-bio [heroId]="2">&#x3C;/app-hero-bio>
    &#x3C;app-hero-bio [heroId]="3">&#x3C;/app-hero-bio>`,
  providers: [HeroService]
})
export class HeroBiosComponent {
}

</code-example>
<p translation-origin="off">Each <code>HeroBioComponent</code> can edit a single hero's biography.
A <code>HeroBioComponent</code> relies on a <code>HeroCacheService</code> to fetch, cache, and perform other persistence operations on that hero.</p>
<p translation-result="">每个 <code>HeroBioComponent</code> 都能编辑一个英雄的生平。<code>HeroBioComponent</code> 依赖 <code>HeroCacheService</code> 服务来对该英雄进行读取、缓存和执行其它持久化操作。</p>
<code-example path="dependency-injection-in-action/src/app/hero-cache.service.ts" region="service" title="src/app/hero-cache.service.ts">
@<a href="/api/core/Injectable" class="code-anchor">Injectable</a>()
export class HeroCacheService {
  hero: Hero;
  constructor(private heroService: HeroService) {}

  fetchCachedHero(id: number) {
    if (!this.hero) {
      this.hero = this.heroService.getHeroById(id);
    }
    return this.hero;
  }
}

</code-example>
<p translation-origin="off">Clearly the three instances of the <code>HeroBioComponent</code> can't share the same <code>HeroCacheService</code>.
They'd be competing with each other to determine which hero to cache.</p>
<p translation-result="">很明显，这三个 <code>HeroBioComponent</code> 实例不能共享一样的 <code>HeroCacheService</code>。要不然它们会相互冲突，争相把自己的英雄放在缓存里面。</p>
<p translation-origin="off">Each <code>HeroBioComponent</code> gets its <em>own</em> <code>HeroCacheService</code> instance
by listing the <code>HeroCacheService</code> in its metadata <code>providers</code> array.</p>
<p translation-result="">通过在自己的元数据(metadata)<code>providers</code> 数组里面列出 <code>HeroCacheService</code>, 每个 <code>HeroBioComponent</code> 就能<em>拥有</em>自己独立的 <code>HeroCacheService</code> 实例。</p>
<code-example path="dependency-injection-in-action/src/app/hero-bio.component.ts" region="component" title="src/app/hero-bio.component.ts">
@<a href="/api/core/Component" class="code-anchor">Component</a>({
  selector: 'app-hero-bio',
  <a href="/api/core/Component#template" class="code-anchor">template</a>: `
    &#x3C;h4>{{hero.name}}&#x3C;/h4>
    &#x3C;ng-content>&#x3C;/ng-content>
    &#x3C;<a href="/api/forms/DefaultValueAccessor" class="code-anchor">textarea</a> cols="25" [(<a href="/api/forms/NgModel" class="code-anchor">ngModel</a>)]="hero.description">&#x3C;/<a href="/api/forms/DefaultValueAccessor" class="code-anchor">textarea</a>>`,
  providers: [HeroCacheService]
})

export class HeroBioComponent implements <a href="/api/core/OnInit" class="code-anchor">OnInit</a>  {
  @<a href="/api/core/Input" class="code-anchor">Input</a>() heroId: number;

  constructor(private heroCache: HeroCacheService) { }

  ngOnInit() { this.heroCache.fetchCachedHero(this.heroId); }

  get hero() { return this.heroCache.hero; }
}

</code-example>
<p translation-origin="off">The parent <code>HeroBiosComponent</code> binds a value to the <code>heroId</code>.
The <code>ngOnInit</code> passes that <code>id</code> to the service, which fetches and caches the hero.
The getter for the <code>hero</code> property pulls the cached hero from the service.
And the template displays this data-bound property.</p>
<p translation-result="">父组件 <code>HeroBiosComponent</code> 把一个值绑定到 <code>heroId</code>。<code>ngOnInit</code> 把该 <code>id</code> 传递到服务，然后服务获取和缓存英雄。<code>hero</code> 属性的 getter 从服务里面获取缓存的英雄，并在模板里显示它绑定到属性值。</p>
<p translation-origin="off">Find this example in <live-example name="dependency-injection-in-action">live code</live-example>
and confirm that the three <code>HeroBioComponent</code> instances have their own cached hero data.</p>
<p translation-result="">到<live-example name="dependency-injection-in-action">在线例子</live-example>中找到这个例子，确认三个 <code>HeroBioComponent</code> 实例拥有自己独立的英雄数据缓存。</p>
<figure>
  <img src="generated/images/guide/dependency-injection-in-action/hero-bios.png" alt="Bios" width="199" height="317">
</figure>
<a id="optional"></a>
<a id="qualify-dependency-lookup"></a>
<h2 translation-origin="off" id="qualify-dependency-lookup-with-optional-and-host">Qualify dependency lookup with <em>@Optional()</em> and <code>@<a href="/api/core/Host" class="code-anchor">Host</a>()</code><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#qualify-dependency-lookup-with-optional-and-host"><i class="material-icons">link</i></a></h2>
<h2 translation-result="" id="qualify-dependency-lookup-with-emoptionalem-and-codehostcode">使用<em>@Optional()</em>和 <code>@<a href="/api/core/Host" class="code-anchor">Host</a>()</code> 装饰器来限定依赖查找方式<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#qualify-dependency-lookup-with-emoptionalem-and-codehostcode"><i class="material-icons">link</i></a></h2>
<p translation-origin="off">As you now know, dependencies can be registered at any level in the component hierarchy.</p>
<p translation-result="">你知道，依赖可以被注入到任何组件级别。</p>
<p translation-origin="off">When a component requests a dependency, Angular starts with that component's injector and walks up the injector tree
until it finds the first suitable provider.  Angular throws an error if it can't find the dependency during that walk.</p>
<p translation-result="">当组件申请一个依赖时，Angular 从该组件本身的注入器开始，沿着依赖注入器的树往上找，直到找到第一个符合要求的提供商。如果 Angular 不能在这个过程中找到合适的依赖，它就会抛出一个错误。</p>
<p translation-origin="off">You <em>want</em> this behavior most of the time.
But sometimes you need to limit the search and/or accommodate a missing dependency.
You can modify Angular's search behavior with the <code>@<a href="/api/core/Host" class="code-anchor">Host</a></code> and <code>@<a href="/api/core/Optional" class="code-anchor">Optional</a></code> qualifying decorators,
used individually or together.</p>
<p translation-result="">大部分时候，你确实<em>想要</em>这个行为。
但是有时候，需要限制这个(依赖)查找逻辑，且/或提供一个缺失的依赖。
单独或联合使用 <code>@<a href="/api/core/Host" class="code-anchor">Host</a></code> 和 <code>@<a href="/api/core/Optional" class="code-anchor">Optional</a></code> 限定型装饰器，就可以修改 Angular 的查找行为。</p>
<p translation-origin="off">The <code>@<a href="/api/core/Optional" class="code-anchor">Optional</a></code> decorator tells Angular to continue when it can't find the dependency.
Angular sets the injection parameter to <code>null</code> instead.</p>
<p translation-result="">当 Angular 找不到依赖时，<code>@<a href="/api/core/Optional" class="code-anchor">Optional</a></code> 装饰器会告诉 Angular 继续执行。Angular 把此注入参数设置为 <code>null</code>(而不用默认的抛出错误的行为)。</p>
<p translation-origin="off">The <code>@<a href="/api/core/Host" class="code-anchor">Host</a></code> decorator stops the upward search at the <em>host component</em>.</p>
<p translation-result=""><code>@<a href="/api/core/Host" class="code-anchor">Host</a></code> 装饰器将把往上搜索的行为截止在<em>宿主组件</em></p>
<p translation-origin="off">The host component is typically the component requesting the dependency.
But when this component is projected into a <em>parent</em> component, that parent component becomes the host.
The next example covers this second case.</p>
<p translation-result="">宿主组件通常是申请这个依赖的组件。但当这个组件被投影(projected)进一个<em>父组件</em>后，这个父组件就变成了宿主。
下一个例子会演示第二种情况。</p>
<a id="demonstration"></a>
<h3 translation-origin="off" id="demonstration">Demonstration<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#demonstration"><i class="material-icons">link</i></a></h3>
<h3 translation-result="" id="demonstration">示范<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#demonstration"><i class="material-icons">link</i></a></h3>
<p translation-origin="off">The <code>HeroBiosAndContactsComponent</code> is a revision of the <code>HeroBiosComponent</code> that you looked at <a href="/guide/dependency-injection-in-action#hero-bios-component">above</a>.</p>
<p translation-result=""><code>HeroBiosAndContactsComponent</code> 是<a href="/guide/dependency-injection-in-action#hero-bios-component">前面</a>见过的 <code>HeroBiosComponent</code> 的修改版。</p>
<code-example path="dependency-injection-in-action/src/app/hero-bios.component.ts" region="hero-bios-and-contacts" title="src/app/hero-bios.component.ts (HeroBiosAndContactsComponent)">
@<a href="/api/core/Component" class="code-anchor">Component</a>({
  selector: 'app-hero-bios-and-contacts',
  <a href="/api/core/Component#template" class="code-anchor">template</a>: `
    &#x3C;app-hero-bio [heroId]="1"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio>
    &#x3C;app-hero-bio [heroId]="2"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio>
    &#x3C;app-hero-bio [heroId]="3"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio>`,
  providers: [HeroService]
})
export class HeroBiosAndContactsComponent {
  constructor(logger: LoggerService) {
    logger.logInfo('Creating HeroBiosAndContactsComponent');
  }
}

</code-example>
<p translation-origin="off">Focus on the template:</p>
<p translation-result="">注意看模板：</p>
<code-example path="dependency-injection-in-action/src/app/hero-bios.component.ts" region="template" title="dependency-injection-in-action/src/app/hero-bios.component.ts" linenums="false">
<a href="/api/core/Component#template" class="code-anchor">template</a>: `
  &#x3C;app-hero-bio [heroId]="1"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio>
  &#x3C;app-hero-bio [heroId]="2"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio>
  &#x3C;app-hero-bio [heroId]="3"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio>`,

</code-example>
<p translation-origin="off">Now there is a new <code>&#x3C;hero-contact></code> element between the <code>&#x3C;hero-bio></code> tags.
Angular <em>projects</em>, or <em>transcludes</em>, the corresponding <code>HeroContactComponent</code> into the <code>HeroBioComponent</code> view,
placing it in the <code>&#x3C;ng-content></code> slot of the <code>HeroBioComponent</code> template:</p>
<p translation-result="">在 <code>&#x3C;hero-bio></code> 标签中是一个新的 <code>&#x3C;hero-contact></code> 元素。Angular 就会把相应的 <code>HeroContactComponent</code><em>投影</em>(<em>transclude</em>)进 <code>HeroBioComponent</code> 的视图里，
将它放在 <code>HeroBioComponent</code> 模板的 <code>&#x3C;ng-content></code> 标签槽里。</p>
<code-example path="dependency-injection-in-action/src/app/hero-bio.component.ts" region="template" title="src/app/hero-bio.component.ts (template)" linenums="false">
<a href="/api/core/Component#template" class="code-anchor">template</a>: `
  &#x3C;h4>{{hero.name}}&#x3C;/h4>
  &#x3C;ng-content>&#x3C;/ng-content>
  &#x3C;<a href="/api/forms/DefaultValueAccessor" class="code-anchor">textarea</a> cols="25" [(<a href="/api/forms/NgModel" class="code-anchor">ngModel</a>)]="hero.description">&#x3C;/<a href="/api/forms/DefaultValueAccessor" class="code-anchor">textarea</a>>`,

</code-example>
<p translation-origin="off">It looks like this, with the hero's telephone number from <code>HeroContactComponent</code> projected above the hero description:</p>
<p translation-result="">从 <code>HeroContactComponent</code> 获得的英雄电话号码，被投影到上面的英雄描述里，就像这样：</p>
<figure>
  <img src="generated/images/guide/dependency-injection-in-action/hero-bio-and-content.png" alt="bio and contact" width="199" height="92">
</figure>
<p translation-origin="off">Here's the <code>HeroContactComponent</code> which demonstrates the qualifying decorators:</p>
<p translation-result="">下面的 <code>HeroContactComponent</code>，示范了限定型装饰器(@Optional 和@Host)：</p>
<code-example path="dependency-injection-in-action/src/app/hero-contact.component.ts" region="component" title="src/app/hero-contact.component.ts">
@<a href="/api/core/Component" class="code-anchor">Component</a>({
  selector: 'app-hero-contact',
  <a href="/api/core/Component#template" class="code-anchor">template</a>: `
  &#x3C;div>Phone #: {{phoneNumber}}
  &#x3C;span *<a href="/api/common/NgIf" class="code-anchor">ngIf</a>="hasLogger">!!!&#x3C;/span>&#x3C;/div>`
})
export class HeroContactComponent {

  hasLogger = false;

  constructor(
      @<a href="/api/core/Host" class="code-anchor">Host</a>() // <a href="/api/animations/AnimationQueryOptions#limit" class="code-anchor">limit</a> to the <a href="/api/core/Directive#host" class="code-anchor">host</a> component's instance of the HeroCacheService
      private heroCache: HeroCacheService,

      @<a href="/api/core/Host" class="code-anchor">Host</a>()     // <a href="/api/animations/AnimationQueryOptions#limit" class="code-anchor">limit</a> <a href="/api/common/PlatformLocation#search" class="code-anchor">search</a> for logger; hides the application-wide logger
      @<a href="/api/core/Optional" class="code-anchor">Optional</a>() // ok if the logger doesn't exist
      private loggerService: LoggerService
  ) {
    if (loggerService) {
      this.hasLogger = true;
      loggerService.logInfo('HeroContactComponent can <a href="/api/animations/browser/testing/MockAnimationDriver#log" class="code-anchor">log</a>!');
    }
  }

  get phoneNumber() { return this.heroCache.hero.phone; }

}

</code-example>
<p translation-origin="off">Focus on the constructor parameters:</p>
<p translation-result="">注意看构造函数的参数：</p>
<code-example path="dependency-injection-in-action/src/app/hero-contact.component.ts" region="ctor-params" title="src/app/hero-contact.component.ts" linenums="false">
@<a href="/api/core/Host" class="code-anchor">Host</a>() // <a href="/api/animations/AnimationQueryOptions#limit" class="code-anchor">limit</a> to the <a href="/api/core/Directive#host" class="code-anchor">host</a> component's instance of the HeroCacheService
private heroCache: HeroCacheService,

@<a href="/api/core/Host" class="code-anchor">Host</a>()     // <a href="/api/animations/AnimationQueryOptions#limit" class="code-anchor">limit</a> <a href="/api/common/PlatformLocation#search" class="code-anchor">search</a> for logger; hides the application-wide logger
@<a href="/api/core/Optional" class="code-anchor">Optional</a>() // ok if the logger doesn't exist
private loggerService: LoggerService

</code-example>
<p translation-origin="off">The <code>@<a href="/api/core/Host" class="code-anchor">Host</a>()</code> function decorating the  <code>heroCache</code> property ensures that
you get a reference to the cache service from the parent <code>HeroBioComponent</code>.
Angular throws an error if the parent lacks that service, even if a component higher
in the component tree happens to have it.</p>
<p translation-result=""><code>@<a href="/api/core/Host" class="code-anchor">Host</a>()</code> 函数是 <code>heroCache</code> 属性的装饰器，确保从其父组件 <code>HeroBioComponent</code> 得到一个缓存服务。如果该父组件不存在这个服务，Angular 就会抛出错误，即使组件树里的再上级有某个组件拥有这个服务，Angular 也会抛出错误。</p>
<p translation-origin="off">A second <code>@<a href="/api/core/Host" class="code-anchor">Host</a>()</code> function decorates the <code>loggerService</code> property.
The only <code>LoggerService</code> instance in the app is provided at the <code>AppComponent</code> level.
The host <code>HeroBioComponent</code> doesn't have its own <code>LoggerService</code> provider.</p>
<p translation-result="">另一个 <code>@<a href="/api/core/Host" class="code-anchor">Host</a>()</code> 函数是属性 <code>loggerService</code> 的装饰器。
在本应用程序中只有一个在 <code>AppComponent</code> 级提供的 <code>LoggerService</code> 实例。
该宿主 <code>HeroBioComponent</code> 没有自己的 <code>LoggerService</code> 提供商。</p>
<p translation-origin="off">Angular would throw an error if you hadn't also decorated the property with the <code>@<a href="/api/core/Optional" class="code-anchor">Optional</a>()</code> function.
Thanks to <code>@<a href="/api/core/Optional" class="code-anchor">Optional</a>()</code>, Angular sets the <code>loggerService</code> to null and the rest of the component adapts.</p>
<p translation-result="">如果没有同时使用 <code>@<a href="/api/core/Optional" class="code-anchor">Optional</a>()</code> 装饰器的话，Angular 就会抛出错误。多亏了 <code>@<a href="/api/core/Optional" class="code-anchor">Optional</a>()</code>，Angular 把 <code>loggerService</code> 设置为 null，并继续执行组件而不会抛出错误。</p>
<p translation-origin="off">Here's the <code>HeroBiosAndContactsComponent</code> in action.</p>
<p translation-result="">下面是 <code>HeroBiosAndContactsComponent</code> 的执行结果：</p>
<figure>
  <img src="generated/images/guide/dependency-injection-in-action/hero-bios-and-contacts.png" alt="Bios with contact into" width="206" height="393">
</figure>
<p translation-origin="off">If you comment out the <code>@<a href="/api/core/Host" class="code-anchor">Host</a>()</code> decorator, Angular now walks up the injector ancestor tree
until it finds the logger at the <code>AppComponent</code> level. The logger logic kicks in and the hero display updates
with the gratuitous "!!!", indicating that the logger was found.</p>
<p translation-result="">如果注释掉 <code>@<a href="/api/core/Host" class="code-anchor">Host</a>()</code> 装饰器，Angular 就会沿着注入器树往上走，直到在 <code>AppComponent</code> 中找到该日志服务。日志服务的逻辑加入进来，更新了英雄的显示信息，这表明确实找到了日志服务。</p>
<figure>
  <img src="generated/images/guide/dependency-injection-in-action/hero-bio-contact-no-host.png" alt="Without @Host" width="199" height="93">
</figure>
<p translation-origin="off">On the other hand, if you restore the <code>@<a href="/api/core/Host" class="code-anchor">Host</a>()</code> decorator and comment out <code>@<a href="/api/core/Optional" class="code-anchor">Optional</a></code>,
the application fails for lack of the required logger at the host component level.
<br>
<code>EXCEPTION: No provider for LoggerService! (HeroContactComponent -> LoggerService)</code></p>
<p translation-result="">另一方面，如果恢复 <code>@<a href="/api/core/Host" class="code-anchor">Host</a>()</code> 装饰器，注释掉 <code>@<a href="/api/core/Optional" class="code-anchor">Optional</a></code>，应用程序就会运行失败，因为它在宿主组件级别找不到需要的日志服务。
<br>
<code>EXCEPTION: No provider for LoggerService! (HeroContactComponent -> LoggerService)</code></p>
<a id="component-element"></a>
<h2 translation-origin="off" id="inject-the-components-dom-element">Inject the component's DOM element<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#inject-the-components-dom-element"><i class="material-icons">link</i></a></h2>
<h2 translation-result="" id="inject-the-components-dom-element">注入组件的 DOM 元素<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#inject-the-components-dom-element"><i class="material-icons">link</i></a></h2>
<p translation-origin="off">On occasion you might need to access a component's corresponding DOM element.
Although developers strive to avoid it, many visual effects and 3rd party tools, such as jQuery,
require DOM access.</p>
<p translation-result="">偶尔，可能需要访问一个组件对应的 DOM 元素。尽量避免这样做，但还是有很多视觉效果和第三方工具(比如 jQuery)需要访问 DOM。</p>
<p translation-origin="off">To illustrate, here's a simplified version of the <code>HighlightDirective</code> from
the <a href="/guide/attribute-directives">Attribute Directives</a> page.</p>
<p translation-result="">要说明这一点，请在<a href="/guide/attribute-directives">属性型指令</a><code>HighlightDirective</code> 的基础上，编写一个简化版。</p>
<code-example path="dependency-injection-in-action/src/app/highlight.directive.ts" title="src/app/highlight.directive.ts">
import { <a href="/api/core/Directive" class="code-anchor">Directive</a>, <a href="/api/core/ElementRef" class="code-anchor">ElementRef</a>, <a href="/api/core/HostListener" class="code-anchor">HostListener</a>, <a href="/api/core/Input" class="code-anchor">Input</a> } from '@angular/core';

@<a href="/api/core/Directive" class="code-anchor">Directive</a>({
  selector: '[appHighlight]'
})
export class HighlightDirective {

  @<a href="/api/core/Input" class="code-anchor">Input</a>('appHighlight') highlightColor: string;

  private el: HTMLElement;

  constructor(el: <a href="/api/core/ElementRef" class="code-anchor">ElementRef</a>) {
    this.el = el.nativeElement;
  }

  @<a href="/api/core/HostListener" class="code-anchor">HostListener</a>('mouseenter') onMouseEnter() {
    this.highlight(this.highlightColor || 'cyan');
  }

  @<a href="/api/core/HostListener" class="code-anchor">HostListener</a>('mouseleave') onMouseLeave() {
    this.highlight(null);
  }

  private highlight(color: string) {
    this.el.style.backgroundColor = color;
  }
}


</code-example>
<p translation-origin="off">The directive sets the background to a highlight color when the user mouses over the
DOM element to which it is applied.</p>
<p translation-result="">当用户把鼠标移到 DOM 元素上时，指令将该元素的背景设置为一个高亮颜色。</p>
<p translation-origin="off">Angular sets the constructor's <code>el</code> parameter to the injected <code><a href="/api/core/ElementRef" class="code-anchor">ElementRef</a></code>, which is
a wrapper around that DOM element.
Its <code>nativeElement</code> property exposes the DOM element for the directive to manipulate.</p>
<p translation-result="">Angular 把构造函数参数 <code>el</code> 设置为注入的 <code><a href="/api/core/ElementRef" class="code-anchor">ElementRef</a></code>，该 <code><a href="/api/core/ElementRef" class="code-anchor">ElementRef</a></code> 代表了宿主的 DOM 元素， 它的 <code>nativeElement</code> 属性把该 DOM 元素暴露给了指令。</p>
<p translation-origin="off">The sample code applies the directive's <code>myHighlight</code> attribute to two <code>&#x3C;div></code> tags,
first without a value (yielding the default color) and then with an assigned color value.</p>
<p translation-result="">下面的代码把指令的 <code>myHighlight</code> 属性(Attribute)填加到两个 <code>&#x3C;div></code> 标签里，一个没有赋值，一个赋值了颜色。</p>
<code-example path="dependency-injection-in-action/src/app/app.component.html" region="highlight" title="src/app/app.component.html (highlight)" linenums="false">
&#x3C;div id="highlight"  class="di-component"  appHighlight>
  &#x3C;h3>Hero Bios and Contacts&#x3C;/h3>
  &#x3C;div appHighlight="yellow">
    &#x3C;app-hero-bios-and-contacts>&#x3C;/app-hero-bios-and-contacts>
  &#x3C;/div>
&#x3C;/div>

</code-example>
<p translation-origin="off">The following image shows the effect of mousing over the <code>&#x3C;hero-bios-and-contacts></code> tag.</p>
<p translation-result="">下图显示了鼠标移到 <code>&#x3C;hero-bios-and-contacts></code> 标签的效果：</p>
<figure>
  <img src="generated/images/guide/dependency-injection-in-action/highlight.png" alt="Highlighted bios" width="318" height="196">
</figure>
<a id="providers"></a>
<h2 translation-origin="off" id="define-dependencies-with-providers">Define dependencies with providers<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#define-dependencies-with-providers"><i class="material-icons">link</i></a></h2>
<h2 translation-result="" id="define-dependencies-with-providers">使用提供商来定义依赖<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#define-dependencies-with-providers"><i class="material-icons">link</i></a></h2>
<p translation-origin="off">This section demonstrates how to write providers that deliver dependent services.</p>
<p translation-result="">本节将演示如何编写提供商来提供被依赖的服务。</p>
<p translation-origin="off">Get a service from a dependency injector by giving it a <strong><em>token</em></strong>.</p>
<p translation-result="">给依赖注入器提供<strong><em>令牌</em></strong>来获取服务。</p>
<p translation-origin="off">You usually let Angular handle this transaction by specifying a constructor parameter and its type.
The parameter type serves as the injector lookup <em>token</em>.
Angular passes this token to the injector and assigns the result to the parameter.
Here's a typical example:</p>
<p translation-result="">你通常在构造函数里面，为参数指定类型，让 Angular 来处理依赖注入。该参数类型就是依赖注入器所需的<em>令牌</em>。
Angular 把该令牌传给注入器，然后把得到的结果赋给参数。下面是一个典型的例子：</p>
<code-example path="dependency-injection-in-action/src/app/hero-bios.component.ts" region="ctor" title="src/app/hero-bios.component.ts (component constructor injection)" linenums="false">
constructor(logger: LoggerService) {
  logger.logInfo('Creating HeroBiosComponent');
}

</code-example>
<p translation-origin="off">Angular asks the injector for the service associated with the <code>LoggerService</code>
and assigns the returned value to the <code>logger</code> parameter.</p>
<p translation-result="">Angular 向注入器请求与 <code>LoggerService</code> 对应的服务，并将返回值赋给 <code>logger</code> 参数。</p>
<p translation-origin="off">Where did the injector get that value?
It may already have that value in its internal container.
If it doesn't, it may be able to make one with the help of a <strong><em>provider</em></strong>.
A <em>provider</em> is a recipe for delivering a service associated with a <em>token</em>.</p>
<p translation-result="">注入器从哪得到的依赖？
它可能在自己内部容器里已经有该依赖了。
如果它没有，也能在<strong><em>提供商</em></strong>的帮助下新建一个。
<em>提供商</em>就是一个用于交付服务的配方，它被关联到一个令牌。</p>
<div class="alert is-helpful">
<p translation-origin="off">If the injector doesn't have a provider for the requested <em>token</em>, it delegates the request
to its parent injector, where the process repeats until there are no more injectors.
If the search is futile, the injector throws an error—unless the request was <a href="/guide/dependency-injection-in-action#optional">optional</a>.</p>
<p translation-result="">如果注入器无法根据令牌在自己内部找到对应的提供商，它便将请求移交给它的父级注入器，这个过程不断重复，直到没有更多注入器为止。
如果没找到，注入器就抛出一个错误...除非这个请求是<a href="/guide/dependency-injection-in-action#optional">可选的</a>。</p>
</div>
<p translation-origin="off">A new injector has no providers.
Angular initializes the injectors it creates with some providers it cares about.
You have to register your <em>own</em> application providers manually,
usually in the <code>@<a href="/api/core/Injectable" class="code-anchor">Injectable</a></code> decorator of the service, <code>providers</code> array of the <code><a href="/api/core/NgModule" class="code-anchor">NgModule</a></code> or <code><a href="/api/core/Directive" class="code-anchor">Directive</a></code> metadata:</p>
<p translation-result="">新建的注入器中没有提供商。
Angular 会使用一些自带的提供商来初始化这些注入器。你必须自行注册属于<em>自己</em>的提供商，通常会在该服务的 <code>@<a href="/api/core/Injectable" class="code-anchor">Injectable</a></code> 装饰器中，或在 <code><a href="/api/core/NgModule" class="code-anchor">NgModule</a></code> 或 <code><a href="/api/core/Directive" class="code-anchor">Directive</a></code> 元数据的 <code>providers</code> 数组中进行注册。</p>
<code-example path="dependency-injection-in-action/src/app/app.component.ts" region="providers" title="src/app/app.component.ts (providers)">
providers: [ LoggerService, UserContextService, UserService ]

</code-example>
<a id="defining-providers"></a>
<h3 translation-origin="off" id="defining-providers">Defining providers<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#defining-providers"><i class="material-icons">link</i></a></h3>
<h3 translation-result="" id="defining-providers">定义提供商<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#defining-providers"><i class="material-icons">link</i></a></h3>
<p translation-origin="off">The simple way of defining providers in the <code>@<a href="/api/core/Injectable" class="code-anchor">Injectable</a></code> decorator of the class is recommended.</p>
<p translation-result="">建议直接在服务类的 <code>@<a href="/api/core/Injectable" class="code-anchor">Injectable</a></code> 装饰器中定义服务提供商。</p>
<code-example path="dependency-injection/src/app/heroes/hero.service.0.ts" title="src/app/heroes/hero.service.0.ts" linenums="false">
import { <a href="/api/core/Injectable" class="code-anchor">Injectable</a> } from '@angular/core';

@<a href="/api/core/Injectable" class="code-anchor">Injectable</a>({
  <a href="/api/core/Injectable#providedIn" class="code-anchor">providedIn</a>: 'root',
})
export class HeroService {
  constructor() { }
}


</code-example>
<p translation-origin="off">Another alternative is to mention the class in the providers array of the <code>@<a href="/api/core/NgModule" class="code-anchor">NgModule</a></code> and you're done.</p>
<p translation-result="">备选方案是在 <code>@<a href="/api/core/NgModule" class="code-anchor">NgModule</a></code> 的 <code>providers</code> 数组中引用下这个类就可以了。</p>
<code-example path="dependency-injection-in-action/src/app/hero-bios.component.ts" region="class-provider" title="src/app/hero-bios.component.ts (class provider)" linenums="false">
providers: [HeroService]

</code-example>
<p translation-origin="off">It's that simple because the most common injected service is an instance of a class.
But not every dependency can be satisfied by creating a new instance of a class.
You need other ways to deliver dependency values and that means you need other ways to specify a provider.</p>
<p translation-result="">注册类提供商之所以这么简单，是因为最常见的可注入服务就是一个类的实例。
但是，并不是所有的依赖都只要创建一个类的新实例就可以交付了。你还需要其它的交付方式，这意味着你也要用其它方式来指定提供商。</p>
<p translation-origin="off">The <code>HeroOfTheMonthComponent</code> example demonstrates many of the alternatives and why you need them.
It's visually simple: a few properties and the logs produced by a logger.</p>
<p translation-result=""><code>HeroOfTheMonthComponent</code> 例子示范了一些替代方案，展示了为什么需要它们。
它看起来很简单：一些属性和一个日志输出。</p>
<figure>
  <img src="generated/images/guide/dependency-injection-in-action/hero-of-month.png" alt="Hero of the month" width="300" height="165">
</figure>
<p translation-origin="off">The code behind it gives you plenty to think about.</p>
<p translation-result="">这段代码的背后有很多值得深入思考的地方。</p>
<code-example path="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" region="hero-of-the-month" title="hero-of-the-month.component.ts">
import { <a href="/api/core/Component" class="code-anchor">Component</a>, <a href="/api/core/Inject" class="code-anchor">Inject</a> } from '@angular/core';

import { DateLoggerService } from './date-logger.service';
import { Hero }              from './hero';
import { HeroService }       from './hero.service';
import { LoggerService }     from './logger.service';
import { MinimalLogger }     from './minimal-logger.service';
import { RUNNERS_UP,
         runnersUpFactory }  from './runners-up';

@<a href="/api/core/Component" class="code-anchor">Component</a>({
  selector: 'app-hero-of-the-month',
  templateUrl: './hero-of-the-month.component.html',
  providers: [
    { provide: Hero,          useValue:    someHero },
    { provide: TITLE,         useValue:   'Hero of the Month' },
    { provide: HeroService,   useClass:    HeroService },
    { provide: LoggerService, useClass:    DateLoggerService },
    { provide: MinimalLogger, useExisting: LoggerService },
    { provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), <a href="/api/core/ConstructorSansProvider#deps" class="code-anchor">deps</a>: [Hero, HeroService] }
  ]
})
export class HeroOfTheMonthComponent {
  logs: string[] = [];

  constructor(
      logger: MinimalLogger,
      public heroOfTheMonth: Hero,
      @<a href="/api/core/Inject" class="code-anchor">Inject</a>(RUNNERS_UP) public runnersUp: string,
      @<a href="/api/core/Inject" class="code-anchor">Inject</a>(TITLE) public title: string)
  {
    this.logs = logger.logs;
    logger.logInfo('starting up');
  }
}

</code-example>
<a id="provide"></a>
<h4 translation-origin="off" id="the-provide-object-literal">The <em>provide</em> object literal<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#the-provide-object-literal"><i class="material-icons">link</i></a></h4>
<h4 translation-result="" id="the-emprovideem-object-literal"><em>provide</em> 对象<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#the-emprovideem-object-literal"><i class="material-icons">link</i></a></h4>
<p translation-origin="off">The <code>provide</code> object literal takes a <em>token</em> and a <em>definition object</em>.
The <em>token</em> is usually a class but <a href="/guide/dependency-injection-in-action#tokens">it doesn't have to be</a>.</p>
<p translation-result="">该 <code>provide</code> 对象需要一个<em>令牌</em>和一个<em>定义对象</em>。该<em>令牌</em>通常是一个类，但<a href="/guide/dependency-injection-in-action#tokens">并非一定是</a></p>
<p translation-origin="off">The <em>definition</em> object has a required property that specifies how to create the singleton instance of the service. In this case, the property.</p>
<p translation-result="">该<em>定义</em>对象有一个必填属性(即 <code>useValue</code>)，用来标识该提供商会如何新建和返回该服务的单例对象。</p>
<a id="usevalue"></a>
<h4 translation-origin="off" id="usevaluethe-value-provider">useValue—the <em>value provider</em><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#usevaluethe-value-provider"><i class="material-icons">link</i></a></h4>
<h4 translation-result="" id="usevaluethe-emvalue-providerem">useValue - *值-提供商<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#usevaluethe-emvalue-providerem"><i class="material-icons">link</i></a></h4>
<p translation-origin="off">Set the <code>useValue</code> property to a <strong><em>fixed value</em></strong> that the provider can return as the service instance (AKA, the "dependency object").</p>
<p translation-result="">把一个<strong>*固定的值</strong>，也就是该提供商可以将其作为依赖对象返回的值，赋给 <code>useValue</code> 属性。</p>
<p translation-origin="off">Use this technique to provide <em>runtime configuration constants</em> such as website base addresses and feature flags.
You can use a <em>value provider</em> in a unit test to replace a production service with a fake or mock.</p>
<p translation-result="">使用该技巧来进行<em>运行期常量设置</em>，比如网站的基础地址和功能标志等。
你通常在单元测试中使用<em>值-提供商</em>，用一个假的或模仿的(服务)来取代一个生产环境的服务。</p>
<p translation-origin="off">The <code>HeroOfTheMonthComponent</code> example has two <em>value providers</em>.
The first provides an instance of the <code>Hero</code> class;
the second specifies a literal string resource:</p>
<p translation-result=""><code>HeroOfTheMonthComponent</code> 例子有两个<em>值-提供商</em>。
第一个提供了一个 <code>Hero</code> 类的实例；第二个指定了一个字符串资源：</p>
<code-example path="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" region="use-value" title="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" linenums="false">
{ provide: Hero,          useValue:    someHero },
{ provide: TITLE,         useValue:   'Hero of the Month' },

</code-example>
<p translation-origin="off">The <code>Hero</code> provider token is a class which makes sense because the value is a <code>Hero</code>
and the consumer of the injected hero would want the type information.</p>
<p translation-result=""><code>Hero</code> 提供商的令牌是一个类，这很合理，因为它提供的结果是一个 <code>Hero</code> 实例，并且被注入该英雄的消费者也需要知道它类型信息。</p>
<p translation-origin="off">The <code>TITLE</code> provider token is <em>not a class</em>.
It's a special kind of provider lookup key called an <a href="/guide/dependency-injection-in-action#injection-token">InjectionToken</a>.
You can use an <code><a href="/api/core/InjectionToken" class="code-anchor">InjectionToken</a></code> for any kind of provider but it's particular
helpful when the dependency is a simple value like a string, a number, or a function.</p>
<p translation-result=""><code>TITLE</code> 提供商的令牌<em>不是一个类</em>。它是一个特别类型的提供商查询键，名叫<a href="/guide/dependency-injection-in-action#injection-token">InjectionToken</a>.
你可以把 <code><a href="/api/core/InjectionToken" class="code-anchor">InjectionToken</a></code> 用作任何类型的提供商的令牌，但是它在依赖是简单类型（比如字符串、数字、函数）时会特别有帮助。</p>
<p translation-origin="off">The value of a <em>value provider</em> must be defined <em>now</em>. You can't create the value later.
Obviously the title string literal is immediately available.
The <code>someHero</code> variable in this example was set earlier in the file:</p>
<p translation-result="">一个<em>值-提供商</em>的值必须要<em>立即</em>定义。不能事后再定义它的值。很显然，标题字符串是立刻可用的。
该例中的 <code>someHero</code> 变量是以前在下面这个文件中定义的：</p>
<code-example path="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" region="some-hero" title="dependency-injection-in-action/src/app/hero-of-the-month.component.ts">
const someHero = new Hero(42, 'Magma', 'Had <a href="/api/router/RouterLinkWithHref" class="code-anchor">a</a> great month!', '555-555-5555');

</code-example>
<p translation-origin="off">The other providers create their values <em>lazily</em> when they're needed for injection.</p>
<p translation-result="">其它提供商只在需要注入它们的时候才创建并<em>惰性加载</em>它们的值。</p>
<a id="useclass"></a>
<h4 translation-origin="off" id="useclassthe-class-provider">useClass—the <em>class provider</em><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#useclassthe-class-provider"><i class="material-icons">link</i></a></h4>
<h4 translation-result="" id="useclassthe-emclass-providerem">useClass - <em>类-提供商</em><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#useclassthe-emclass-providerem"><i class="material-icons">link</i></a></h4>
<p translation-origin="off">The <code>useClass</code> provider creates and returns new instance of the specified class.</p>
<p translation-result=""><code>userClass</code> 提供商创建并返回一个指定类的新实例。</p>
<p translation-origin="off">Use this technique to <strong><em>substitute an alternative implementation</em></strong> for a common or default class.
The alternative could implement a different strategy, extend the default class,
or fake the behavior of the real class in a test case.</p>
<p translation-result="">使用该技术来为公共或默认类<strong><em>提供备选实现</em></strong>。该替代品能实现一个不同的策略，比如拓展默认类或者在测试的时候假冒真实类。</p>
<p translation-origin="off">Here are two examples in the <code>HeroOfTheMonthComponent</code>:</p>
<p translation-result="">请看下面 <code>HeroOfTheMonthComponent</code> 里的两个例子：</p>
<code-example path="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" region="use-class" title="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" linenums="false">
{ provide: HeroService,   useClass:    HeroService },
{ provide: LoggerService, useClass:    DateLoggerService },

</code-example>
<p translation-origin="off">The first provider is the <em>de-sugared</em>, expanded form of the most typical case in which the
class to be created (<code>HeroService</code>) is also the provider's dependency injection token.
It's in this long form to de-mystify the preferred short form.</p>
<p translation-result="">第一个提供商是<em>展开了语法糖的</em>，是一个典型情况的展开。一般来说，被新建的类(<code>HeroService</code>)同时也是该提供商的注入令牌。
这里用完整形态来编写它，来反衬更受欢迎的缩写形式。</p>
<p translation-origin="off">The second provider substitutes the <code>DateLoggerService</code> for the <code>LoggerService</code>.
The <code>LoggerService</code> is already registered at the <code>AppComponent</code> level.
When <em>this component</em> requests the <code>LoggerService</code>, it receives the <code>DateLoggerService</code> instead.</p>
<p translation-result="">第二个提供商使用 <code>DateLoggerService</code> 来满足 <code>LoggerService</code>。该 <code>LoggerService</code> 在 <code>AppComponent</code> 级别已经被注册。当<em>这个组件</em>要求 <code>LoggerService</code> 的时候，它得到的却是 <code>DateLoggerService</code> 服务。</p>
<div class="alert is-helpful">
<p translation-origin="off">This component and its tree of child components receive the <code>DateLoggerService</code> instance.
Components outside the tree continue to receive the original <code>LoggerService</code> instance.</p>
<p translation-result="">这个组件及其子组件会得到 <code>DateLoggerService</code> 实例。这个组件树之外的组件得到的仍是 <code>LoggerService</code> 实例。</p>
</div>
<p translation-origin="off">The <code>DateLoggerService</code> inherits from <code>LoggerService</code>; it appends the current date/time to each message:</p>
<p translation-result=""><code>DateLoggerService</code> 从 <code>LoggerService</code> 继承；它把当前的日期/时间附加到每条信息上。</p>
<code-example path="dependency-injection-in-action/src/app/date-logger.service.ts" region="date-logger-service" title="src/app/date-logger.service.ts" linenums="false">
@<a href="/api/core/Injectable" class="code-anchor">Injectable</a>()
export class DateLoggerService extends LoggerService
{
  logInfo(msg: any)  { super.logInfo(stamp(msg)); }
  logDebug(msg: any) { super.logInfo(stamp(msg)); }
  logError(msg: any) { super.logError(stamp(msg)); }
}

function stamp(msg: any) { return msg + ' at ' + new Date(); }

</code-example>
<a id="useexisting"></a>
<h4 translation-origin="off" id="useexistingthe-alias-provider"><em>useExisting</em>—the <em>alias provider</em><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#useexistingthe-alias-provider"><i class="material-icons">link</i></a></h4>
<h4 translation-result="" id="emuseexistingemthe-emalias-providerem">useExisting - <em>别名-提供商</em><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#emuseexistingemthe-emalias-providerem"><i class="material-icons">link</i></a></h4>
<p translation-origin="off">The <code>useExisting</code> provider maps one token to another.
In effect, the first token is an <strong><em>alias</em></strong> for the service associated with the second token,
creating <strong><em>two ways to access the same service object</em></strong>.</p>
<p translation-result="">使用 <code>useExisting</code>，提供商可以把一个令牌映射到另一个令牌上。实际上，第一个令牌是第二个令牌所对应的服务的一个<strong><em>别名</em></strong>，创造了<strong><em>访问同一个服务对象的两种方法</em></strong>。</p>
<code-example path="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" region="use-existing" title="dependency-injection-in-action/src/app/hero-of-the-month.component.ts">
{ provide: MinimalLogger, useExisting: LoggerService },

</code-example>
<p translation-origin="off">Narrowing an API through an aliasing interface is <em>one</em> important use case for this technique.
The following example shows aliasing for that purpose.</p>
<p translation-result="">通过使用别名接口来把一个 API 变窄，是<em>一个</em>很重要的该技巧的使用例子。下面的例子中使用别名就是为了这个目的。</p>
<p translation-origin="off">Imagine that the <code>LoggerService</code> had a large API, much larger than the actual three methods and a property.
You might want to shrink that API surface to just the members you actually need.
Here the <code>MinimalLogger</code> <a href="/guide/dependency-injection-in-action#class-interface"><em>class-interface</em></a> reduces the API to two members:</p>
<p translation-result="">想象一下如果 <code>LoggerService</code> 有个很大的 API 接口(虽然它其实只有三个方法，一个属性)，通过使用 <code>MinimalLogger</code><a href="/guide/dependency-injection-in-action#class-interface"><em>类-接口</em></a>别名，就能成功的把这个 API 接口缩小到只暴露两个成员：</p>
<code-example path="dependency-injection-in-action/src/app/minimal-logger.service.ts" title="src/app/minimal-logger.service.ts" linenums="false">
// Class used as <a href="/api/router/RouterLinkWithHref" class="code-anchor">a</a> "narrowing" interface that exposes <a href="/api/router/RouterLinkWithHref" class="code-anchor">a</a> minimal logger
// <a href="/api/common/Plural#Other" class="code-anchor">Other</a> members of the actual implementation are invisible
export abstract class MinimalLogger {
  logs: string[];
  logInfo: (msg: string) => void;
}

</code-example>
<p translation-origin="off">Now put it to use in a simplified version of the <code>HeroOfTheMonthComponent</code>.</p>
<p translation-result="">现在，在一个简化版的 <code>HeroOfTheMonthComponent</code> 中使用它。</p>
<code-example path="dependency-injection-in-action/src/app/hero-of-the-month.component.1.ts" title="src/app/hero-of-the-month.component.ts (minimal version)" linenums="false">
@<a href="/api/core/Component" class="code-anchor">Component</a>({
  selector: 'app-hero-of-the-month',
  templateUrl: './hero-of-the-month.component.html',
  // TODO: move this aliasing, `useExisting` provider to the AppModule
  providers: [{ provide: MinimalLogger, useExisting: LoggerService }]
})
export class HeroOfTheMonthComponent {
  logs: string[] = [];
  constructor(logger: MinimalLogger) {
    logger.logInfo('starting up');
  }
}

</code-example>
<p translation-origin="off">The <code>HeroOfTheMonthComponent</code> constructor's <code>logger</code> parameter is typed as <code>MinimalLogger</code> so only the <code>logs</code> and <code>logInfo</code> members are visible in a TypeScript-aware editor:</p>
<p translation-result=""><code>HeroOfTheMonthComponent</code> 构造函数的 <code>logger</code> 参数是一个 <code>MinimalLogger</code> 类型，支持 TypeScript 的编辑器里，只能看到它的两个成员 <code>logs</code> 和 <code>logInfo</code>：</p>
<figure>
  <img src="generated/images/guide/dependency-injection-in-action/minimal-logger-intellisense.png" alt="MinimalLogger restricted API" width="532" height="60">
</figure>
<p translation-origin="off">Behind the scenes, Angular actually sets the <code>logger</code> parameter to the full service registered under the <code>LoggingService</code> token which happens to be the <code>DateLoggerService</code> that was <a href="/guide/dependency-injection-in-action#useclass">provided above</a>.</p>
<p translation-result="">实际上，Angular 确实想把 <code>logger</code> 参数设置为注入器里 <code>LoggerService</code> 的完整版本。只是在之前的提供商注册里使用了 <code>useClass</code>，
所以该完整版本被 <code>DateLoggerService</code> 取代了。</p>
<div class="alert is-helpful">
<p translation-origin="off">The following image, which displays the logging date, confirms the point:</p>
<p translation-result="">在下面的图片中，显示了日志日期，可以确认这一点：</p>
<figure>
  <img src="generated/images/guide/dependency-injection-in-action/date-logger-entry.png" alt="DateLoggerService entry" width="300" height="32">
</figure>
</div>
<a id="usefactory"></a>
<h4 translation-origin="off" id="usefactorythe-factory-provider"><em>useFactory</em>—the <em>factory provider</em><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#usefactorythe-factory-provider"><i class="material-icons">link</i></a></h4>
<h4 translation-result="" id="emusefactoryemthe-emfactory-providerem">useFactory - <em>工厂-提供商</em><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#emusefactoryemthe-emfactory-providerem"><i class="material-icons">link</i></a></h4>
<p translation-origin="off">The <code>useFactory</code> provider creates a dependency object by calling a factory function
as in this example.</p>
<p translation-result=""><code>useFactory</code> 提供商通过调用工厂函数来新建一个依赖对象，如下例所示。</p>
<code-example path="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" region="use-factory" title="dependency-injection-in-action/src/app/hero-of-the-month.component.ts">
{ provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), <a href="/api/core/ConstructorSansProvider#deps" class="code-anchor">deps</a>: [Hero, HeroService] }

</code-example>
<p translation-origin="off">Use this technique to <strong><em>create a dependency object</em></strong>
with a factory function whose inputs are some <strong><em>combination of injected services and local state</em></strong>.</p>
<p translation-result="">使用这项技术，可以用包含了一些<strong><em>依赖服务和本地状态</em></strong>输入的工厂函数来<strong><em>建立一个依赖对象</em></strong>。</p>
<p translation-origin="off">The <em>dependency object</em> doesn't have to be a class instance. It could be anything.
In this example, the <em>dependency object</em> is a string of the names of the runners-up
to the "Hero of the Month" contest.</p>
<p translation-result="">该<em>依赖对象</em>不一定是一个类实例。它可以是任何东西。在这个例子里，<em>依赖对象</em>是一个字符串，代表了<strong>本月英雄</strong>比赛的亚军的名字。</p>
<p translation-origin="off">The local state is the number <code>2</code>, the number of runners-up this component should show.
It executes <code>runnersUpFactory</code> immediately with <code>2</code>.</p>
<p translation-result="">本地状态是数字 <code>2</code>，该组件应该显示的亚军的个数。它就会立刻用 <code>2</code> 来执行 <code>runnersUpFactory</code>。</p>
<p translation-origin="off">The <code>runnersUpFactory</code> itself isn't the provider factory function.
The true provider factory function is the function that <code>runnersUpFactory</code> returns.</p>
<p translation-result=""><code>runnersUpFactory</code> 自身不是提供商工厂函数。真正的提供商工厂函数是 <code>runnersUpFactory</code> 返回的函数。</p>
<code-example path="dependency-injection-in-action/src/app/runners-up.ts" region="factory-synopsis" title="runners-up.ts (excerpt)" linenums="false">
export function runnersUpFactory(take: number) {
  return (winner: Hero, heroService: HeroService): string => {
    /* ... */
  };
};

</code-example>
<p translation-origin="off">That returned function takes a winning <code>Hero</code> and a <code>HeroService</code> as arguments.</p>
<p translation-result="">这个返回的函数需要一个 <code>Hero</code> 和一个 <code>HeroService</code> 参数。</p>
<p translation-origin="off">Angular supplies these arguments from injected values identified by
the two <em>tokens</em> in the <code><a href="/api/core/ConstructorSansProvider#deps" class="code-anchor">deps</a></code> array.
The two <code><a href="/api/core/ConstructorSansProvider#deps" class="code-anchor">deps</a></code> values are <em>tokens</em> that the injector uses
to provide these factory function dependencies.</p>
<p translation-result="">Angular 通过使用 <code><a href="/api/core/ConstructorSansProvider#deps" class="code-anchor">deps</a></code> 数组中的两个<em>令牌</em>，来识别注入的值，用来提供这些参数。这两个 <code><a href="/api/core/ConstructorSansProvider#deps" class="code-anchor">deps</a></code> 值是供注入器使用的<em>令牌</em>，用来提供工厂函数的依赖。</p>
<p translation-origin="off">After some undisclosed work, the function returns the string of names
and Angular injects it into the <code>runnersUp</code> parameter of the <code>HeroOfTheMonthComponent</code>.</p>
<p translation-result="">一些内部工作后，这个函数返回名字字符串，Angular 将其注入到 <code>HeroOfTheMonthComponent</code> 组件的 <code>runnersUp</code> 参数里。</p>
<div class="alert is-helpful">
<p translation-origin="off">The function retrieves candidate heroes from the <code>HeroService</code>,
takes <code>2</code> of them to be the runners-up, and returns their concatenated names.
Look at the <live-example name="dependency-injection-in-action"></live-example>
for the full source code.</p>
<p translation-result="">该函数从 <code>HeroService</code> 获取英雄参赛者，从中取 <code>2</code> 个作为亚军，并把他们的名字拼接起来。请到<live-example name="dependency-injection-in-action"></live-example>查看全部原代码。</p>
</div>
<a id="tokens"></a>
<h2 translation-origin="off" id="provider-token-alternatives-the-class-interface-and-injectiontoken">Provider token alternatives: the <em>class-interface</em> and <em>InjectionToken</em><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#provider-token-alternatives-the-class-interface-and-injectiontoken"><i class="material-icons">link</i></a></h2>
<h2 translation-result="" id="provider-token-alternatives-the-emclass-interfaceem-and-eminjectiontokenem">备选提供商令牌：<em>类-接口</em>和 <em>InjectionToken</em><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#provider-token-alternatives-the-emclass-interfaceem-and-eminjectiontokenem"><i class="material-icons">link</i></a></h2>
<p translation-origin="off">Angular dependency injection is easiest when the provider <em>token</em> is a class
that is also the type of the returned dependency object, or what you usually call the <em>service</em>.</p>
<p translation-result="">Angular 依赖注入当<em>令牌</em>是类的时候是最简单的，该类同时也是返回的依赖对象的类型(通常直接称之为<em>服务</em>)。</p>
<p translation-origin="off">But the token doesn't have to be a class and even when it is a class,
it doesn't have to be the same type as the returned object.
That's the subject of the next section.</p>
<p translation-result="">但令牌不一定都是类，就算它是一个类，它也不一定都返回类型相同的对象。这是下一节的主题。</p>
<a id="class-interface"></a>
<h3 translation-origin="off" id="class-interface">class-interface<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#class-interface"><i class="material-icons">link</i></a></h3>
<h3 translation-result="" id="class-interface">类-接口<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#class-interface"><i class="material-icons">link</i></a></h3>
<p translation-origin="off">The previous <em>Hero of the Month</em> example used the <code>MinimalLogger</code> class
as the token for a provider of a <code>LoggerService</code>.</p>
<p translation-result="">前面的<em>月度英雄</em>的例子使用了 <code>MinimalLogger</code> 类作为 <code>LoggerService</code> 提供商的令牌。</p>
<code-example path="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" region="use-existing" title="dependency-injection-in-action/src/app/hero-of-the-month.component.ts">
{ provide: MinimalLogger, useExisting: LoggerService },

</code-example>
<p translation-origin="off">The <code>MinimalLogger</code> is an abstract class.</p>
<p translation-result="">该 <code>MinimalLogger</code> 是一个抽象类。</p>
<code-example path="dependency-injection-in-action/src/app/minimal-logger.service.ts" title="dependency-injection-in-action/src/app/minimal-logger.service.ts" linenums="false">
// Class used as <a href="/api/router/RouterLinkWithHref" class="code-anchor">a</a> "narrowing" interface that exposes <a href="/api/router/RouterLinkWithHref" class="code-anchor">a</a> minimal logger
// <a href="/api/common/Plural#Other" class="code-anchor">Other</a> members of the actual implementation are invisible
export abstract class MinimalLogger {
  logs: string[];
  logInfo: (msg: string) => void;
}

</code-example>
<p translation-origin="off">You usually inherit from an abstract class.
But <em>no class</em> in this application inherits from <code>MinimalLogger</code>.</p>
<p translation-result="">你通常从一个抽象类继承。但这个应用中<em>并没有</em>类会继承 <code>MinimalLogger</code>。</p>
<p translation-origin="off">The <code>LoggerService</code> and the <code>DateLoggerService</code> <em>could</em> have inherited from <code>MinimalLogger</code>.
They could have <em>implemented</em> it instead in the manner of an interface.
But they did neither.
The <code>MinimalLogger</code> is used exclusively as a dependency injection token.</p>
<p translation-result=""><code>LoggerService</code> 和 <code>DateLoggerService</code><em>本可以</em>从 <code>MinimalLogger</code> 中继承。
它们也可以实现 <code>MinimalLogger</code>，而不用单独定义接口。
但它们没有。
<code>MinimalLogger</code> 在这里仅仅被用作一个 "依赖注入令牌"。</p>
<p translation-origin="off">When you use a class this way, it's called a <strong><em>class-interface</em></strong>.
The key benefit of a <em>class-interface</em> is that you can get the strong-typing of an interface
and you can <strong><em>use it as a provider token</em></strong> in the way you would a normal class.</p>
<p translation-result="">这种用法的类叫做<em>类-接口</em>。它关键的好处是：提供了接口的强类型，能像正常类一样<strong><em>把它当做提供商令牌使用</em></strong>。</p>
<p translation-origin="off">A <strong><em>class-interface</em></strong> should define <em>only</em> the members that its consumers are allowed to call.
Such a narrowing interface helps decouple the concrete class from its consumers.</p>
<p translation-result=""><strong><em>类-接口</em></strong>应该<em>只</em>定义允许它的消费者调用的成员。窄的接口有助于解耦该类的具体实现和它的消费者。</p>
<div class="alert is-helpful">
<h4 translation-origin="off" id="why-minimallogger-is-a-class-and-not-a-typescript-interface">Why <em>MinimalLogger</em> is a class and not a TypeScript interface<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#why-minimallogger-is-a-class-and-not-a-typescript-interface"><i class="material-icons">link</i></a></h4>
<h4 translation-result="" id="why-emminimalloggerem-is-a-class-and-not-a-typescript-interface">为什么 <em>MinimalLogger</em> 是一个类而不是一个 TypeScript 接口<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#why-emminimalloggerem-is-a-class-and-not-a-typescript-interface"><i class="material-icons">link</i></a></h4>
<p translation-origin="off">You can't use an interface as a provider token because
interfaces are not JavaScript objects.
They exist only in the TypeScript design space.
They disappear after the code is transpiled to JavaScript.</p>
<p translation-result="">不能把接口当做提供商的令牌，因为接口不是有效的 JavaScript 对象。
它们只存在在 TypeScript 的设计空间里。它们会在被编译为 JavaScript 之后消失。</p>
<p translation-origin="off">A provider token must be a real JavaScript object of some kind:
such as a function, an object, a string, or a class.</p>
<p translation-result="">一个提供商令牌必须是一个真实的 JavaScript 对象，比如：一个函数，一个对象，一个字符串，或一个类。</p>
<p translation-origin="off">Using a class as an interface gives you the characteristics of an interface in a real JavaScript object.</p>
<p translation-result="">把类当做接口使用，可以为你在一个 JavaScript 对象上提供类似于接口的特性。</p>
<p translation-origin="off">Of course a real object occupies memory. To minimize memory cost, the class should have <em>no implementation</em>.
The <code>MinimalLogger</code> transpiles to this unoptimized, pre-minified JavaScript for a constructor function:</p>
<p translation-result="">当然，一个真实的类会占用内存。为了节省内存占用，该类应该<strong><em>没有具体的实现</em></strong>。<code>MinimalLogger</code> 会被转译成下面这段没有优化过的，尚未最小化的 JavaScript：</p>
<code-example path="dependency-injection-in-action/src/app/minimal-logger.service.ts" region="minimal-logger-transpiled" title="dependency-injection-in-action/src/app/minimal-logger.service.ts" linenums="false">
var MinimalLogger = (function () {
  function MinimalLogger() {}
  return MinimalLogger;
}());
<a href="/api/core/NgModule#exports" class="code-anchor">exports</a>("MinimalLogger", MinimalLogger);

</code-example>
<p translation-origin="off">Notice that it doesn't have a single member. It never grows no matter how many members you add to the class <em>as long as those members are typed but not implemented</em>. Look again at the TypeScript <code>MinimalLogger</code> class to confirm that it has no implementation.</p>
<p translation-result="">注意，<strong><em>只要不实现它</em></strong>，不管添加多少成员，它永远不会增长大小。</p>
</div>
<a id="injection-token"></a>
<h3 translation-origin="off" id="injectiontoken"><em>InjectionToken</em><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#injectiontoken"><i class="material-icons">link</i></a></h3>
<h3 translation-result="" id="eminjectiontokenem"><em>InjectionToken</em> 值<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#eminjectiontokenem"><i class="material-icons">link</i></a></h3>
<p translation-origin="off">Dependency objects can be simple values like dates, numbers and strings, or
shapeless objects like arrays and functions.</p>
<p translation-result="">依赖对象可以是一个简单的值，比如日期，数字和字符串，或者一个无形的对象，比如数组和函数。</p>
<p translation-origin="off">Such objects don't have application interfaces and therefore aren't well represented by a class.
They're better represented by a token that is both unique and symbolic,
a JavaScript object that has a friendly name but won't conflict with
another token that happens to have the same name.</p>
<p translation-result="">这样的对象没有应用程序接口，所以不能用一个类来表示。更适合表示它们的是：唯一的和符号性的令牌，一个 JavaScript 对象，拥有一个友好的名字，但不会与其它的同名令牌发生冲突。</p>
<p translation-origin="off">The <code><a href="/api/core/InjectionToken" class="code-anchor">InjectionToken</a></code> has these characteristics.
You encountered them twice in the <em>Hero of the Month</em> example,
in the <em>title</em> value provider and in the <em>runnersUp</em> factory provider.</p>
<p translation-result=""><code><a href="/api/core/InjectionToken" class="code-anchor">InjectionToken</a></code> 具有这些特征。在<em>Hero of the Month</em>例子中遇见它们两次，一个是 <em>title</em> 的值，一个是 <em>runnersUp</em> 工厂提供商。</p>
<code-example path="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" region="provide-injection-token" title="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" linenums="false">
{ provide: TITLE,         useValue:   'Hero of the Month' },
{ provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), <a href="/api/core/ConstructorSansProvider#deps" class="code-anchor">deps</a>: [Hero, HeroService] }

</code-example>
<p translation-origin="off">You created the <code>TITLE</code> token like this:</p>
<p translation-result="">这样创建 <code>TITLE</code> 令牌：</p>
<code-example path="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" region="injection-token" title="dependency-injection-in-action/src/app/hero-of-the-month.component.ts" linenums="false">
import { <a href="/api/core/InjectionToken" class="code-anchor">InjectionToken</a> } from '@angular/core';

export const TITLE = new <a href="/api/core/InjectionToken" class="code-anchor">InjectionToken</a>&#x3C;string>('title');

</code-example>
<p translation-origin="off">The type parameter, while optional, conveys the dependency's type to developers and tooling.
The token description is another developer aid.</p>
<p translation-result="">类型参数，虽然是可选的，但可以向开发者和开发工具传达类型信息。
而且这个令牌的描述信息也可以为开发者提供帮助。</p>
<a id="di-inheritance"></a>
<h2 translation-origin="off" id="inject-into-a-derived-class">Inject into a derived class<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#inject-into-a-derived-class"><i class="material-icons">link</i></a></h2>
<h2 translation-result="" id="inject-into-a-derived-class">注入到派生类<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#inject-into-a-derived-class"><i class="material-icons">link</i></a></h2>
<p translation-origin="off">Take care when writing a component that inherits from another component.
If the base component has injected dependencies,
you must re-provide and re-inject them in the derived class
and then pass them down to the base class through the constructor.</p>
<p translation-result="">当编写一个继承自另一个组件的组件时，要格外小心。如果基础组件有依赖注入，必须要在派生类中重新提供和重新注入它们，并将它们通过构造函数传给基类。</p>
<p translation-origin="off">In this contrived example, <code>SortedHeroesComponent</code> inherits from <code>HeroesBaseComponent</code>
to display a <em>sorted</em> list of heroes.</p>
<p translation-result="">在这个刻意生成的例子里，<code>SortedHeroesComponent</code> 继承自 <code>HeroesBaseComponent</code>，显示一个<em>被排序</em>的英雄列表。</p>
<figure>
  <img src="generated/images/guide/dependency-injection-in-action/sorted-heroes.png" alt="Sorted Heroes" width="135" height="107">
</figure>
<p translation-origin="off">The <code>HeroesBaseComponent</code> could stand on its own.
It demands its own instance of the <code>HeroService</code> to get heroes
and displays them in the order they arrive from the database.</p>
<p translation-result=""><code>HeroesBaseComponent</code> 能自己独立运行。它在自己的实例里要求 <code>HeroService</code>，用来得到英雄，并将他们按照数据库返回的顺序显示出来。</p>
<code-example path="dependency-injection-in-action/src/app/sorted-heroes.component.ts" region="heroes-base" title="src/app/sorted-heroes.component.ts (HeroesBaseComponent)">
@<a href="/api/core/Component" class="code-anchor">Component</a>({
  selector: 'app-unsorted-heroes',
  <a href="/api/core/Component#template" class="code-anchor">template</a>: `&#x3C;div *<a href="/api/common/NgForOf" class="code-anchor">ngFor</a>="let hero of heroes">{{hero.name}}&#x3C;/div>`,
  providers: [HeroService]
})
export class HeroesBaseComponent implements <a href="/api/core/OnInit" class="code-anchor">OnInit</a> {
  constructor(private heroService: HeroService) { }

  heroes: Array&#x3C;Hero>;

  ngOnInit() {
    this.heroes = this.heroService.getAllHeroes();
    this.afterGetHeroes();
  }

  // Post-process heroes in derived class override.
  protected afterGetHeroes() {}

}

</code-example>
<div class="alert is-helpful">
<p translation-origin="off"><strong><em>Keep constructors simple.</em></strong> They should do little more than initialize variables.
This rule makes the component safe to construct under test without fear that it will do something dramatic like talk to the server.
That's why you call the <code>HeroService</code> from within the <code>ngOnInit</code> rather than the constructor.</p>
<p translation-result=""><strong><em>让构造函数保持简单。</em></strong>它们只应该用来初始化变量。
这条规则用于在测试环境中放心的构造组件，以免在构造它们时，无意做了一些非常戏剧化的动作(比如与服务器进行会话)。
这就是为什么你要在 <code>ngOnInit</code> 里面调用 <code>HeroService</code>，而不是在构造函数中。</p>
</div>
<p translation-origin="off">Users want to see the heroes in alphabetical order.
Rather than modify the original component, sub-class it and create a
<code>SortedHeroesComponent</code> that sorts the heroes before presenting them.
The <code>SortedHeroesComponent</code> lets the base class fetch the heroes.</p>
<p translation-result="">用户希望看到英雄按字母顺序排序。与其修改原始的组件，不如派生它，新建 <code>SortedHeroesComponent</code>，以便展示英雄之前进行排序。
<code>SortedHeroesComponent</code> 让基类来获取英雄。</p>
<p translation-origin="off">Unfortunately, Angular cannot inject the <code>HeroService</code> directly into the base class.
You must provide the <code>HeroService</code> again for <em>this</em> component,
then pass it down to the base class inside the constructor.</p>
<p translation-result="">可惜，Angular 不能直接在基类里直接注入 <code>HeroService</code>。必须在<em>这个</em>组件里再次提供 <code>HeroService</code>，然后通过构造函数传给基类。</p>
<code-example path="dependency-injection-in-action/src/app/sorted-heroes.component.ts" region="sorted-heroes" title="src/app/sorted-heroes.component.ts (SortedHeroesComponent)">
@<a href="/api/core/Component" class="code-anchor">Component</a>({
  selector: 'app-sorted-heroes',
  <a href="/api/core/Component#template" class="code-anchor">template</a>: `&#x3C;div *<a href="/api/common/NgForOf" class="code-anchor">ngFor</a>="let hero of heroes">{{hero.name}}&#x3C;/div>`,
  providers: [HeroService]
})
export class SortedHeroesComponent extends HeroesBaseComponent {
  constructor(heroService: HeroService) {
    super(heroService);
  }

  protected afterGetHeroes() {
    this.heroes = this.heroes.sort((h1, h2) => {
      return h1.name &#x3C; h2.name ? -1 :
            (h1.name > h2.name ? 1 : 0);
    });
  }
}

</code-example>
<p translation-origin="off">Now take note of the <code>afterGetHeroes()</code> method.
Your first instinct might have been to create an <code>ngOnInit</code> method in <code>SortedHeroesComponent</code> and do the sorting there.
But Angular calls the <em>derived</em> class's <code>ngOnInit</code> <em>before</em> calling the base class's <code>ngOnInit</code>
so you'd be sorting the heroes array <em>before they arrived</em>. That produces a nasty error.</p>
<p translation-result="">现在，请注意 <code>afterGetHeroes()</code> 方法。
你的第一反应是在 <code>SortedHeroesComponent</code> 组件里面建一个 <code>ngOnInit</code> 方法来做排序。但是 Angular 会先调用<em>派生</em>类的 <code>ngOnInit</code>，后调用基类的 <code>ngOnInit</code>，
所以可能在<em>英雄到达之前</em>就开始排序。这就产生了一个讨厌的错误。</p>
<p translation-origin="off">Overriding the base class's <code>afterGetHeroes()</code> method solves the problem.</p>
<p translation-result="">覆盖基类的 <code>afterGetHeroes()</code> 方法可以解决这个问题。</p>
<p translation-origin="off">These complications argue for <em>avoiding component inheritance</em>.</p>
<p translation-result="">分析上面的这些复杂性是为了强调<em>避免使用组件继承</em>这一点。</p>
<a id="find-parent"></a>
<h2 translation-origin="off" id="find-a-parent-component-by-injection">Find a parent component by injection<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#find-a-parent-component-by-injection"><i class="material-icons">link</i></a></h2>
<h2 translation-result="" id="find-a-parent-component-by-injection">通过注入来找到一个父组件<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#find-a-parent-component-by-injection"><i class="material-icons">link</i></a></h2>
<p translation-origin="off">Application components often need to share information.
More loosely coupled techniques such as data binding and service sharing
are preferable. But sometimes it makes sense for one component
to have a direct reference to another component
perhaps to access values or call methods on that component.</p>
<p translation-result="">应用程序组件经常需要共享信息。使用松耦合的技术会更好一点，比如数据绑定和服务共享。
但有时候组件确实需要拥有另一个组件的引用，用来访问该组件的属性值或者调用它的方法。</p>
<p translation-origin="off">Obtaining a component reference is a bit tricky in Angular.
Although an Angular application is a tree of components,
there is no public API for inspecting and traversing that tree.</p>
<p translation-result="">在 Angular 里，获取一个组件的引用比较复杂。虽然 Angular 应用程序是一个组件树，但它没有公共 API 来在该树中巡查和穿梭。</p>
<p translation-origin="off">There is an API for acquiring a child reference.
Check out <code><a href="/api/core/Query" class="code-anchor">Query</a></code>, <code><a href="/api/core/QueryList" class="code-anchor">QueryList</a></code>, <code><a href="/api/core/ViewChildren" class="code-anchor">ViewChildren</a></code>, and <code><a href="/api/core/ContentChildren" class="code-anchor">ContentChildren</a></code>
in the <a href="/api/">API Reference</a>.</p>
<p translation-result="">有一个 API 可以获取子级的引用(请看<a href="/api/">API 参考手册</a>中的 <code><a href="/api/core/Query" class="code-anchor">Query</a></code>, <code><a href="/api/core/QueryList" class="code-anchor">QueryList</a></code>, <code><a href="/api/core/ViewChildren" class="code-anchor">ViewChildren</a></code>,和 <code><a href="/api/core/ContentChildren" class="code-anchor">ContentChildren</a></code>)。</p>
<p translation-origin="off">There is no public API for acquiring a parent reference.
But because every component instance is added to an injector's container,
you can use Angular dependency injection to reach a parent component.</p>
<p translation-result="">但没有公共 API 来获取父组件的引用。但是因为每个组件的实例都被加到了依赖注入器的容器中，可以使用 Angular 依赖注入来找到父组件。</p>
<p translation-origin="off">This section describes some techniques for doing that.</p>
<p translation-result="">本章节描述了这项技术。</p>
<a id="known-parent"></a>
<h3 translation-origin="off" id="find-a-parent-component-of-known-type">Find a parent component of known type<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#find-a-parent-component-of-known-type"><i class="material-icons">link</i></a></h3>
<h3 translation-result="" id="find-a-parent-component-of-known-type">找到已知类型的父组件<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#find-a-parent-component-of-known-type"><i class="material-icons">link</i></a></h3>
<p translation-origin="off">You use standard class injection to acquire a parent component whose type you know.</p>
<p translation-result="">你使用标准的类注入来获取已知类型的父组件。</p>
<p translation-origin="off">In the following example, the parent <code>AlexComponent</code> has several children including a <code>CathyComponent</code>:</p>
<p translation-result="">在下面的例子中，父组件 <code>AlexComponent</code> 有几个子组件，包括 <code>CathyComponent</code>:</p>
<a id="alex"></a>
<code-example path="dependency-injection-in-action/src/app/parent-finder.component.ts" region="alex-1" title="parent-finder.component.ts (AlexComponent v.1)" linenums="false">
@<a href="/api/core/Component" class="code-anchor">Component</a>({
  selector: 'alex',
  <a href="/api/core/Component#template" class="code-anchor">template</a>: `
    &#x3C;div class="<a href="/api/router/RouterLinkWithHref" class="code-anchor">a</a>">
      &#x3C;h3>{{name}}&#x3C;/h3>
      &#x3C;cathy>&#x3C;/cathy>
      &#x3C;craig>&#x3C;/craig>
      &#x3C;carol>&#x3C;/carol>
    &#x3C;/div>`,
})
export class AlexComponent extends Base
{
  name = 'Alex';
}

</code-example>
<p translation-origin="off"><em>Cathy</em> reports whether or not she has access to <em>Alex</em>
after injecting an <code>AlexComponent</code> into her constructor:</p>
<p translation-result="">在注入<em>AlexComponent` 进来后，</em>Cathy<em> 报告它是否对 </em>Alex* 有访问权：</p>
<code-example path="dependency-injection-in-action/src/app/parent-finder.component.ts" region="cathy" title="parent-finder.component.ts (CathyComponent)" linenums="false">
@<a href="/api/core/Component" class="code-anchor">Component</a>({
  selector: 'cathy',
  <a href="/api/core/Component#template" class="code-anchor">template</a>: `
  &#x3C;div class="c">
    &#x3C;h3>Cathy&#x3C;/h3>
    {{alex ? 'Found' : 'Did not find'}} Alex via the component class.&#x3C;br>
  &#x3C;/div>`
})
export class CathyComponent {
  constructor( @<a href="/api/core/Optional" class="code-anchor">Optional</a>() public alex: AlexComponent ) { }
}

</code-example>
<p translation-origin="off">Notice that even though the <a href="/guide/dependency-injection-in-action#optional">@Optional</a> qualifier
is there for safety,
the <live-example name="dependency-injection-in-action"></live-example>
confirms that the <code>alex</code> parameter is set.</p>
<p translation-result="">注意，这里为安全起见而添加了<a href="/guide/dependency-injection-in-action#optional">@Optional</a>装饰器，<live-example name="dependency-injection-in-action"></live-example>显示 <code>alex</code> 参数确实被设置了。</p>
<a id="base-parent"></a>
<h3 translation-origin="off" id="cannot-find-a-parent-by-its-base-class">Cannot find a parent by its base class<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#cannot-find-a-parent-by-its-base-class"><i class="material-icons">link</i></a></h3>
<h3 translation-result="" id="cannot-find-a-parent-by-its-base-class">无法通过它的基类找到一个父级<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#cannot-find-a-parent-by-its-base-class"><i class="material-icons">link</i></a></h3>
<p translation-origin="off">What if you <em>don't</em> know the concrete parent component class?</p>
<p translation-result="">如果<em>不</em>知道具体的父组件类名怎么办？</p>
<p translation-origin="off">A re-usable component might be a child of multiple components.
Imagine a component for rendering breaking news about a financial instrument.
For business reasons, this news component makes frequent calls
directly into its parent instrument as changing market data streams by.</p>
<p translation-result="">一个可复用的组件可能是多个组件的子级。想象一个用来渲染金融工具头条新闻的组件。由于商业原因，该新闻组件在实时变化的市场数据流过时，要频繁的直接调用其父级工具。</p>
<p translation-origin="off">The app probably defines more than a dozen financial instrument components.
If you're lucky, they all implement the same base class
whose API your <code>NewsComponent</code> understands.</p>
<p translation-result="">该应用程序可能有多于一打的金融工具组件。如果幸运，它们可能会从同一个基类派生，其 API 是 <code>NewsComponent</code> 组件所能理解的。</p>
<div class="alert is-helpful">
<p translation-origin="off">Looking for components that implement an interface would be better.
That's not possible because TypeScript interfaces disappear
from the transpiled JavaScript, which doesn't support interfaces.
There's no artifact to look for.</p>
<p translation-result="">更好的方式是通过接口来寻找实现了它的组件。但这是不可能的，因为 TypeScript 的接口在编译成 JavaScript 以后就消失了，JavaScript 不支持接口。没有东西可查。</p>
</div>
<p translation-origin="off">This isn't necessarily good design.
This example is examining <em>whether a component can
inject its parent via the parent's base class</em>.</p>
<p translation-result="">这并不是好的设计。问题是<em>一个组件是否能通过它父组件的基类来注入它的父组件呢</em>？</p>
<p translation-origin="off">The sample's <code>CraigComponent</code> explores this question. <a href="/guide/dependency-injection-in-action#alex">Looking back</a>,
you see that the <code>Alex</code> component <em>extends</em> (<em>inherits</em>) from a class named <code>Base</code>.</p>
<p translation-result=""><code>CraigComponent</code> 例子探究了这个问题。[往回看 Alex]{guide/dependency-injection-in-action#alex}，你看到 <code>Alex</code> 组件<em>扩展</em>(<em>派生</em>)自一个叫 <code>Base</code> 的类。</p>
<code-example path="dependency-injection-in-action/src/app/parent-finder.component.ts" region="alex-class-signature" title="parent-finder.component.ts (Alex class signature)" linenums="false">
export class AlexComponent extends Base

</code-example>
<p translation-origin="off">The <code>CraigComponent</code> tries to inject <code>Base</code> into its <code>alex</code> constructor parameter and reports if it succeeded.</p>
<p translation-result=""><code>CraigComponent</code> 试图把 <code>Base</code> 注入到到它的 <code>alex</code> 构造函数参数，来报告是否成功。</p>
<code-example path="dependency-injection-in-action/src/app/parent-finder.component.ts" region="craig" title="parent-finder.component.ts (CraigComponent)" linenums="false">
@<a href="/api/core/Component" class="code-anchor">Component</a>({
  selector: 'craig',
  <a href="/api/core/Component#template" class="code-anchor">template</a>: `
  &#x3C;div class="c">
    &#x3C;h3>Craig&#x3C;/h3>
    {{alex ? 'Found' : 'Did not find'}} Alex via the base class.
  &#x3C;/div>`
})
export class CraigComponent {
  constructor( @<a href="/api/core/Optional" class="code-anchor">Optional</a>() public alex: Base ) { }
}

</code-example>
<p translation-origin="off">Unfortunately, this does not work.
The <live-example name="dependency-injection-in-action"></live-example>
confirms that the <code>alex</code> parameter is null.
<em>You cannot inject a parent by its base class.</em></p>
<p translation-result="">可惜这样不行。<live-example name="dependency-injection-in-action"></live-example>显示 <code>alex</code> 参数是 null。
<em>不能通过基类注入父组件</em>。</p>
<a id="class-interface-parent"></a>
<h3 translation-origin="off" id="find-a-parent-by-its-class-interface">Find a parent by its class-interface<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#find-a-parent-by-its-class-interface"><i class="material-icons">link</i></a></h3>
<h3 translation-result="" id="find-a-parent-by-its-class-interface">通过类-接口找到父组件<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#find-a-parent-by-its-class-interface"><i class="material-icons">link</i></a></h3>
<p translation-origin="off">You can find a parent component with a <a href="/guide/dependency-injection-in-action#class-interface">class-interface</a>.</p>
<p translation-result="">可以通过<a href="/guide/dependency-injection-in-action#class-interface">类-接口</a>找到一个父组件。</p>
<p translation-origin="off">The parent must cooperate by providing an <em>alias</em> to itself in the name of a <em>class-interface</em> token.</p>
<p translation-result="">该父组件必须通过提供一个与<em>类-接口</em>令牌同名的<em>别名</em>来与之合作。</p>
<p translation-origin="off">Recall that Angular always adds a component instance to its own injector;
that's why you could inject <em>Alex</em> into <em>Cathy</em> <a href="/guide/dependency-injection-in-action#known-parent">earlier</a>.</p>
<p translation-result="">请记住 Angular 总是从它自己的注入器添加一个组件实例；这就是为什么在<a href="/guide/dependency-injection-in-action#known-parent">之前</a>可以 <em>Alex</em> 注入到 <em>Carol</em>。</p>
<p translation-origin="off">Write an <a href="/guide/dependency-injection-in-action#useexisting"><em>alias provider</em></a>—a <code>provide</code> object literal with a <code>useExisting</code>
definition—that creates an <em>alternative</em> way to inject the same component instance
and add that provider to the <code>providers</code> array of the <code>@<a href="/api/core/Component" class="code-anchor">Component</a></code> metadata for the <code>AlexComponent</code>:</p>
<p translation-result="">编写一个<a href="/guide/dependency-injection-in-action#useexisting"><em>别名提供商</em></a> &#x26;mdash；一个拥有 <code>useExisting</code> 定义的 <code>provide</code> 函数 —
它新建一个<em>备选的</em>方式来注入同一个组件实例，并把这个提供商添加到 <code>AlexComponent</code> 的 <code>@<a href="/api/core/Component" class="code-anchor">Component</a></code> 元数据里的 <code>providers</code> 数组。</p>
<a id="alex-providers"></a>
<code-example path="dependency-injection-in-action/src/app/parent-finder.component.ts" region="alex-providers" title="parent-finder.component.ts (AlexComponent providers)" linenums="false">
providers: [{ provide: Parent, useExisting: <a href="/api/core/forwardRef" class="code-anchor">forwardRef</a>(() => AlexComponent) }],

</code-example>
<p translation-origin="off"><a href="/guide/dependency-injection-in-action#parent-token">Parent</a> is the provider's <em>class-interface</em> token.
The <a href="/guide/dependency-injection-in-action#forwardref"><em>forwardRef</em></a> breaks the circular reference you just created by having the <code>AlexComponent</code> refer to itself.</p>
<p translation-result=""><a href="/guide/dependency-injection-in-action#parent-token">Parent</a>是该提供商的<em>类-接口</em>令牌。<code>AlexComponent</code> 引用了自身，造成循环引用，使用<a href="/guide/dependency-injection-in-action#forwardref"><em>forwardRef</em></a>打破了该循环。</p>
<p translation-origin="off"><em>Carol</em>, the third of <em>Alex</em>'s child components, injects the parent into its <code>parent</code> parameter,
the same way you've done it before:</p>
<p translation-result=""><em>Carol</em>，<em>Alex</em> 的第三个子组件，把父级注入到了自己的 <code>parent</code> 参数，和之前做的一样：</p>
<code-example path="dependency-injection-in-action/src/app/parent-finder.component.ts" region="carol-class" title="parent-finder.component.ts (CarolComponent class)" linenums="false">
export class CarolComponent {
  name = 'Carol';
  constructor( @<a href="/api/core/Optional" class="code-anchor">Optional</a>() public parent: Parent ) { }
}

</code-example>
<p translation-origin="off">Here's <em>Alex</em> and family in action:</p>
<p translation-result="">下面是 <em>Alex</em> 和其家庭的运行结果：</p>
<figure>
  <img src="generated/images/guide/dependency-injection-in-action/alex.png" alt="Alex in action" width="302" height="374">
</figure>
<a id="parent-tree"></a>
<h3 translation-origin="off" id="find-the-parent-in-a-tree-of-parents-with-skipself">Find the parent in a tree of parents with <em>@SkipSelf()</em><a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#find-the-parent-in-a-tree-of-parents-with-skipself"><i class="material-icons">link</i></a></h3>
<h3 translation-result="" id="find-the-parent-in-a-tree-of-parents-with-emskipselfem">通过父级树找到父组件<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#find-the-parent-in-a-tree-of-parents-with-emskipselfem"><i class="material-icons">link</i></a></h3>
<p translation-origin="off">Imagine one branch of a component hierarchy: <em>Alice</em> -> <em>Barry</em> -> <em>Carol</em>.
Both <em>Alice</em> and <em>Barry</em> implement the <code>Parent</code> <em>class-interface</em>.</p>
<p translation-result="">想象组件树中的一个分支为：<em>Alice</em> -> <em>Barry</em> -> <em>Carol</em>。<em>Alice</em> 和 <em>Barry</em> 都实现了这个 <code>Parent</code><em>类-接口</em>。</p>
<p translation-origin="off"><em>Barry</em> is the problem. He needs to reach his parent, <em>Alice</em>, and also be a parent to <em>Carol</em>.
That means he must both <em>inject</em> the <code>Parent</code> <em>class-interface</em> to get <em>Alice</em> and
<em>provide</em> a <code>Parent</code> to satisfy <em>Carol</em>.</p>
<p translation-result=""><em>Barry</em> 是个问题。它需要访问它的父组件 <em>Alice</em>，但同时它也是 <em>Carol</em> 的父组件。这个意味着它必须同时<em>注入</em><code>Parent</code><em>类-接口</em>来获取 <em>Alice</em>，和<em>提供</em>一个 <code>Parent</code> 来满足 <em>Carol</em>。</p>
<p translation-origin="off">Here's <em>Barry</em>:</p>
<p translation-result="">下面是 <em>Barry</em> 的代码：</p>
<code-example path="dependency-injection-in-action/src/app/parent-finder.component.ts" region="barry" title="parent-finder.component.ts (BarryComponent)" linenums="false">
const templateB = `
  &#x3C;div class="b">
    &#x3C;div>
      &#x3C;h3>{{name}}&#x3C;/h3>
      &#x3C;p>My parent is {{parent?.name}}&#x3C;/p>
    &#x3C;/div>
    &#x3C;carol>&#x3C;/carol>
    &#x3C;chris>&#x3C;/chris>
  &#x3C;/div>`;

@<a href="/api/core/Component" class="code-anchor">Component</a>({
  selector:   'barry',
  <a href="/api/core/Component#template" class="code-anchor">template</a>:   templateB,
  providers:  [{ provide: Parent, useExisting: <a href="/api/core/forwardRef" class="code-anchor">forwardRef</a>(() => BarryComponent) }]
})
export class BarryComponent implements Parent {
  name = 'Barry';
  constructor( @<a href="/api/core/SkipSelf" class="code-anchor">SkipSelf</a>() @<a href="/api/core/Optional" class="code-anchor">Optional</a>() public parent: Parent ) { }
}

</code-example>
<p translation-origin="off"><em>Barry</em>'s <code>providers</code> array looks just like <a href="/guide/dependency-injection-in-action#alex-providers"><em>Alex</em>'s</a>.
If you're going to keep writing <a href="/guide/dependency-injection-in-action#useexisting"><em>alias providers</em></a> like this you should create a <a href="/guide/dependency-injection-in-action#provideparent">helper function</a>.</p>
<p translation-result=""><em>Barry</em> 的 <code>providers</code> 数组看起来很像<a href="/guide/dependency-injection-in-action#alex-providers"><em>Alex</em> 的那个</a>.
如果准备一直像这样编写<a href="/guide/dependency-injection-in-action#useexisting"><em>别名提供商</em></a>的话，你应该建立一个<a href="/guide/dependency-injection-in-action#provideparent">辅助函数</a>。</p>
<p translation-origin="off">For now, focus on <em>Barry</em>'s constructor:</p>
<p translation-result="">眼下，请注意 <em>Barry</em> 的构造函数：</p>
<code-tabs>

  <code-pane title="Barry&#x27;s constructor" path="dependency-injection-in-action/src/app/parent-finder.component.ts" region="barry-ctor">
constructor( @<a href="/api/core/SkipSelf" class="code-anchor">SkipSelf</a>() @<a href="/api/core/Optional" class="code-anchor">Optional</a>() public parent: Parent ) { }

</code-pane>

  <code-pane title="Carol&#x27;s constructor" path="dependency-injection-in-action/src/app/parent-finder.component.ts" region="carol-ctor">
constructor( @<a href="/api/core/Optional" class="code-anchor">Optional</a>() public parent: Parent ) { }

</code-pane>

</code-tabs>
<p translation-origin="off">It's identical to <em>Carol</em>'s constructor except for the additional <code>@<a href="/api/core/SkipSelf" class="code-anchor">SkipSelf</a></code> decorator.</p>
<p translation-result="">除额外添加了一个的 <code>@<a href="/api/core/SkipSelf" class="code-anchor">SkipSelf</a></code> 外，它和 <em>Carol</em> 的构造函数一样。</p>
<p translation-origin="off"><code>@<a href="/api/core/SkipSelf" class="code-anchor">SkipSelf</a></code> is essential for two reasons:</p>
<p translation-result="">添加 <code>@<a href="/api/core/SkipSelf" class="code-anchor">SkipSelf</a></code> 主要是出于两个原因：</p>
<ol>
<li>
<p translation-origin="off">It tells the injector to start its search for a <code>Parent</code> dependency in a component <em>above</em> itself,
which <em>is</em> what parent means.</p>
<p translation-result="">   它告诉注入器从一个在自己<em>上一级</em>的组件开始搜索一个 <code>Parent</code> 依赖。</p>
</li>
<li>
<p translation-origin="off">Angular throws a cyclic dependency error if you omit the <code>@<a href="/api/core/SkipSelf" class="code-anchor">SkipSelf</a></code> decorator.</p>
<p translation-result=""> 如果没写 <code>@<a href="/api/core/SkipSelf" class="code-anchor">SkipSelf</a></code> 装饰器的话，Angular 就会抛出一个循环依赖错误。</p>
<p translation-origin="off"><code>Cannot instantiate cyclic dependency! (BethComponent -> Parent -> BethComponent)</code></p>
<p translation-result=""><code>不能创建循环依赖实例！(BethComponent -> Parent -> BethComponent)</code></p>
</li>
</ol>
<p translation-origin="off">Here's <em>Alice</em>, <em>Barry</em> and family in action:</p>
<p translation-result="">这里是 <em>Alice</em>，<em>Barry</em> 和该家庭的操作演示：</p>
<figure>
  <img src="generated/images/guide/dependency-injection-in-action/alice.png" alt="Alice in action" width="298" height="631">
</figure>
<a id="parent-token"></a>
<h3 translation-origin="off" id="the-parent-class-interface">The <em>Parent</em> class-interface<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#the-parent-class-interface"><i class="material-icons">link</i></a></h3>
<h3 translation-result="" id="the-emparentem-class-interface"><em>Parent</em> 类-接口<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#the-emparentem-class-interface"><i class="material-icons">link</i></a></h3>
<p translation-origin="off">You <a href="/guide/dependency-injection-in-action#class-interface">learned earlier</a> that a <em>class-interface</em> is an abstract class used as an interface rather than as a base class.</p>
<p translation-result="">你<a href="/guide/dependency-injection-in-action#class-interface">以前学过</a>：<em>类-接口</em>是一个抽象类，被当成一个接口使用，而非基类。</p>
<p translation-origin="off">The example defines a <code>Parent</code> <em>class-interface</em>.</p>
<p translation-result="">这个例子定义了一个 <code>Parent</code><em>类-接口</em>。</p>
<code-example path="dependency-injection-in-action/src/app/parent-finder.component.ts" region="parent" title="parent-finder.component.ts (Parent class-interface)" linenums="false">
export abstract class Parent { name: string; }

</code-example>
<p translation-origin="off">The <code>Parent</code> <em>class-interface</em> defines a <code>name</code> property with a type declaration but <em>no implementation</em>.
The <code>name</code> property is the only member of a parent component that a child component can call.
Such a narrow interface helps decouple the child component class from its parent components.</p>
<p translation-result="">该 <code>Parent</code><em>类-接口</em>定义了 <code>Name</code> 属性，它有类型声明，但是<em>没有实现</em>，该 <code>name</code> 是该父级的所有子组件们唯一能调用的属性。
这种“窄接口”有助于解耦子组件类和它的父组件。</p>
<p translation-origin="off">A component that could serve as a parent <em>should</em> implement the <em>class-interface</em> as the <code>AliceComponent</code> does:</p>
<p translation-result="">一个能用做父级的组件<em>应该</em>实现<em>类-接口</em>，和下面的 <code>AliceComponent</code> 的做法一样：</p>
<code-example path="dependency-injection-in-action/src/app/parent-finder.component.ts" region="alice-class-signature" title="parent-finder.component.ts (AliceComponent class signature)" linenums="false">
export class AliceComponent implements Parent

</code-example>
<p translation-origin="off">Doing so adds clarity to the code.  But it's not technically necessary.
Although the <code>AlexComponent</code> has a <code>name</code> property, as required by its <code>Base</code> class,
its class signature doesn't mention <code>Parent</code>:</p>
<p translation-result="">这样做可以提升代码的清晰度，但严格来说并不是必须的。虽然 <code>AlexComponent</code> 有一个 <code>name</code> 属性(来自 <code>Base</code> 类的要求)，但它的类签名并不需要提及 <code>Parent</code>。</p>
<code-example path="dependency-injection-in-action/src/app/parent-finder.component.ts" region="alex-class-signature" title="parent-finder.component.ts (AlexComponent class signature)" linenums="false">
export class AlexComponent extends Base

</code-example>
<div class="alert is-helpful">
<p translation-origin="off">The <code>AlexComponent</code> <em>should</em> implement <code>Parent</code> as a matter of proper style.
It doesn't in this example <em>only</em> to demonstrate that the code will compile and run without the interface</p>
<p translation-result="">为了正确的代码风格，该 <code>AlexComponent</code><em>应该</em>实现 <code>Parent</code>。在这个例子里它没有这样，只是为了演示在没有该接口的情况下，该代码仍会被正确编译并运行。</p>
</div>
<a id="provideparent"></a>
<h3 translation-origin="off" id="a-provideparent-helper-function">A <em>provideParent()</em> helper function<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#a-provideparent-helper-function"><i class="material-icons">link</i></a></h3>
<h3 translation-result="" id="a-emprovideparentem-helper-function"><em>provideParent()</em>助手函数<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#a-emprovideparentem-helper-function"><i class="material-icons">link</i></a></h3>
<p translation-origin="off">Writing variations of the same parent <em>alias provider</em> gets old quickly,
especially this awful mouthful with a <a href="/guide/dependency-injection-in-action#forwardref"><em>forwardRef</em></a>:</p>
<p translation-result="">编写父组件相同的各种<em>别名提供商</em>很快就会变得啰嗦，在用<a href="/guide/dependency-injection-in-action#forwardref"><em>forwardRef</em></a>的时候尤其绕口：</p>
<code-example path="dependency-injection-in-action/src/app/parent-finder.component.ts" region="alex-providers" title="dependency-injection-in-action/src/app/parent-finder.component.ts" linenums="false">
providers: [{ provide: Parent, useExisting: <a href="/api/core/forwardRef" class="code-anchor">forwardRef</a>(() => AlexComponent) }],

</code-example>
<p translation-origin="off">You can extract that logic into a helper function like this:</p>
<p translation-result="">可以像这样把该逻辑抽取到一个助手函数里：</p>
<code-example path="dependency-injection-in-action/src/app/parent-finder.component.ts" region="provide-the-parent" title="dependency-injection-in-action/src/app/parent-finder.component.ts" linenums="false">
// Helper method to provide the current component instance in the name of <a href="/api/router/RouterLinkWithHref" class="code-anchor">a</a> `parentType`.
const provideParent =
  (component: any) => {
    return { provide: Parent, useExisting: <a href="/api/core/forwardRef" class="code-anchor">forwardRef</a>(() => component) };
  };

</code-example>
<p translation-origin="off">Now you can add a simpler, more meaningful parent provider to your components:</p>
<p translation-result="">现在就可以为组件添加一个更简单、直观的父级提供商了：</p>
<code-example path="dependency-injection-in-action/src/app/parent-finder.component.ts" region="alice-providers" title="dependency-injection-in-action/src/app/parent-finder.component.ts" linenums="false">
providers:  [ provideParent(AliceComponent) ]

</code-example>
<p translation-origin="off">You can do better. The current version of the helper function can only alias the <code>Parent</code> <em>class-interface</em>.
The application might have a variety of parent types, each with its own <em>class-interface</em> token.</p>
<p translation-result="">你可以做得更好。当前版本的助手函数只能为 <code>Parent</code><em>类-接口</em>提供别名。应用程序可能有很多类型的父组件，每个父组件有自己的<em>类-接口</em>令牌。</p>
<p translation-origin="off">Here's a revised version that defaults to <code>parent</code> but also accepts an optional second parameter for a different parent <em>class-interface</em>.</p>
<p translation-result="">下面是一个修改版本，默认接受一个 <code>Parent</code>，但同时接受一个可选的第二参数，可以用来指定一个不同的父级<em>类-接口</em>。</p>
<code-example path="dependency-injection-in-action/src/app/parent-finder.component.ts" region="provide-parent" title="dependency-injection-in-action/src/app/parent-finder.component.ts" linenums="false">
// Helper method to provide the current component instance in the name of <a href="/api/router/RouterLinkWithHref" class="code-anchor">a</a> `parentType`.
// The `parentType` defaults to `Parent` when omitting the second parameter.
const provideParent =
  (component: any, parentType?: any) => {
    return { provide: parentType || Parent, useExisting: <a href="/api/core/forwardRef" class="code-anchor">forwardRef</a>(() => component) };
  };

</code-example>
<p translation-origin="off">And here's how you could use it with a different parent type:</p>
<p translation-result="">下面的代码演示了如何使它添加一个不同类型的父级：</p>
<code-example path="dependency-injection-in-action/src/app/parent-finder.component.ts" region="beth-providers" title="dependency-injection-in-action/src/app/parent-finder.component.ts" linenums="false">
providers:  [ provideParent(BethComponent, DifferentParent) ]

</code-example>
<a id="forwardref"></a>
<h2 translation-origin="off" id="break-circularities-with-a-forward-class-reference-forwardref">Break circularities with a forward class reference (<em>forwardRef</em>)<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#break-circularities-with-a-forward-class-reference-forwardref"><i class="material-icons">link</i></a></h2>
<h2 translation-result="" id="break-circularities-with-a-forward-class-reference-emforwardrefem">使用一个前向引用(<em>forwardRef</em>)来打破循环<a title="Link to this heading" class="header-link" aria-hidden="true" href="/guide/dependency-injection-in-action#break-circularities-with-a-forward-class-reference-emforwardrefem"><i class="material-icons">link</i></a></h2>
<p translation-origin="off">The order of class declaration matters in TypeScript.
You can't refer directly to a class until it's been defined.</p>
<p translation-result="">在 TypeScript 里面，类声明的顺序是很重要的。如果一个类尚未定义，就不能引用它。</p>
<p translation-origin="off">This isn't usually a problem, especially if you adhere to the recommended <em>one class per file</em> rule.
But sometimes circular references are unavoidable.
You're in a bind when class 'A' refers to class 'B' and 'B' refers to 'A'.
One of them has to be defined first.</p>
<p translation-result="">这通常不是一个问题，特别是当你遵循<em>一个文件一个类</em>规则的时候。
但是有时候循环引用可能不能避免。当一个类<em>A 引用类 B</em>，同时'B'引用'A'的时候，你就陷入困境了：它们中间的某一个必须要先定义。</p>
<p translation-origin="off">The Angular <code><a href="/api/core/forwardRef" class="code-anchor">forwardRef</a>()</code> function creates an <em>indirect</em> reference that Angular can resolve later.</p>
<p translation-result="">Angular 的 <code><a href="/api/core/forwardRef" class="code-anchor">forwardRef</a>()</code> 函数建立一个<em>间接地</em>引用，Angular 可以随后解析。</p>
<p translation-origin="off">The <em>Parent Finder</em> sample is full of circular class references that are impossible to break.</p>
<p translation-result=""><em>Parent Finder</em>是一个充满了无法解决的循环引用的例子</p>
<p translation-origin="off">You face this dilemma when a class makes <em>a reference to itself</em>
as does the <code>AlexComponent</code> in its <code>providers</code> array.
The <code>providers</code> array is a property of the <code>@<a href="/api/core/Component" class="code-anchor">Component</a></code> decorator function which must
appear <em>above</em> the class definition.</p>
<p translation-result="">当一个类<em>需要引用自身</em>的时候，你面临同样的困境，就像在 <code>AlexComponent</code> 的 <code>provdiers</code> 数组中遇到的困境一样。
该 <code>providers</code> 数组是一个 <code>@<a href="/api/core/Component" class="code-anchor">Component</a></code> 装饰器函数的一个属性，它必须在类定义<em>之前</em>出现。</p>
<p translation-origin="off">Break the circularity with <code><a href="/api/core/forwardRef" class="code-anchor">forwardRef</a></code>:</p>
<p translation-result="">使用 <code><a href="/api/core/forwardRef" class="code-anchor">forwardRef</a></code> 来打破这种循环：</p>
<code-example path="dependency-injection-in-action/src/app/parent-finder.component.ts" region="alex-providers" title="parent-finder.component.ts (AlexComponent providers)" linenums="false">
providers: [{ provide: Parent, useExisting: <a href="/api/core/forwardRef" class="code-anchor">forwardRef</a>(() => AlexComponent) }],

</code-example>

</div>

</mat-sidenav-content></mat-sidenav-container><div class="toc-container no-print" style="max-height: 34485px;"><aio-lazy-ce selector="aio-toc"><aio-toc ng-version="6.0.0"></aio-toc></aio-lazy-ce></div><footer class="no-print"><aio-footer><div class="grid-fluid"><div class="footer-block"><h3>资源</h3><ul><li><a class="link" href="/about" title="Angular 贡献者。">关于</a></li><li><a class="link" href="/resources" title="网络上的 Angular 工具、培训、博客等">资源列表</a></li><li><a class="link" href="/presskit" title="我们的联系方式、LOGO 和品牌">宣传资料</a></li><li><a class="link" href="https://blog.angular.io/" title="Angular 官方博客">博客</a></li></ul></div><div class="footer-block"><h3>帮助</h3><ul><li><a class="link" href="https://stackoverflow.com/questions/tagged/angular" title="Stack Overflow: 这里的社区会回答你关于 Angular 的技术问题">Stack Overflow</a></li><li><a class="link" href="https://gitter.im/angular/angular" title="和老鸟聊 Angular">Gitter</a></li><li><a class="link" href="https://github.com/angular/angular/issues" title="在 github 上报告问题和建议。">报告问题</a></li><li><a class="link" href="https://github.com/angular/code-of-conduct/blob/master/CODE_OF_CONDUCT.md" title="让我们彼此尊重">行为规范</a></li></ul></div><div class="footer-block"><h3>社区</h3><ul><li><a class="link" href="/events" title="Post issues and suggestions on github.">活动</a></li><li><a class="link" href="http://www.meetup.com/topics/angularjs/" title="参加聚会，向别的开发人员学习">聚会</a></li><li><a class="link" href="https://twitter.com/angular" title="Twitter">Twitter</a></li><li><a class="link" href="https://github.com/angular/angular" title="GitHub">GitHub</a></li><li><a class="link" href="/contribute" title="向 Angular 做贡献">做贡献</a></li></ul></div><div class="footer-block"><h3>多语言</h3><ul><li><a class="link" href="https://angular.io/" title="English Version.">English Version</a></li><li><a class="link" href="https://angular.jp/" title="日本語版">日本語版</a></li></ul></div></div><p>Powered by Google ©2010-2018. 代码授权方式：<a href="/license" title="License text">MIT-style License</a>. 文档授权方式：<a href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.</p><p>当前版本：6.1.1-local+sha.fe5eef45e.</p></aio-footer></footer></aio-shell>

  <noscript>
    <div class="background-sky hero"></div>
    <section id="intro">
      <div class="hero-logo">
        <img src="assets/images/logos/angular/angular.svg" width="250" height="250">
      </div>
      <div class="homepage-container">
        <div class="hero-headline">一套框架，多种平台<br>移动 &amp; 桌面</div>
      </div>
    </section>
    <h2 style="color: red; text-align: center; margin-top: -50px;">
      <b><i>该网站需要浏览器支持 JavaScript </i></b>
    </h2>
  </noscript>


<script type="text/javascript" src="runtime.8449e895f8a924ee0f85.js"></script><script type="text/javascript" src="polyfills.e0d2c3e02a83a3cfb1a1.js"></script><script type="text/javascript" src="main.6f07a93e787bf7b7efab.js"></script></body></html>