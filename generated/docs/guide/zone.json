{
  "id": "guide/zone",
  "title": "NgZone",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/zone.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"ngzone\">NgZone<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#ngzone\"><i class=\"material-icons\">link</i></a></h1>\n<p>A zone is an execution context that persists across async tasks. You can think of it as <a href=\"https://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage</a> for JavaScript VMs.\nThis guide describes how to use Angular's NgZone to automatically detect changes in the component to update HTML.</p>\n<h2 id=\"fundamentals-of-change-detection\">Fundamentals of change detection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#fundamentals-of-change-detection\"><i class=\"material-icons\">link</i></a></h2>\n<p>To understand the benefits of <code><a href=\"api/core/NgZone\" class=\"code-anchor\">NgZone</a></code>, it is important to have a clear grasp of what change detection is and how it works.</p>\n<h3 id=\"displaying-and-updating-data-in-angular\">Displaying and updating data in Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#displaying-and-updating-data-in-angular\"><i class=\"material-icons\">link</i></a></h3>\n<p>In Angular, you can display data by binding controls in an HTML template to the properties of an Angular component.</p>\n<code-example path=\"displaying-data/src/app/app.component.1.ts\" header=\"src/app/app.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: `\n    &#x3C;h1>{{title}}&#x3C;/h1>\n    &#x3C;h2>My favorite hero is: {{myHero}}&#x3C;/h2>\n    `\n})\nexport class AppComponent {\n  title = 'Tour of Heroes';\n  myHero = 'Windstorm';\n}\n\n\n</code-example>\n<p>In addition, you can bind DOM events to a method of an Angular component. In such methods, you can also update a property of the Angular component, which updates the corresponding data displayed in the template.</p>\n<code-example path=\"user-input/src/app/click-me.component.ts\" region=\"click-me-component\" header=\"src/app/click-me.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-click-me',\n  template: `\n    &#x3C;button (click)=\"onClickMe()\">Click me!&#x3C;/button>\n    {{clickMessage}}`\n})\nexport class ClickMeComponent {\n  clickMessage = '';\n\n  onClickMe() {\n    this.clickMessage = 'You are my hero!';\n  }\n}\n\n</code-example>\n<p>In both of the above examples, the component's code updates only the property of the component.\nHowever, the HTML is also updated automatically.\nThis guide describes how and when Angular renders the HTML based on the data from the Angular component.</p>\n<h3 id=\"detecting-changes-with-plain-javascript\">Detecting changes with plain JavaScript<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#detecting-changes-with-plain-javascript\"><i class=\"material-icons\">link</i></a></h3>\n<p>To clarify how changes are detected and values updated, consider the following code written in plain JavaScript.</p>\n<code-example language=\"javascript\">\n&#x3C;html>\n  &#x3C;div id=\"dataDiv\">&#x3C;/div>\n  &#x3C;button id=\"btn\">updateData&#x3C;/button>\n  &#x3C;canvas id=\"canvas\">&#x3C;/canvas>\n  &#x3C;script>\n    let value = 'initialValue';\n    // initial rendering\n    detectChange();\n\n    function renderHTML() {\n      document.getElementById('dataDiv').innerText = value;\n    }\n\n    function detectChange() {\n      const currentValue = document.getElementById('dataDiv').innerText;\n      if (currentValue !== value) {\n        renderHTML();\n      }\n    }\n\n    // Example 1: update data inside button click event handler\n    document.getElementById('btn').addEventListener('click', () => {\n      // update value\n      value = 'button update value';\n      // call detectChange manually\n      detectChange();\n    });\n\n    // Example 2: HTTP Request\n    const xhr = new XMLHttpRequest();\n    xhr.addEventListener('load', function() {\n      // get response from server\n      value = this.responseText;\n      // call detectChange manually\n      detectChange();\n    });\n    xhr.open('GET', serverUrl);\n    xhr.send();\n\n    // Example 3: setTimeout\n    setTimeout(() => {\n      // update value inside setTimeout callback\n      value = 'timeout update value';\n      // call detectChange manually\n      detectChange();\n    }, 100);\n\n    // Example 4: Promise.then\n    Promise.resolve('promise resolved a value').then(v => {\n      // update value inside Promise thenCallback\n      value = v;\n      // call detectChange manually\n      detectChange();\n    }, 100);\n\n    // Example 5: some other asynchronous APIs\n    document.getElementById('canvas').toBlob(blob => {\n      // update value when blob data is created from the canvas\n      value = `value updated by canvas, size is ${blob.size}`;\n      // call detectChange manually\n      detectChange();\n    });\n  &#x3C;/script>\n&#x3C;/html>\n</code-example>\n<p>After you update the data, you need to call <code>detectChange()</code> manually to check whether the data changed.\nIf the data changed, you render the HTML to reflect the updated data.</p>\n<p>In Angular, this step is unnecessary. Whenever you update the data, your HTML is updated automatically.</p>\n<h3 id=\"when-apps-update-html\">When apps update HTML<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#when-apps-update-html\"><i class=\"material-icons\">link</i></a></h3>\n<p>To understand how change detection works, first consider when the application needs to update the HTML. Typically, updates occur for one of the following reasons:</p>\n<ol>\n<li>\n<p>Component initialization. For example, when bootstrapping an Angular application, Angular loads the bootstrap component and triggers the <a href=\"api/core/ApplicationRef#tick\">ApplicationRef.tick()</a> to call change detection and View Rendering.</p>\n</li>\n<li>\n<p>Event listener. The DOM event listener can update the data in an Angular component and also trigger change detection, as in the following example.</p>\n</li>\n</ol>\n<code-example path=\"user-input/src/app/click-me.component.ts\" region=\"click-me-component\" header=\"src/app/click-me.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-click-me',\n  template: `\n    &#x3C;button (click)=\"onClickMe()\">Click me!&#x3C;/button>\n    {{clickMessage}}`\n})\nexport class ClickMeComponent {\n  clickMessage = '';\n\n  onClickMe() {\n    this.clickMessage = 'You are my hero!';\n  }\n}\n\n</code-example>\n<ol start=\"3\">\n<li>HTTP Data Request. You can also get data from a server through an HTTP request. For example:</li>\n</ol>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: '&#x3C;div>{{data}}&#x3C;/div>';\n})\nexport class AppComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  data = 'initial value';\n  serverUrl = 'SERVER_URL';\n  constructor(private httpClient: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>) {}\n\n  ngOnInit() {\n    this.httpClient.get(this.serverUrl).subscribe(response => {\n      // user does not need to <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> change detection manually\n      this.data = response.data;\n    });\n  }\n}\n</code-example>\n<ol start=\"4\">\n<li>MacroTasks, such as <code>setTimeout()</code> or <code>setInterval()</code>. You can also update the data in the callback function of a <code>macroTask</code> such as <code>setTimeout()</code>. For example:</li>\n</ol>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: '&#x3C;div>{{data}}&#x3C;/div>';\n})\nexport class AppComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  data = 'initial value';\n\n  ngOnInit() {\n    setTimeout(() => {\n      // user does not need to <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> change detection manually\n      this.data = 'value updated';\n    });\n  }\n}\n</code-example>\n<ol start=\"5\">\n<li>MicroTasks, such as <code>Promise.then()</code>. Other asynchronous APIs return a Promise object (such as <code>fetch</code>), so the <code>then()</code> callback function can also update the data. For example:</li>\n</ol>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: '&#x3C;div>{{data}}&#x3C;/div>';\n})\nexport class AppComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  data = 'initial value';\n\n  ngOnInit() {\n    Promise.resolve(1).then(v => {\n      // user does not need to <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> change detection manually\n      this.data = v;\n    });\n  }\n}\n</code-example>\n<ol start=\"6\">\n<li>Other async operations. In addition to <code>addEventListener()</code>, <code>setTimeout()</code> and <code>Promise.then()</code>, there are other operations that can update the data asynchronously. Some examples include <code>WebSocket.onmessage()</code> and <code>Canvas.toBlob()</code>.</li>\n</ol>\n<p>The preceding list contains most common scenarios in which the application might change the data. Angular runs change detection whenever it detects that data could have changed.\nThe result of change detection is that the DOM is updated with new data. Angular detects the changes in different ways. For component initialization, Angular calls change detection explicitly. For <a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous\">asynchronous operations</a>, Angular uses a zone to detect changes in places where the data could have possibly mutated and it runs change detection automatically.</p>\n<h2 id=\"zones-and-execution-contexts\">Zones and execution contexts<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#zones-and-execution-contexts\"><i class=\"material-icons\">link</i></a></h2>\n<p>A zone provides an execution context that persists across async tasks. <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\">Execution Context</a> is an abstract concept that holds information about the environment within the current code being executed. Consider the following example:</p>\n<code-example language=\"javascript\">\nconst callback = function() {\n  console.log('setTimeout callback context is', this);\n}\n\nconst ctx1 = { name: 'ctx1' };\nconst ctx2 = { name: 'ctx2' };\n\nconst func = function() {\n  console.log('caller context is', this);\n  setTimeout(callback);\n}\n\nfunc.apply(ctx1);\nfunc.apply(ctx2);\n</code-example>\n<p>The value of <code>this</code> in the callback of <code>setTimeout()</code> might differ depending on when <code>setTimeout()</code> is called.\nThus, you can lose the context in asynchronous operations.</p>\n<p>A zone provides a new zone context other than <code>this</code>, the zone context that persists across asynchronous operations.\nIn the following example, the new zone context is called <code>zoneThis</code>.</p>\n<code-example language=\"javascript\">\nzone.run(() => {\n  // now you are in a zone\n  expect(zoneThis).toBe(zone);\n  setTimeout(function() {\n    // the zoneThis context will be the same zone\n    // when the setTimeout is scheduled\n    expect(zoneThis).toBe(zone);\n  });\n});\n</code-example>\n<p>This new context, <code>zoneThis</code>, can be retrieved from the <code>setTimeout()</code> callback function, and this context is the same when the <code>setTimeout()</code> is scheduled.\nTo get the context, you can call <a href=\"https://github.com/angular/angular/blob/master/packages/zone.js/lib/zone.ts\"><code>Zone.current</code></a>.</p>\n<h2 id=\"zones-and-async-lifecycle-hooks\">Zones and async lifecycle hooks<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#zones-and-async-lifecycle-hooks\"><i class=\"material-icons\">link</i></a></h2>\n<p>Zone.js can create contexts that persist across asynchronous operations as well as provide lifecycle hooks for asynchronous operations.</p>\n<code-example language=\"javascript\">\nconst zone = Zone.current.fork({\n  name: 'zone',\n  onScheduleTask: function(delegate, curr, target, task) {\n    console.log('new task is scheduled:', task.type, task.source);\n    return delegate.scheduleTask(target, task);\n  },\n  onInvokeTask: function(delegate, curr, target, task, applyThis, applyArgs) {\n    console.log('task will be invoked:', task.type, task.source);\n    return delegate.invokeTask(target, task, applyThis, applyArgs);\n  },\n  onHasTask: function(delegate, curr, target, hasTaskState) {\n    console.log('task <a href=\"api/animations/state\" class=\"code-anchor\">state</a> changed in the zone:', hasTaskState);\n    return delegate.hasTask(target, hasTaskState);\n  },\n  onInvoke: function(delegate, curr, target, callback, applyThis, applyArgs) {\n    console.log('the callback will be invoked:', callback);\n    return delegate.invoke(target, callback, applyThis, applyArgs);\n  }\n});\nzone.run(() => {\n  setTimeout(() => {\n    console.log('timeout callback is invoked.');\n  });\n});\n</code-example>\n<p>The above example creates a zone with several hooks.</p>\n<p>The <code>onXXXTask</code> hooks trigger when the status of the task changes.\nThe concept of a <em>Zone Task</em> is very similar to the JavaScript VM Task concept:</p>\n<ul>\n<li><code>macroTask</code>: such as <code>setTimeout()</code></li>\n<li><code>microTask</code>: such as <code>Promise.then()</code></li>\n<li><code>eventTask</code>: such as <code>element.addEventListener()</code></li>\n</ul>\n<p>These hooks trigger under the following circumstances:</p>\n<ul>\n<li><code>onScheduleTask</code>: triggers when a new asynchronous task is scheduled, such as when you call <code>setTimeout()</code>.</li>\n<li><code>onInvokeTask</code>: triggers when an asynchronous task is about to execute, such as when the callback of <code>setTimeout()</code> is about to execute.</li>\n<li><code>onHasTask</code>: triggers when the status of one kind of task inside a zone changes from stable to unstable or from unstable to stable. A status of \"stable\" means there are no tasks inside the zone, while \"unstable\" means a new task is scheduled in the zone.</li>\n<li><code>onInvoke</code>: triggers when a synchronous function is going to execute in the zone.</li>\n</ul>\n<p>With these hooks, <code>Zone</code> can monitor the status of all synchronous and asynchronous operations inside a zone.</p>\n<p>The above example returns the following output:</p>\n<code-example>\nthe callback will be invoked: () => {\n  setTimeout(() => {\n    console.log('timeout callback is invoked.');\n  });\n}\nnew task is scheduled: macroTask setTimeout\ntask <a href=\"api/animations/state\" class=\"code-anchor\">state</a> changed in the zone: { microTask: false,\n  macroTask: true,\n  eventTask: false,\n  change: 'macroTask' }\ntask will be invoked macroTask: setTimeout\ntimeout callback is invoked.\ntask <a href=\"api/animations/state\" class=\"code-anchor\">state</a> changed in the zone: { microTask: false,\n  macroTask: false,\n  eventTask: false,\n  change: 'macroTask' }\n</code-example>\n<p>All of the functions of <code>Zone</code> are provided by a library called <a href=\"https://github.com/angular/angular/tree/master/packages/zone.js/README.md\">Zone.js</a>.\nThis library implements those features by intercepting asynchronous APIs through monkey patching.\nMonkey patching is a technique to add or modify the default behavior of a function at runtime without changing the source code.</p>\n<h2 id=\"ngzone-1\">NgZone<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#ngzone-1\"><i class=\"material-icons\">link</i></a></h2>\n<p>While Zone.js can monitor all the states of synchronous and asynchronous operations, Angular additionally provides a service called NgZone.\nThis service creates a zone named <code>angular</code> to automatically trigger change detection when the following conditions are satisfied:</p>\n<ol>\n<li>When a sync or async function is executed.</li>\n<li>When there is no <code>microTask</code> scheduled.</li>\n</ol>\n<h3 id=\"ngzone-run-and-runoutsideofangular\">NgZone <code>run()</code> and <code>runOutsideOfAngular()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#ngzone-run-and-runoutsideofangular\"><i class=\"material-icons\">link</i></a></h3>\n<p><code>Zone</code> handles most asynchronous APIs such as <code>setTimeout()</code>, <code>Promise.then()</code>, and <code>addEventListener()</code>.\nFor the full list, see the <a href=\"https://github.com/angular/angular/blob/master/packages/zone.js/MODULE.md\">Zone Module document</a>.\nTherefore in those asynchronous APIs, you don't need to trigger change detection manually.</p>\n<p>There are still some third party APIs that Zone does not handle.\nIn those cases, the <code><a href=\"api/core/NgZone\" class=\"code-anchor\">NgZone</a></code> service provides a <a href=\"api/core/NgZone#run\"><code>run()</code></a> method that allows you to execute a function inside the angular zone.\nThis function, and all asynchronous operations in that function, trigger change detection automatically at the correct time.</p>\n<code-example language=\"typescript\">\nexport class AppComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private ngZone: <a href=\"api/core/NgZone\" class=\"code-anchor\">NgZone</a>) {}\n  ngOnInit() {\n    // New async API is not handled by Zone, so you need to\n    // use ngZone.run() to make the asynchronous operation in the angular zone\n    // and <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> change detection automatically.\n    this.ngZone.run(() => {\n      someNewAsyncAPI(() => {\n        // update the data of the component\n      });\n    });\n  }\n}\n</code-example>\n<p>By default, all asynchronous operations are inside the angular zone, which triggers change detection automatically.\nAnother common case is when you don't want to trigger change detection.\nIn that situation, you can use another <code><a href=\"api/core/NgZone\" class=\"code-anchor\">NgZone</a></code> method: <a href=\"api/core/NgZone#runoutsideangular\"><code>runOutsideAngular()</code></a>.</p>\n<code-example language=\"typescript\">\nexport class AppComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private ngZone: <a href=\"api/core/NgZone\" class=\"code-anchor\">NgZone</a>) {}\n  ngOnInit() {\n    // You know no data will be updated,\n    // so you don't want to <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> change detection in this\n    // specified operation. Instead, call ngZone.runOutsideAngular()\n    this.ngZone.runOutsideAngular(() => {\n      setTimeout(() => {\n        // update component data\n        // but don't <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> change detection.\n      });\n    });\n  }\n}\n</code-example>\n<h3 id=\"setting-up-zonejs\">Setting up Zone.js<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#setting-up-zonejs\"><i class=\"material-icons\">link</i></a></h3>\n<p>To make Zone.js available in Angular, you need to import the <code>zone.js</code> package.\nIf you are using the Angular CLI, this step is done automatically, and you will see the following line in the <code>src/polyfills.ts</code>:</p>\n<code-example language=\"typescript\">\n/***************************************************************************************************\n * Zone JS is required by default for Angular itself.\n */\nimport 'zone.js/dist/zone';  // Included with Angular CLI.\n</code-example>\n<p>Before importing the  <code>zone.js</code> package, you can set the following configurations:</p>\n<ul>\n<li>You can disable some asynchronous API monkey patching for better performance.\nFor example, you can disable the <code>requestAnimationFrame()</code> monkey patch, so the callback of <code>requestAnimationFrame()</code> will not trigger change detection.\nThis is useful if, in your application, the callback of the <code>requestAnimationFrame()</code> will not update any data.</li>\n<li>You can specify that certain DOM events do not run inside the angular zone; for example, to prevent a <code>mousemove</code> or <code>scroll</code> event to trigger change detection.</li>\n</ul>\n<p>There are several other settings you can change.\nTo make these changes, you need to create a <code>zone-flags.ts</code> file, such as the following.</p>\n<code-example language=\"typescript\">\n// disable patching requestAnimationFrame\n(window as any).__Zone_disable_requestAnimationFrame = true;\n\n// disable patching specified eventNames\n(window as any).__zone_symbol__UNPATCHED_EVENTS = ['scroll', 'mousemove'];\n</code-example>\n<p>Next, import <code>zone-flags</code> before you import <code>zone.js</code> in the <code>polyfills.ts</code>:</p>\n<code-example language=\"typescript\">\n/***************************************************************************************************\n * Zone JS is required by default for Angular.\n */\nimport `./zone-flags`;\nimport 'zone.js/dist/zone';  // Included with Angular CLI.\n</code-example>\n<p>For more information about what you can configure, see the <a href=\"https://github.com/angular/angular/tree/master/packages/zone.js\">Zone.js</a> documentation.</p>\n<h3 id=\"noopzone\">NoopZone<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#noopzone\"><i class=\"material-icons\">link</i></a></h3>\n<p><code>Zone</code> helps Angular know when to trigger change detection and let the developers focus on the application development.\nBy default, <code>Zone</code> is loaded and works without additional configuration. However, you don't necessarily have to use <code>Zone</code> to make Angular work. Instead, you can opt to trigger change detection on your own.</p>\n<div class=\"alert is-helpful\">\n<h4 id=\"disabling-zone\">Disabling <code>Zone</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#disabling-zone\"><i class=\"material-icons\">link</i></a></h4>\n<p><strong>If you disable <code>Zone</code>, you will need to trigger all change detection at the correct timing yourself, which requires comprehensive knowledge of change detection</strong>.</p>\n</div>\n<p>To remove Zone.js, make the following changes.</p>\n<ol>\n<li>\n<p>Remove the <code>zone.js</code> import from <code>polyfills.ts</code>:</p>\n<code-example language=\"typescript\">\n/***************************************************************************************************\n * Zone JS is required by default for Angular itself.\n */\n// import 'zone.js/dist/zone';  // Included with Angular CLI.\n</code-example>\n</li>\n<li>\n<p>Bootstrap Angular with the <code>noop</code> zone in <code>src/main.ts</code>:</p>\n<code-example language=\"typescript\">\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule, { ngZone: 'noop' })\n  .catch(err => console.error(err));\n</code-example>\n</li>\n</ol>\n\n</div>\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/animations/state\n - api/animations/trigger\n - api/common/http/HttpClient\n - api/core/ApplicationRef#tick\n - api/core/Component\n - api/core/NgZone\n - api/core/NgZone#run\n - api/core/NgZone#runoutsideangular\n - api/core/OnInit\n - api/platform-browser-dynamic/platformBrowserDynamic\n - guide/zone#detecting-changes-with-plain-javascript\n - guide/zone#disabling-zone\n - guide/zone#displaying-and-updating-data-in-angular\n - guide/zone#fundamentals-of-change-detection\n - guide/zone#ngzone\n - guide/zone#ngzone-1\n - guide/zone#ngzone-run-and-runoutsideofangular\n - guide/zone#noopzone\n - guide/zone#setting-up-zonejs\n - guide/zone#when-apps-update-html\n - guide/zone#zones-and-async-lifecycle-hooks\n - guide/zone#zones-and-execution-contexts\n - https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\n - https://en.wikipedia.org/wiki/Thread-local_storage\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/zone.md?message=docs%3A%20请简述你的修改...\n - https://github.com/angular/angular/blob/master/packages/zone.js/MODULE.md\n - https://github.com/angular/angular/blob/master/packages/zone.js/lib/zone.ts\n - https://github.com/angular/angular/tree/master/packages/zone.js\n - https://github.com/angular/angular/tree/master/packages/zone.js/README.md\n-->"
}