{
  "id": "guide/testing-components-basics",
  "title": "Basics of testing components",
  "contents": "\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/aio/aio/content/guide/testing-components-basics.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"basics-of-testing-components\" translation-result=\"on\">测试组件的基础知识<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#basics-of-testing-components\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"basics-of-testing-components\">Basics of testing components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#basics-of-testing-components\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">组件与 Angular 应用的所有其它部分不同，它结合了 HTML 模板和 TypeScript 类。事实上，组件就是由模板和类<em>一起工作的</em>。要想对组件进行充分的测试，你应该测试它们是否如预期般协同工作。</p><p translation-origin=\"off\">A component, unlike all other parts of an Angular application,\ncombines an HTML template and a TypeScript class.\nThe component truly is the template and the class <em>working together</em>. To adequately test a component, you should test that they work together\nas intended.</p>\n\n<p translation-result=\"on\">这些测试需要在浏览器 DOM 中创建该组件的宿主元素，就像 Angular 所做的那样，然后检查组件类与 DOM 的交互是否如模板中描述的那样工作。</p><p translation-origin=\"off\">Such tests require creating the component's host element in the browser DOM,\nas Angular does, and investigating the component class's interaction with\nthe DOM as described by its template.</p>\n\n<p translation-result=\"on\">Angular 的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 可以帮你做这种测试，正如你将在下面的章节中看到的那样。但是，在很多情况下，<em>单独测试组件类</em>（不需要 DOM 的参与），就能以更简单，更明显的方式验证组件的大部分行为。</p><p translation-origin=\"off\">The Angular <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> facilitates this kind of testing as you'll see in the following sections.\nBut in many cases, <em>testing the component class alone</em>, without DOM involvement,\ncan validate much of the component's behavior in an straightforward, more obvious way.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">  如果你要试验本指南中所讲的应用，请<live-example name=\"testing\" nodownload=\"\">在浏览器中运行它</live-example>或<live-example name=\"testing\" downloadonly=\"\">下载并在本地运行它</live-example>。</p><p translation-origin=\"off\">  If you'd like to experiment with the application that this guide describes, <live-example name=\"testing\" nodownload=\"\">run it in your browser</live-example> or <live-example name=\"testing\" downloadonly=\"\">download and run it locally</live-example>.</p>\n\n</div>\n<a id=\"component-class-testing\"></a>\n<h2 id=\"component-class-testing\" translation-result=\"on\">组件类测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#component-class-testing\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"component-class-testing\">Component class testing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#component-class-testing\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你可以像测试服务类那样来测试一个组件类本身。</p><p translation-origin=\"off\">Test a component class on its own as you would test a service class.</p>\n\n<p translation-result=\"on\">组件类的测试应该保持非常干净和简单。它应该只测试一个单元。一眼看上去，你就应该能够理解正在测试的对象。</p><p translation-origin=\"off\">Component class testing should be kept very clean and simple.\nIt should test only a single unit.\nAt first glance, you should be able to understand\nwhat the test is testing.</p>\n\n<p translation-result=\"on\">考虑这个 <code>LightswitchComponent</code>，当用户单击该按钮时，它会打开和关闭一个指示灯（用屏幕上的一条消息表示）。</p><p translation-origin=\"off\">Consider this <code>LightswitchComponent</code> which toggles a light on and off\n(represented by an on-screen message) when the user clicks the button.</p>\n\n<code-example path=\"testing/src/app/demo/demo.ts\" region=\"LightswitchComp\" header=\"app/demo/demo.ts (LightswitchComp)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lightswitch-comp',\n  template: `\n    &#x3C;button (click)=\"clicked()\">Click me!&#x3C;/button>\n    &#x3C;span>{{message}}&#x3C;/span>`\n})\nexport class LightswitchComponent {\n  isOn = false;\n  clicked() { this.isOn = !this.isOn; }\n  get message() { return `The light is ${this.isOn ? 'On' : 'Off'}`; }\n}\n\n</code-example>\n<p translation-result=\"on\">你可能要测试 <code>clicked()</code> 方法是否切换了灯的<em>开/关</em>状态并正确设置了这个消息。</p><p translation-origin=\"off\">You might decide only to test that the <code>clicked()</code> method\ntoggles the light's <em>on/off</em> state and sets the message appropriately.</p>\n\n<p translation-result=\"on\">这个组件类没有依赖。要测试这种类型的组件类，请遵循与没有依赖的服务相同的步骤：</p><p translation-origin=\"off\">This component class has no dependencies. To test these types of classes, follow the same steps as you would for a service that has no dependencies:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">使用 new 关键字创建一个组件。</p><p translation-origin=\"off\">Create a component using the new keyword.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">调用它的 API。</p><p translation-origin=\"off\">Poke at its API.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">对其公开状态的期望值进行断言。</p><p translation-origin=\"off\">Assert expectations on its public state.</p>\n\n</li>\n</ol>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"Lightswitch\" header=\"app/demo/demo.spec.ts (Lightswitch tests)\">\ndescribe('LightswitchComp', () => {\n  it('#clicked() should toggle #isOn', () => {\n    const comp = new LightswitchComponent();\n    expect(comp.isOn).toBe(false, 'off at first');\n    comp.clicked();\n    expect(comp.isOn).toBe(true, 'on after click');\n    comp.clicked();\n    expect(comp.isOn).toBe(false, 'off after second click');\n  });\n\n  it('#clicked() should set #message to \"is on\"', () => {\n    const comp = new LightswitchComponent();\n    expect(comp.message).toMatch(/is off/i, 'off at first');\n    comp.clicked();\n    expect(comp.message).toMatch(/is on/i, 'on after clicked');\n  });\n});\n\n</code-example>\n<p translation-result=\"on\">下面是“<em>英雄之旅</em>”教程中的 <code>DashboardHeroComponent</code>。</p><p translation-origin=\"off\">Here is the <code>DashboardHeroComponent</code> from the <em>Tour of Heroes</em> tutorial.</p>\n\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.ts\" region=\"class\" header=\"app/dashboard/dashboard-hero.component.ts (component)\">\nexport class DashboardHeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero!: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() selected = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;Hero>();\n  click() { this.selected.emit(this.hero); }\n}\n\n</code-example>\n<p translation-result=\"on\">它出现在父组件的模板中，把一个<em>英雄</em>绑定到了 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 属性，并监听通过<em>所选</em><code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> 属性引发的一个事件。</p><p translation-origin=\"off\">It appears within the template of a parent component,\nwhich binds a <em>hero</em> to the <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> property and\nlistens for an event raised through the <em>selected</em> <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> property.</p>\n\n<p translation-result=\"on\">你可以测试类代码的工作方式，而无需创建 <code>DashboardHeroComponent</code> 或它的父组件。</p><p translation-origin=\"off\">You can test that the class code works without creating the <code>DashboardHeroComponent</code>\nor its parent component.</p>\n\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"class-only\" header=\"app/dashboard/dashboard-hero.component.spec.ts (class tests)\">\nit('raises the selected event when clicked', () => {\n  const comp = new DashboardHeroComponent();\n  const hero: Hero = {id: 42, name: 'Test'};\n  comp.hero = hero;\n\n  comp.selected.pipe(first()).subscribe((selectedHero: Hero) => expect(selectedHero).toBe(hero));\n  comp.click();\n});\n\n</code-example>\n<p translation-result=\"on\">当组件有依赖时，你可能要使用 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 来同时创建该组件及其依赖。</p><p translation-origin=\"off\">When a component has dependencies, you might want to use the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> to both\ncreate the component and its dependencies.</p>\n\n<p translation-result=\"on\">下列的 <code>WelcomeComponent</code> 依赖于 <code>UserService</code> 来了解要问候的用户的名字。</p><p translation-origin=\"off\">The following <code>WelcomeComponent</code> depends on the <code>UserService</code> to know the name of the user to greet.</p>\n\n<code-example path=\"testing/src/app/welcome/welcome.component.ts\" region=\"class\" header=\"app/welcome/welcome.component.ts\">\nexport class WelcomeComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  welcome = '';\n  constructor(private userService: UserService) { }\n\n  ngOnInit(): void {\n    this.welcome = this.userService.isLoggedIn ?\n      'Welcome, ' + this.userService.user.name : 'Please log in.';\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">你可以先创建一个能满足本组件最低需求的 <code>UserService</code></p><p translation-origin=\"off\">You might start by creating a mock of the <code>UserService</code> that meets the minimum needs of this component.</p>\n\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"mock-user-service\" header=\"app/welcome/welcome.component.spec.ts (MockUserService)\">\nclass MockUserService {\n  isLoggedIn = true;\n  user = { name: 'Test User'};\n}\n\n</code-example>\n<p translation-result=\"on\">然后在 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 配置中提供并注入所有这些<strong>组件</strong>和<em>服务</em>。</p><p translation-origin=\"off\">Then provide and inject <em>both the</em> <strong>component</strong> <em>and the service</em> in the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> configuration.</p>\n\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"class-only-before-each\" header=\"app/welcome/welcome.component.spec.ts (class-only setup)\">\nbeforeEach(() => {\n  TestBed.configureTestingModule({\n    // provide the component-under-test and dependent service\n    providers: [\n      WelcomeComponent,\n      { provide: UserService, useClass: MockUserService }\n    ]\n  });\n  // inject both the component and the dependent service.\n  comp = TestBed.inject(WelcomeComponent);\n  userService = TestBed.inject(UserService);\n});\n\n</code-example>\n<p translation-result=\"on\">然后，测验组件类，别忘了要像 Angular 运行应用时一样<a href=\"guide/lifecycle-hooks\">调用生命周期钩子方法</a>。</p><p translation-origin=\"off\">Then exercise the component class, remembering to call the <a href=\"guide/lifecycle-hooks\">lifecycle hook methods</a> as Angular does when running the application.</p>\n\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"class-only-tests\" header=\"app/welcome/welcome.component.spec.ts (class-only tests)\">\nit('should not have welcome message after construction', () => {\n  expect(comp.welcome).toBe('');\n});\n\nit('should welcome logged in user after Angular calls ngOnInit', () => {\n  comp.ngOnInit();\n  expect(comp.welcome).toContain(userService.user.name);\n});\n\nit('should ask user to log in if not logged in after ngOnInit', () => {\n  userService.isLoggedIn = false;\n  comp.ngOnInit();\n  expect(comp.welcome).not.toContain(userService.user.name);\n  expect(comp.welcome).toContain('log in');\n});\n\n</code-example>\n<h2 id=\"component-dom-testing\" translation-result=\"on\">组件 DOM 测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#component-dom-testing\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"component-dom-testing\">Component DOM testing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#component-dom-testing\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">测试组件<em>类</em><a href=\"guide/testing-services\">和测试服务</a>一样简单。</p><p translation-origin=\"off\">Testing the component <em>class</em> is as straightforward as <a href=\"guide/testing-services\">testing a service</a>.</p>\n\n<p translation-result=\"on\">但组件不仅仅是它的类。组件还会与 DOM 以及其他组件进行交互。<em>只对类</em>的测试可以告诉你类的行为。但它们无法告诉你这个组件是否能正确渲染、响应用户输入和手势，或是集成到它的父组件和子组件中。</p><p translation-origin=\"off\">But a component is more than just its class.\nA component interacts with the DOM and with other components.\nThe <em>class-only</em> tests can tell you about class behavior.\nThey cannot tell you if the component is going to render properly,\nrespond to user input and gestures, or integrate with its parent and child components.</p>\n\n<p translation-result=\"on\">以上所有<em>只对类</em>的测试都不能回答有关组件会如何在屏幕上实际运行方面的关键问题。</p><p translation-origin=\"off\">None of the preceding <em>class-only</em> tests can answer key questions about how the\ncomponents actually behave on screen.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>Lightswitch.clicked()</code> 绑定到了什么？用户可以调用它吗？</p><p translation-origin=\"off\">Is <code>Lightswitch.clicked()</code> bound to anything such that the user can invoke it?</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>Lightswitch.message</code> 是否显示过？</p><p translation-origin=\"off\">Is the <code>Lightswitch.message</code> displayed?</p>\n\n</li>\n<li>\n<p translation-result=\"on\">用户能否真正选中由 <code>DashboardHeroComponent</code> 显示的英雄？</p><p translation-origin=\"off\">Can the user actually select the hero displayed by <code>DashboardHeroComponent</code>?</p>\n\n</li>\n<li>\n<p translation-result=\"on\">英雄名字是否按预期显示的（也就是大写字母）？</p><p translation-origin=\"off\">Is the hero name displayed as expected (i.e, in uppercase)?</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>WelcomeComponent</code> 的模板是否显示了欢迎信息？</p><p translation-origin=\"off\">Is the welcome message displayed by the template of <code>WelcomeComponent</code>?</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">对于上面描述的那些简单组件来说，这些问题可能并不麻烦。但是很多组件都与模板中描述的 DOM 元素进行了复杂的交互，导致一些 HTML 会在组件状态发生变化时出现和消失。</p><p translation-origin=\"off\">These might not be troubling questions for the preceding simple components illustrated.\nBut many components have complex interactions with the DOM elements\ndescribed in their templates, causing HTML to appear and disappear as\nthe component state changes.</p>\n\n<p translation-result=\"on\">要回答这些问题，你必须创建与组件关联的 DOM 元素，你必须检查 DOM 以确认组件状态是否在适当的时候正确显示了，并且你必须模拟用户与屏幕的交互以确定这些交互是否正确。判断该组件的行为是否符合预期。</p><p translation-origin=\"off\">To answer these kinds of questions, you have to create the DOM elements associated\nwith the components, you must examine the DOM to confirm that component state\ndisplays properly at the appropriate times, and you must simulate user interaction\nwith the screen to determine whether those interactions cause the component to\nbehave as expected.</p>\n\n<p translation-result=\"on\">为了编写这些类型的测试，你将使用 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的其它特性以及其他的测试辅助函数。</p><p translation-origin=\"off\">To write these kinds of test, you'll use additional features of the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>\nas well as other testing helpers.</p>\n\n<h3 id=\"cli-generated-tests\" translation-result=\"on\">CLI 生成的测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#cli-generated-tests\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"cli-generated-tests\">CLI-generated tests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#cli-generated-tests\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">当你要求 CLI 生成一个新组件时，它会默认为你创建一个初始的测试文件。</p><p translation-origin=\"off\">The CLI creates an initial test file for you by default when you ask it to\ngenerate a new component.</p>\n\n<p translation-result=\"on\">比如，下列 CLI 命令会在 <code>app/banner</code> 文件夹中生成带有内联模板和内联样式的 <code>BannerComponent</code>：</p><p translation-origin=\"off\">For example, the following CLI command generates a <code>BannerComponent</code> in the <code>app/banner</code> folder (with inline template and styles):</p>\n\n<code-example language=\"sh\">\nng generate component banner --inline-template --inline-style --module app\n</code-example>\n<p translation-result=\"on\">它还会生成一个初始测试文件 <code>banner-external.component.spec.ts</code>，如下所示：</p><p translation-origin=\"off\">It also generates an initial test file for the component, <code>banner-external.component.spec.ts</code>, that looks like this:</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v1\" header=\"app/banner/banner-external.component.spec.ts (initial)\">\nimport { <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a> } from '@angular/core/testing';\n\nimport { BannerComponent } from './banner.component';\n\ndescribe('BannerComponent', () => {\n  let component: BannerComponent;\n  let fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&#x3C;BannerComponent>;\n\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n    TestBed.configureTestingModule({declarations: [BannerComponent]}).compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">由于 <code>compileComponents</code> 是异步的，所以它使用从 <code>@angular/core/testing</code> 中导入的实用工具函数 <a href=\"api/core/testing/waitForAsync\"><code>waitForAsync</code></a>。</p><p translation-origin=\"off\">Because <code>compileComponents</code> is asynchronous, it uses\nthe <a href=\"api/core/testing/waitForAsync\"><code>waitForAsync</code></a> utility\nfunction imported from <code>@angular/core/testing</code>.</p>\n\n<p translation-result=\"on\">欲知详情，请参阅 <a href=\"guide/testing-components-scenarios#waitForAsync\">waitForAsync 部分。</a></p><p translation-origin=\"off\">Refer to the <a href=\"guide/testing-components-scenarios#waitForAsync\">waitForAsync</a> section for more details.</p>\n\n</div>\n<h3 id=\"reduce-the-setup\" translation-result=\"on\">减少设置代码<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#reduce-the-setup\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"reduce-the-setup\">Reduce the setup<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#reduce-the-setup\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">只有这个文件的最后三行才是真正测试组件的，并且所有这些都断言了 Angular 可以创建该组件。</p><p translation-origin=\"off\">Only the last three lines of this file actually test the component\nand all they do is assert that Angular can create the component.</p>\n\n<p translation-result=\"on\">该文件的其它部分是做设置用的样板代码，<em>可以</em>预见，如果组件演变得更具实质性内容，就会需要更高级的测试。</p><p translation-origin=\"off\">The rest of the file is boilerplate setup code anticipating more advanced tests that <em>might</em> become necessary if the component evolves into something substantial.</p>\n\n<p translation-result=\"on\">下面你将学习这些高级测试特性。现在，你可以从根本上把这个测试文件减少到一个更容易管理的大小：</p><p translation-origin=\"off\">You'll learn about these advanced test features in the following sections.\nFor now, you can radically reduce this test file to a more manageable size:</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v2\" header=\"app/banner/banner-initial.component.spec.ts (minimal)\">\ndescribe('BannerComponent (minimal)', () => {\n  it('should create', () => {\n    TestBed.configureTestingModule({declarations: [BannerComponent]});\n    const fixture = TestBed.createComponent(BannerComponent);\n    const component = fixture.componentInstance;\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n<p translation-result=\"on\">在这个例子中，传给 <code>TestBed.configureTestingModule</code> 的元数据对象只是声明了要测试的组件 <code>BannerComponent</code></p><p translation-origin=\"off\">In this example, the metadata object passed to <code>TestBed.configureTestingModule</code>\nsimply declares <code>BannerComponent</code>, the component to test.</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"configureTestingModule\">\nTestBed.configureTestingModule({declarations: [BannerComponent]});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">没有必要声明或导入任何其他东西。默认的测试模块预先配置了像来自 <code>@angular/platform-browser</code> 的 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> 这样的东西。</p><p translation-origin=\"off\">There's no need to declare or import anything else.\nThe default test module is pre-configured with\nsomething like the <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> from <code>@angular/platform-browser</code>.</p>\n\n<p translation-result=\"on\">稍后你会用 <code>imports</code>、<code>providers</code> 和更多可声明对象的参数来调用 <code>TestBed.configureTestingModule()</code>，以满足你的测试需求。可选方法 <code>override</code>可以进一步微调此配置的各个方面。</p><p translation-origin=\"off\">Later you'll call <code>TestBed.configureTestingModule()</code> with\nimports, providers, and more declarations to suit your testing needs.\nOptional <code>override</code> methods can further fine-tune aspects of the configuration.</p>\n\n</div>\n<a id=\"create-component\"></a>\n<h3 id=\"createcomponent\"><em>createComponent()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#createcomponent\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">在配置好 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 之后，你就可以调用它的 <code>createComponent()</code> 方法了。</p><p translation-origin=\"off\">After configuring <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>, you call its <code>createComponent()</code> method.</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"createComponent\">\nconst fixture = TestBed.createComponent(BannerComponent);\n\n</code-example>\n<p translation-result=\"on\"><code>TestBed.createComponent()</code> 会创建 <code>BannerComponent</code> 的实例，它把一个对应元素添加到了测试运行器的 DOM 中，并返回一个<a href=\"guide/testing-components-basics#component-fixture\"><code>ComponentFixture</code></a> 对象。</p><p translation-origin=\"off\"><code>TestBed.createComponent()</code> creates an instance of the <code>BannerComponent</code>,\nadds a corresponding element to the test-runner DOM,\nand returns a <a href=\"guide/testing-components-basics#component-fixture\"><code>ComponentFixture</code></a>.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">调用 <code>createComponent</code> 后不能再重新配置 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 。</p><p translation-origin=\"off\">Do not re-configure <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> after calling <code>createComponent</code>.</p>\n\n<p translation-result=\"on\"><code>createComponent</code> 方法会冻结当前的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 定义，并把它关闭以防止进一步的配置。</p><p translation-origin=\"off\">The <code>createComponent</code> method freezes the current <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> definition,\nclosing it to further configuration.</p>\n\n<p translation-result=\"on\">你不能再调用任何 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 配置方法， 无论是 <code>configureTestingModule()</code>、<code>get()</code> 还是 <code>override...</code> 方法都不行。如果你这样做，<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 会抛出一个错误。</p><p translation-origin=\"off\">You cannot call any more <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> configuration methods, not <code>configureTestingModule()</code>,\nnor <code>get()</code>, nor any of the <code>override...</code> methods.\nIf you try, <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> throws an error.</p>\n\n</div>\n<a id=\"component-fixture\"></a>\n<h3 id=\"componentfixture\"><em>ComponentFixture</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#componentfixture\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\"><a href=\"api/core/testing/ComponentFixture\">ComponentFixture</a> 是一个测试挽具，用于与所创建的组件及其对应的元素进行交互。</p><p translation-origin=\"off\">The <a href=\"api/core/testing/ComponentFixture\">ComponentFixture</a> is a test harness for interacting with the created component and its corresponding element.</p>\n\n<p translation-result=\"on\">可以通过测试夹具（fixture）访问组件实例，并用 Jasmine 的期望断言来确认它是否存在：</p><p translation-origin=\"off\">Access the component instance through the fixture and confirm it exists with a Jasmine expectation:</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"componentInstance\">\nconst component = fixture.componentInstance;\nexpect(component).toBeDefined();\n\n</code-example>\n<h3 id=\"beforeeach\"><em>beforeEach()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#beforeeach\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">随着这个组件的发展，你会添加更多的测试。你不必为每个测试复制 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的配置代码，而是把它重构到 Jasmine 的 <code>beforeEach()</code> 和一些支持变量中：</p><p translation-origin=\"off\">You will add more tests as this component evolves.\nRather than duplicate the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> configuration for each test,\nyou refactor to pull the setup into a Jasmine <code>beforeEach()</code> and some supporting variables:</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v3\">\ndescribe('BannerComponent (with beforeEach)', () => {\n  let component: BannerComponent;\n  let fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&#x3C;BannerComponent>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({declarations: [BannerComponent]});\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n  });\n\n  it('should create', () => {\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n<p translation-result=\"on\">现在添加一个测试程序，它从 <code>fixture.nativeElement</code> 中获取组件的元素，并查找预期的文本。</p><p translation-origin=\"off\">Now add a test that gets the component's element from <code>fixture.nativeElement</code> and\nlooks for the expected text.</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-2\">\nit('should contain \"banner works!\"', () => {\n  const bannerElement: HTMLElement = fixture.nativeElement;\n  expect(bannerElement.textContent).toContain('banner works!');\n});\n\n</code-example>\n<a id=\"native-element\"></a>\n<h3 id=\"nativeelement\"><em>nativeElement</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#nativeelement\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\"><code><a href=\"api/core/testing/ComponentFixture#nativeElement\" class=\"code-anchor\">ComponentFixture.nativeElement</a></code> 的值是 <code>any</code> 类型的。稍后你会遇到 <code><a href=\"api/core/DebugElement#nativeElement\" class=\"code-anchor\">DebugElement.nativeElement</a></code>，它也是 <code>any</code> 类型的。</p><p translation-origin=\"off\">The value of <code><a href=\"api/core/testing/ComponentFixture#nativeElement\" class=\"code-anchor\">ComponentFixture.nativeElement</a></code> has the <code>any</code> type.\nLater you'll encounter the <code><a href=\"api/core/DebugElement#nativeElement\" class=\"code-anchor\">DebugElement.nativeElement</a></code> and it too has the <code>any</code> type.</p>\n\n<p translation-result=\"on\">Angular 在编译时不知道 <code>nativeElement</code> 是什么样的 HTML 元素，甚至可能不是 HTML 元素。该应用可能运行在<em>非浏览器平台</em>（如服务器或 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API\">Web Worker）上</a>，在那里本元素可能具有一个缩小版的 API，甚至根本不存在。</p><p translation-origin=\"off\">Angular can't know at compile time what kind of HTML element the <code>nativeElement</code> is or\nif it even is an HTML element.\nThe application might be running on a <em>non-browser platform</em>, such as the server or a\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API\">Web Worker</a>,\nwhere the element might have a diminished API or not exist at all.</p>\n\n<p translation-result=\"on\">本指南中的测试都是为了在浏览器中运行而设计的，因此 <code>nativeElement</code> 的值始终是 <code>HTMLElement</code> 或其派生类之一。</p><p translation-origin=\"off\">The tests in this guide are designed to run in a browser so a\n<code>nativeElement</code> value will always be an <code>HTMLElement</code> or\none of its derived classes.</p>\n\n<p translation-result=\"on\">知道了它是某种 <code>HTMLElement</code> ，就可以用标准的 HTML <code>querySelector</code> 深入了解元素树。</p><p translation-origin=\"off\">Knowing that it is an <code>HTMLElement</code> of some sort, use\nthe standard HTML <code>querySelector</code> to dive deeper into the element tree.</p>\n\n<p translation-result=\"on\">这是另一个调用 <code>HTMLElement.querySelector</code> 来获取段落元素并查找横幅文本的测试：</p><p translation-origin=\"off\">Here's another test that calls <code>HTMLElement.querySelector</code> to get the paragraph element and look for the banner text:</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-3\">\nit('should have &#x3C;p> with \"banner works!\"', () => {\n  const bannerElement: HTMLElement = fixture.nativeElement;\n  const p = bannerElement.querySelector('p')!;\n  expect(p.textContent).toEqual('banner works!');\n});\n\n</code-example>\n<a id=\"debug-element\"></a>\n<h3 id=\"debugelement\"><em>DebugElement</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#debugelement\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">Angular 的<em>测试夹具</em>可以直接通过 <code>fixture.nativeElement</code> 提供组件的元素。</p><p translation-origin=\"off\">The Angular <em>fixture</em> provides the component's element directly through the <code>fixture.nativeElement</code>.</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"nativeElement\">\nconst bannerElement: HTMLElement = fixture.nativeElement;\n\n</code-example>\n<p translation-result=\"on\">它实际上是一个便利方法，其最终实现为 <code>fixture.debugElement.nativeElement</code>。</p><p translation-origin=\"off\">This is actually a convenience method, implemented as <code>fixture.debugElement.nativeElement</code>.</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"debugElement-nativeElement\">\nconst bannerDe: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> = fixture.debugElement;\nconst bannerEl: HTMLElement = bannerDe.nativeElement;\n\n</code-example>\n<p translation-result=\"on\">使用这种迂回的路径访问元素是有充分理由的。</p><p translation-origin=\"off\">There's a good reason for this circuitous path to the element.</p>\n\n<p translation-result=\"on\"><code>nativeElement</code> 的属性依赖于其运行时环境。你可以在<em>非浏览器</em>平台上运行这些测试，那些平台上可能没有 DOM，或者其模拟的 DOM 不支持完整的 <code>HTMLElement</code> API。</p><p translation-origin=\"off\">The properties of the <code>nativeElement</code> depend upon the runtime environment.\nYou could be running these tests on a <em>non-browser</em> platform that doesn't have a DOM or\nwhose DOM-emulation doesn't support the full <code>HTMLElement</code> API.</p>\n\n<p translation-result=\"on\">Angular 依靠 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 抽象来在其支持的<em>所有平台上</em>安全地工作。 Angular 不会创建 HTML 元素树，而会创建一个 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 树来封装运行时平台上的<em>原生元素</em>。<code>nativeElement</code> 属性会解包 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 并返回特定于平台的元素对象。</p><p translation-origin=\"off\">Angular relies on the <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> abstraction to work safely across <em>all supported platforms</em>.\nInstead of creating an HTML element tree, Angular creates a <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> tree that wraps the <em>native elements</em> for the runtime platform.\nThe <code>nativeElement</code> property unwraps the <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> and returns the platform-specific element object.</p>\n\n<p translation-result=\"on\">由于本指南的范例测试只能在浏览器中运行，因此 <code>nativeElement</code> 在这些测试中始终是 <code>HTMLElement</code> ，你可以在测试中探索熟悉的方法和属性。</p><p translation-origin=\"off\">Because the sample tests for this guide are designed to run only in a browser,\na <code>nativeElement</code> in these tests is always an <code>HTMLElement</code>\nwhose familiar methods and properties you can explore within a test.</p>\n\n<p translation-result=\"on\">下面是把前述测试用 <code>fixture.debugElement.nativeElement</code> 重新实现的版本：</p><p translation-origin=\"off\">Here's the previous test, re-implemented with <code>fixture.debugElement.nativeElement</code>:</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-4\">\nit('should find the &#x3C;p> with fixture.debugElement.nativeElement)', () => {\n  const bannerDe: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> = fixture.debugElement;\n  const bannerEl: HTMLElement = bannerDe.nativeElement;\n  const p = bannerEl.querySelector('p')!;\n  expect(p.textContent).toEqual('banner works!');\n});\n\n</code-example>\n<p translation-result=\"on\">这些 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 还有另一些在测试中很有用的方法和属性，你可以在本指南的其他地方看到。</p><p translation-origin=\"off\">The <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> has other methods and properties that\nare useful in tests, as you'll see elsewhere in this guide.</p>\n\n<p translation-result=\"on\">你可以从 Angular 的 core 库中导入 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 符号。</p><p translation-origin=\"off\">You import the <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> symbol from the Angular core library.</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"import-debug-element\">\nimport { <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> } from '@angular/core';\n\n</code-example>\n<a id=\"by-css\"></a>\n<h3 id=\"bycss\"><em>By.css()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#bycss\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">虽然本指南中的测试都是在浏览器中运行的，但有些应用可能至少要在某些时候运行在不同的平台上。</p><p translation-origin=\"off\">Although the tests in this guide all run in the browser,\nsome applications might run on a different platform at least some of the time.</p>\n\n<p translation-result=\"on\">例如，作为优化策略的一部分，该组件可能会首先在服务器上渲染，以便在连接不良的设备上更快地启动本应用。服务器端渲染器可能不支持完整的 HTML 元素 API。如果它不支持 <code>querySelector</code>，之前的测试就会失败。</p><p translation-origin=\"off\">For example, the component might render first on the server as part of a strategy to make the application launch faster on poorly connected devices. The server-side renderer might not support the full HTML element API.\nIf it doesn't support <code>querySelector</code>, the previous test could fail.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 提供了适用于其支持的所有平台的查询方法。这些查询方法接受一个<em>谓词</em>函数，当 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 树中的一个节点与选择条件匹配时，该函数返回 <code>true</code>。</p><p translation-origin=\"off\">The <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> offers query methods that work for all supported platforms.\nThese query methods take a <em>predicate</em> function that returns <code>true</code> when a node in the <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> tree matches the selection criteria.</p>\n\n<p translation-result=\"on\">你可以借助从库中为运行时平台导入 <code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> 类来创建一个<em>谓词</em>。这里的 <code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> 是从浏览器平台导入的。</p><p translation-origin=\"off\">You create a <em>predicate</em> with the help of a <code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> class imported from a\nlibrary for the runtime platform. Here's the <code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> import for the browser platform:</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"import-by\">\nimport { <a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a> } from '@angular/platform-browser';\n\n</code-example>\n<p translation-result=\"on\">下面的例子用 <code>DebugElement.query()</code> 和浏览器的 <code>By.css</code> 方法重新实现了前面的测试。</p><p translation-origin=\"off\">The following example re-implements the previous test with\n<code>DebugElement.query()</code> and the browser's <code>By.css</code> method.</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-5\">\nit('should find the &#x3C;p> with fixture.debugElement.query(By.css)', () => {\n  const bannerDe: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> = fixture.debugElement;\n  const paragraphDe = bannerDe.query(By.css('p'));\n  const p: HTMLElement = paragraphDe.nativeElement;\n  expect(p.textContent).toEqual('banner works!');\n});\n\n</code-example>\n<p translation-result=\"on\">一些值得注意的地方：</p><p translation-origin=\"off\">Some noteworthy observations:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">静态方法 <code><a href=\"api/platform-browser/By#css\" class=\"code-anchor\">By.css()</a></code> 会用<a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors\" title=\"CSS 选择器\">标准的 CSS 选择器</a>来选择 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 中的各个节点。</p><p translation-origin=\"off\">The <code><a href=\"api/platform-browser/By#css\" class=\"code-anchor\">By.css()</a></code> static method selects <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> nodes\nwith a <a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors\" title=\"CSS selectors\">standard CSS selector</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">该查询为 p 元素返回了一个 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code></p><p translation-origin=\"off\">The query returns a <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> for the paragraph.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">你必须解包那个结果才能得到 p 元素。</p><p translation-origin=\"off\">You must unwrap that result to get the paragraph element.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">当你使用 CSS 选择器进行过滤并且只测试浏览器<em>原生元素</em>的属性时，用 <code>By.css</code> 方法可能会有点过度。</p><p translation-origin=\"off\">When you're filtering by CSS selector and only testing properties of a browser's <em>native element</em>, the <code>By.css</code> approach might be overkill.</p>\n\n<p translation-result=\"on\">用 <code>HTMLElement</code> 方法（比如 <code>querySelector()</code> 或 <code>querySelectorAll()</code>）进行过滤通常更简单，更清晰。</p><p translation-origin=\"off\">It's often straightforward and more clear to filter with a standard <code>HTMLElement</code> method\nsuch as <code>querySelector()</code> or <code>querySelectorAll()</code>.</p>\n\n\n  \n</div>\n\n\n<!-- links to this doc:\n - api/core/DebugElement\n - guide/testing\n - guide/testing-components-scenarios\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/DebugElement\n - api/core/DebugElement#nativeElement\n - api/core/EventEmitter\n - api/core/Input\n - api/core/OnInit\n - api/core/Output\n - api/core/testing/ComponentFixture\n - api/core/testing/ComponentFixture#nativeElement\n - api/core/testing/TestBed\n - api/core/testing/waitForAsync\n - api/platform-browser/BrowserModule\n - api/platform-browser/By\n - api/platform-browser/By#css\n - guide/lifecycle-hooks\n - guide/testing-components-basics#basics-of-testing-components\n - guide/testing-components-basics#beforeeach\n - guide/testing-components-basics#bycss\n - guide/testing-components-basics#cli-generated-tests\n - guide/testing-components-basics#component-class-testing\n - guide/testing-components-basics#component-dom-testing\n - guide/testing-components-basics#component-fixture\n - guide/testing-components-basics#componentfixture\n - guide/testing-components-basics#createcomponent\n - guide/testing-components-basics#debugelement\n - guide/testing-components-basics#nativeelement\n - guide/testing-components-basics#reduce-the-setup\n - guide/testing-components-scenarios#waitForAsync\n - guide/testing-services\n - https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API\n - https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors\n - https://github.com/ng-docs/angular-cn/edit/aio/aio/content/guide/testing-components-basics.md?message=docs%3A%20请简述你的修改...\n-->"
}