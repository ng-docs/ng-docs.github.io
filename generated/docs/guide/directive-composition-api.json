{"id":"guide/directive-composition-api","title":"Directive composition API","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/angular/angular-cn/edit/cn/aio/content/guide/directive-composition-api.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"directive-composition-api\" translation-result=\"on\">指令组合 API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#directive-composition-api\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Directive composition API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#directive-composition-api\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">Angular 指令提供了一种封装可复用行为的好方法 —— 指令可以将属性、CSS 类和事件侦听器应用于元素。</p><p translation-origin=\"off\">Angular directives offer a great way to encapsulate reusable behaviors— directives can apply\nattributes, CSS classes, and event listeners to an element.</p>\n\n<p translation-result=\"on\"><em>指令组合 API</em> 允许你从组件<em>内部</em>将指令应用于此组件的宿主元素。</p><p translation-origin=\"off\">The <em>directive composition API</em> lets you apply directives to a component's host element from\n<em>within</em> the component.</p>\n\n<h2 id=\"adding-directives-to-a-component\" translation-result=\"on\">向组件添加指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#adding-directives-to-a-component\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Adding directives to a component<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#adding-directives-to-a-component\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你可以通过将 <code>hostDirectives</code> 属性添加到组件的装饰器来将指令应用于组件。我们称这样的指令为<em>宿主指令</em>。</p><p translation-origin=\"off\">You apply directives to a component by adding a <code>hostDirectives</code> property to a component's\ndecorator. We call such directives <em>host directives</em>.</p>\n\n<p translation-result=\"on\">在此示例中，我们将指令 <code>MenuBehavior</code> 应用于 <code>AdminMenu</code> 的宿主元素。这类似于将 <code>MenuBehavior</code> 应用于模板中的 <code>&lt;admin-menu&gt;</code> 元素。</p><p translation-origin=\"off\">In this example, we apply the directive <code>MenuBehavior</code> to the host element of <code>AdminMenu</code>. This\nworks similarly to applying the <code>MenuBehavior</code> to the <code>&lt;admin-menu&gt;</code> element in a template.</p>\n\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [MenuBehavior],\n})\nexport class AdminMenu { }\n</code-example>\n<p translation-result=\"on\">当框架渲染组件时，Angular 还会创建每个宿主指令的实例。指令的宿主绑定被应用于组件的宿主元素。默认情况下，宿主指令的输入和输出不会作为组件公共 API 的一部分公开。有关更多信息，请参阅下面的<a href=\"guide/directive-composition-api#including-inputs-and-outputs\">包含输入属性和输出属性</a>。</p><p translation-origin=\"off\">When the framework renders a component, Angular also creates an instance of each host directive. The\ndirectives' host bindings apply to the component's host element. By default, host directive inputs\nand outputs are not exposed as part of the component's public API. See\n<a href=\"guide/directive-composition-api#including-inputs-and-outputs\">Including inputs and outputs</a> below for more information.</p>\n\n<p translation-result=\"on\"><strong>Angular 会在编译时静态应用宿主指令</strong>。你不能在运行时动态添加指令。</p><p translation-origin=\"off\"><strong>Angular applies host directives statically at compile time.</strong> You cannot dynamically add\ndirectives at runtime.</p>\n\n<p translation-result=\"on\"><strong><code>hostDirectives</code> 中使用的指令必须是 <code>standalone: true</code> 的。</strong></p><p translation-origin=\"off\"><strong>Directives used in <code>hostDirectives</code> must be <code>standalone: true</code>.</strong></p>\n\n<p translation-result=\"on\"><strong>Angular 会忽略 <code>hostDirectives</code> 属性中所应用的那些指令的 <code>selector</code> 。</strong></p><p translation-origin=\"off\"><strong>Angular ignores the <code>selector</code> of directives applied in the <code>hostDirectives</code> property.</strong></p>\n\n<h2 id=\"including-inputs-and-outputs\" translation-result=\"on\">包含输入属性和输出属性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#including-inputs-and-outputs\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Including inputs and outputs<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#including-inputs-and-outputs\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">默认情况下，当你将 <code>hostDirectives</code> 应用于组件时，宿主指令的输入属性和输出属性不会包含在组件的 API 中。你可以通过扩展 <code>hostDirectives</code> 中的条目来在组件的 API 中显式包含输入和输出：</p><p translation-origin=\"off\">When you apply <code>hostDirectives</code> to your component, the inputs and outputs from the host directives\nare not included in your component's API by default. You can explicitly include inputs and outputs\nin your component's API by expanding the entry in <code>hostDirectives</code>:</p>\n\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [{\n    directive: MenuBehavior,\n    inputs: ['menuId'],\n    outputs: ['menuClosed'],\n  }],\n})\nexport class AdminMenu { }\n</code-example>\n<p translation-result=\"on\">通过显式指定输入和输出，使用 <code>hostDirective</code> 的组件的使用者可以将它们绑定在模板中：</p><p translation-origin=\"off\">By explicitly specifying the inputs and outputs, consumers of the component with <code>hostDirective</code> can\nbind them in a template:</p>\n\n<code-example language=\"html\">\n&lt;admin-menu menuId=\"top-menu\" (menuClosed)=\"logMenuClosed()\"&gt;\n</code-example>\n<p translation-result=\"on\">此外，你可以为 <code>hostDirective</code> 的输入和输出起别名来自定义组件的 API：</p><p translation-origin=\"off\">Furthermore, you can alias inputs and outputs from <code>hostDirective</code> to customize the API of your\ncomponent:</p>\n\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [{\n    directive: MenuBehavior,\n    inputs: ['menuId: id'],\n    outputs: ['menuClosed: closed'],\n  }],\n})\nexport class AdminMenu { }\n</code-example>\n<code-example language=\"html\">\n&lt;admin-menu id=\"top-menu\" (closed)=\"logMenuClosed()\"&gt;\n</code-example>\n<h2 id=\"adding-directives-to-another-directive\" translation-result=\"on\">将指令添加到另一个指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#adding-directives-to-another-directive\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Adding directives to another directive<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#adding-directives-to-another-directive\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">除了组件之外，你还可以将 <code>hostDirectives</code> 添加到其他指令。这启用了多个行为的可传递聚合能力。</p><p translation-origin=\"off\">You can also add <code>hostDirectives</code> to other directives, in addition to components. This enables the\ntransitive aggregation of multiple behaviors.</p>\n\n<p translation-result=\"on\">在以下示例中，我们定义了两个指令，<code>Menu</code> 和 <code>Tooltip</code>。然后，我们会在 <code>MenuWithTooltip</code> 中组合这两个指令的行为。最后，我们将 <code>MenuWithTooltip</code> 应用到 <code>SpecializedMenuWithTooltip</code> 上。</p><p translation-origin=\"off\">In the following example, we define two directives, <code>Menu</code> and <code>Tooltip</code>. We then compose the behavior\nof these two directives in <code>MenuWithTooltip</code>. Finally, we apply <code>MenuWithTooltip</code>\nto <code>SpecializedMenuWithTooltip</code>.</p>\n\n<p translation-result=\"on\">在模板中使用 <code>SpecializedMenuWithTooltip</code> 时，它会创建 <code>Menu</code>、<code>Tooltip</code> 和 <code>MenuWithTooltip</code> 的所有实例。这些指令的宿主绑定中的每一个都会应用于 <code>SpecializedMenuWithTooltip</code> 的宿主元素。</p><p translation-origin=\"off\">When <code>SpecializedMenuWithTooltip</code> is used in a template, it creates instances of all of <code>Menu</code>\n, <code>Tooltip</code>, and <code>MenuWithTooltip</code>. Each of these directives' host bindings apply to the host\nelement of <code>SpecializedMenuWithTooltip</code>.</p>\n\n<code-example language=\"typescript\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({...})\nexport class Menu { }\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({...})\nexport class Tooltip { }\n\n// MenuWithTooltip can compose behaviors from <a href=\"api/forms/SelectMultipleControlValueAccessor\" class=\"code-anchor\">multiple</a> other directives\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  hostDirectives: [Tooltip, Menu],\n})\nexport class MenuWithTooltip { }\n\n// CustomWidget can apply the already-composed behaviors from MenuWithTooltip\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  hostDirectives: [MenuWithTooltip],\n})\nexport class SpecializedMenuWithTooltip { }\n</code-example>\n<h2 id=\"host-directive-semantics\">Host directive semantics<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#host-directive-semantics\"><i class=\"material-icons\">link</i></a></h2>\n<p>##宿主指令的语义</p>\n<h3 id=\"directive-execution-order\" translation-result=\"on\">指令的执行顺序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#directive-execution-order\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Directive execution order<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#directive-execution-order\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">宿主指令和直接在模板中使用的组件和指令会经历相同的生命周期。但是，宿主指令总是会在应用它们的组件或指令<em>之前</em>执行它们的构造函数、生命周期钩子和绑定。</p><p translation-origin=\"off\">Host directives go through the same lifecycle as components and directives used directly in a\ntemplate. However, host directives always execute their constructor, lifecycle hooks, and bindings <em>\nbefore</em> the component or directive on which they are applied.</p>\n\n<p translation-result=\"on\">以下示例显示了宿主指令的最小化使用：</p><p translation-origin=\"off\">The following example shows minimal use of a host directive:</p>\n\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [MenuBehavior],\n})\nexport class AdminMenu { }\n</code-example>\n<p translation-result=\"on\">这里的执行顺序是：</p><p translation-origin=\"off\">The order of execution here is:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\"><code>MenuBehavior</code> 实例化</p><p translation-origin=\"off\"><code>MenuBehavior</code> instantiated</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>AdminMenu</code> 实例化</p><p translation-origin=\"off\"><code>AdminMenu</code> instantiated</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>MenuBehavior</code> 接收输入（ <code>ngOnInit</code> ）</p><p translation-origin=\"off\"><code>MenuBehavior</code> receives inputs (<code>ngOnInit</code>)</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>AdminMenu</code> 接收输入 ( <code>ngOnInit</code> )</p><p translation-origin=\"off\"><code>AdminMenu</code> receives inputs (<code>ngOnInit</code>)</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>MenuBehavior</code> 应用宿主绑定</p><p translation-origin=\"off\"><code>MenuBehavior</code> applies host bindings</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>AdminMenu</code> 应用宿主绑定</p><p translation-origin=\"off\"><code>AdminMenu</code> applies host bindings</p>\n\n</li>\n</ol>\n<p translation-result=\"on\">这种操作顺序意味着带有 <code>hostDirectives</code> 的组件可以改写（override）宿主指令指定的任何宿主绑定。</p><p translation-origin=\"off\">This order of operations means that components with <code>hostDirectives</code> can override any host bindings\nspecified by a host directive.</p>\n\n<p translation-result=\"on\">展开宿主指令的嵌套链的操作顺序，如下例所示。</p><p translation-origin=\"off\">This order of operations extends to nested chains of host directives, as shown in the following\nexample.</p>\n\n<code-example language=\"typescript\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({...})\nexport class Tooltip { }\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  hostDirectives: [Tooltip],\n})\nexport class CustomTooltip { }\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  hostDirectives: [CustomTooltip],\n})\nexport class EvenMoreCustomTooltip { }\n</code-example>\n<p translation-result=\"on\">在上面的示例中，执行顺序是：</p><p translation-origin=\"off\">In the example above, the order of execution is:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\"><code>Tooltip</code> 实例化</p><p translation-origin=\"off\"><code>Tooltip</code> instantiated</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>CustomTooltip</code> 实例化</p><p translation-origin=\"off\"><code>CustomTooltip</code> instantiated</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>EvenMoreCustomTooltip</code> 实例化</p><p translation-origin=\"off\"><code>EvenMoreCustomTooltip</code> instantiated</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>Tooltip</code> 接收输入 ( <code>ngOnInit</code> )</p><p translation-origin=\"off\"><code>Tooltip</code> receives inputs (<code>ngOnInit</code>)</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>CustomTooltip</code> 接收输入 ( <code>ngOnInit</code> )</p><p translation-origin=\"off\"><code>CustomTooltip</code> receives inputs (<code>ngOnInit</code>)</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>EvenMoreCustomTooltip</code> 接收输入 ( <code>ngOnInit</code> )</p><p translation-origin=\"off\"><code>EvenMoreCustomTooltip</code> receives inputs (<code>ngOnInit</code>)</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>Tooltip</code> 应用宿主绑定</p><p translation-origin=\"off\"><code>Tooltip</code> applies host bindings</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>CustomTooltip</code> 应用宿主绑定</p><p translation-origin=\"off\"><code>CustomTooltip</code> applies host bindings</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>EvenMoreCustomTooltip</code> 应用宿主绑定</p><p translation-origin=\"off\"><code>EvenMoreCustomTooltip</code> applies host bindings</p>\n\n</li>\n</ol>\n<h3 id=\"dependency-injection\" translation-result=\"on\">依赖注入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#dependency-injection\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Dependency injection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#dependency-injection\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">指定了 <code>hostDirectives</code> 的组件或指令可以注入这些宿主指令的实例，反之亦然。</p><p translation-origin=\"off\">A component or directive that specifies <code>hostDirectives</code> can inject the instances of those host\ndirectives and vice versa.</p>\n\n<p translation-result=\"on\">当把宿主指令应用于组件时，组件和宿主指令都可以定义提供者。</p><p translation-origin=\"off\">When applying host directives to a component, both the component and host directives can define\nproviders.</p>\n\n<p translation-result=\"on\">如果带有 <code>hostDirectives</code> 的组件或指令以及这些宿主指令都提供相同的注入令牌，则带有 <code>hostDirectives</code> 的类定义的提供者会优先于宿主指令定义的提供者。</p><p translation-origin=\"off\">If a component or directive with <code>hostDirectives</code> and those host directives both provide the same\ninjection token, the providers defined by class with <code>hostDirectives</code> take precedence over providers\ndefined by the host directives.</p>\n\n<h3 id=\"performance\" translation-result=\"on\">性能<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#performance\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Performance<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#performance\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">虽然指令组合 API 提供了一个强大的工具来复用常见行为，但过度使用宿主指令会影响应用程序的内存使用。如果你创建使用<em>许多个</em>宿主指令的组件或指令，你可能会无意中让应用程序占用的内存膨胀。</p><p translation-origin=\"off\">While the directive composition API offers a powerful tool for reusing common behaviors, excessive\nuse of host directives can impact your application's memory use. If you create components or\ndirectives that use <em>many</em> host directives, you may inadvertently balloon the memory used by your\napplication.</p>\n\n<p translation-result=\"on\">以下示例显示了一个应用多个宿主指令的组件。</p><p translation-origin=\"off\">The following example shows a component that applies several host directives.</p>\n\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  hostDirectives: [\n    DisabledState,\n    RequiredState,\n    ValidationState,\n    ColorState,\n    RippleBehavior,\n  ],\n})\nexport class CustomCheckbox { }\n</code-example>\n<p translation-result=\"on\">此示例声明了一个自定义复选框组件，其中包含五个宿主指令。这意味着每次 <code>CustomCheckbox</code> 渲染时，Angular 将创建六个对象 —— 组件用一个，每个宿主指令用一个。对于页面上的少量复选框，这不会构成任何重大问题。但是，如果你的页面渲染<em>数百个</em>复选框（例如在表格中），那么你可能会开始看到额外对象分配的影响。始终确保对你的应用程序进行性能剖析，以便为你的用例确定正确的组合模式。</p><p translation-origin=\"off\">This example declares a custom checkbox component that includes five host directives. This\nmeans that Angular will create six objects each time a <code>CustomCheckbox</code> renders— one for the\ncomponent and one for each host directive. For a few checkboxes on a page, this won't pose any\nsignificant issues. However, if your page renders <em>hundreds</em> of checkboxes, such as in a table, then\nyou could start to see an impact of the additional object allocations. Always be sure to profile\nyour application to determine the right composition pattern for your use case.</p>\n\n\n  \n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/Directive\n - api/forms/SelectMultipleControlValueAccessor\n - guide/directive-composition-api#adding-directives-to-a-component\n - guide/directive-composition-api#adding-directives-to-another-directive\n - guide/directive-composition-api#dependency-injection\n - guide/directive-composition-api#directive-composition-api\n - guide/directive-composition-api#directive-execution-order\n - guide/directive-composition-api#host-directive-semantics\n - guide/directive-composition-api#including-inputs-and-outputs\n - guide/directive-composition-api#performance\n - guide/directive-composition-api#依赖注入\n - guide/directive-composition-api#包含输入属性和输出属性\n - guide/directive-composition-api#向组件添加指令\n - guide/directive-composition-api#将指令添加到另一个指令\n - guide/directive-composition-api#性能\n - guide/directive-composition-api#指令的执行顺序\n - guide/directive-composition-api#指令组合-api\n - https://github.com/angular/angular-cn/edit/cn/aio/content/guide/directive-composition-api.md?message=docs%3A%20请简述你的修改...\n-->"}