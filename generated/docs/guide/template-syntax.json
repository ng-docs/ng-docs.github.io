{
  "id": "guide/template-syntax",
  "title": "Template Syntax",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/template-syntax.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"template-syntax\" translation-result=\"on\">模板语法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#template-syntax\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"template-syntax\">Template Syntax<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#template-syntax\"><i class=\"material-icons\">link</i></a></h1>\n\n<style>\n  h4 {font-size: 17px !important; text-transform: none !important;}\n  .syntax { font-family: Consolas, 'Lucida Sans', Courier, sans-serif; color: black; font-size: 85%; }\n  h4 .syntax { font-size: 100%; }\n</style>\n<p translation-result=\"on\">Angular 应用管理着用户之所见和所为，并通过 Component 类的实例（<em>组件</em>）和面向用户的模板交互来实现这一点。</p><p translation-origin=\"off\">The Angular application manages what the user sees and can do, achieving this through the interaction of a\ncomponent class instance (the <em>component</em>) and its user-facing template.</p>\n\n<p translation-result=\"on\">从使用模型-视图-控制器 (MVC) 或模型-视图-视图模型 (MVVM) 的经验中，很多开发人员都熟悉了组件和模板这两个概念。\n在 Angular 中，组件扮演着控制器或视图模型的角色，模板则扮演视图的角色。</p><p translation-origin=\"off\">You may be familiar with the component/template duality from your experience with model-view-controller (MVC) or model-view-viewmodel (MVVM).\nIn Angular, the component plays the part of the controller/viewmodel, and the template represents the view.</p>\n\n<p translation-result=\"on\">这是一篇关于 Angular 模板语言的技术大全。\n它解释了模板语言的基本原理，并描述了你将在文档中其它地方遇到的大部分语法。</p><p translation-origin=\"off\">This page is a comprehensive technical reference to the Angular template language.\nIt explains basic principles of the template language and describes most of the syntax that you'll encounter elsewhere in the documentation.</p>\n\n<p translation-result=\"on\">这里还有很多代码片段用来解释技术点和概念，它们全都在<live-example title=\"模板语法的在线例子\"></live-example>中。</p><p translation-origin=\"off\">Many code snippets illustrate the points and concepts, all of them available\nin the <live-example title=\"Template Syntax Live Code\"></live-example>.</p>\n\n<a id=\"html\"></a>\n<h2 id=\"html-in-templates\" translation-result=\"on\">模板中的 HTML<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#html-in-templates\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"html-in-templates\">HTML in templates<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#html-in-templates\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">HTML 是 Angular 模板的语言。几乎所有的 HTML 语法都是有效的模板语法。\n但值得注意的例外是 <code>&#x3C;script></code> 元素，它被禁用了，以阻止脚本注入攻击的风险。（实际上，<code>&#x3C;script></code> 只是被忽略了。）\n参见<a href=\"guide/security\">安全</a>页了解详情。</p><p translation-origin=\"off\">HTML is the language of the Angular template.\nAlmost all HTML syntax is valid template syntax.\nThe <code>&#x3C;script></code> element is a notable exception;\nit is forbidden, eliminating the risk of script injection attacks.\nIn practice, <code>&#x3C;script></code> is ignored and a warning appears in the browser console.\nSee the <a href=\"guide/security\">Security</a> page for details.</p>\n\n<p translation-result=\"on\">有些合法的 HTML 被用在模板中是没有意义的。<code>&#x3C;html></code>、<code>&#x3C;body></code> 和 <code>&#x3C;base></code> 元素这个舞台上中并没有扮演有用的角色。剩下的所有元素基本上就都一样用了。</p><p translation-origin=\"off\">Some legal HTML doesn't make much sense in a template.\nThe <code>&#x3C;html></code>, <code>&#x3C;body></code>, and <code>&#x3C;base></code> elements have no useful role.\nPretty much everything else is fair game.</p>\n\n<p translation-result=\"on\">可以通过组件和指令来扩展模板中的 HTML 词汇。它们看上去就是新元素和属性。接下来将学习如何通过数据绑定来动态获取/设置 DOM（文档对象模型）的值。</p><p translation-origin=\"off\">You can extend the HTML vocabulary of your templates with components and directives that appear as new elements and attributes.\nIn the following sections, you'll learn how to get and set DOM (Document Object Model) values dynamically through data binding.</p>\n\n<p translation-result=\"on\">首先看看数据绑定的第一种形式 —— 插值表达式，它展示了模板的 HTML 可以有多丰富。</p><p translation-origin=\"off\">Begin with the first form of data binding—interpolation—to see how much richer template HTML can be.</p>\n\n<hr>\n<a id=\"interpolation\"></a>\n<h2 id=\"interpolation-and-template-expressions\" translation-result=\"on\">插值与模板表达式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#interpolation-and-template-expressions\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"interpolation-and-template-expressions\">Interpolation and Template Expressions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#interpolation-and-template-expressions\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">插值能让你把计算后的字符串合并到 HTML 元素标签之间和属性赋值语句内的文本中。模板表达式则是用来供你求出这些字符串的。</p><p translation-origin=\"off\">Interpolation allows you to incorporate calculated strings into the text\nbetween HTML element tags and within attribute assignments. Template\nexpressions are what you use to calculate those strings.</p>\n\n<p translation-result=\"on\">这个关于插值的<live-example></live-example>演示了本节所讲的全部语法和代码片段。</p><p translation-origin=\"off\">The interpolation <live-example></live-example> demonstrates all of\nthe syntax and code snippets described in this section.</p>\n\n<h3 id=\"interpolation-\" translation-result=\"on\">插值表达式 <code>{{...}}</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#interpolation-\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"interpolation-\">Interpolation <code>{{...}}</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#interpolation-\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">所谓 \"插值\" 是指将表达式嵌入到标记文本中。\n默认情况下，插值表达式会用双花括号 <code>{{</code>和 <code>}}</code> 作为分隔符。</p><p translation-origin=\"off\">Interpolation refers to embedding expressions into marked up text.\nBy default, interpolation uses as its delimiter the double curly braces, <code>{{</code> and <code>}}</code>.</p>\n\n<p translation-result=\"on\">在下面的代码片段中，<code>{{ currentCustomer }}</code> 就是插值表达式的例子。</p><p translation-origin=\"off\">In the following snippet, <code>{{ currentCustomer }}</code> is an example of interpolation.</p>\n\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"interpolation-example1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;h3>Current customer: {{ currentCustomer }}&#x3C;/h3>\n\n</code-example>\n<p translation-result=\"on\">插值表达式可以把计算后的字符串插入到 HTML 元素标签内的文本或对标签的属性进行赋值。</p><p translation-origin=\"off\">The text between the braces is often the name of a component\nproperty. Angular replaces that name with the\nstring value of the corresponding component property.</p>\n\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"component-property\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;p>{{title}}&#x3C;/p>\n&#x3C;div>&#x3C;img src=\"{{itemImageUrl}}\">&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\">在括号之间的“素材”，通常是组件属性的名字。Angular 会用组件中相应属性的字符串值，替换这个名字。\n上例中，Angular 计算 <code>title</code> 和 <code>itemImageUrl</code> 属性的值，并把它们填在空白处。\n首先显示粗体的应用标题，然后显示英雄的图片。</p><p translation-origin=\"off\">In the example above, Angular evaluates the <code>title</code> and <code>itemImageUrl</code> properties\nand fills in the blanks, first displaying some title text and then an image.</p>\n\n<p translation-result=\"on\">一般来说，括号间的素材是一个<strong>模板表达式</strong>，Angular 先<strong>对它求值</strong>，再把它<strong>转换成字符串</strong>。\n下列插值表达式通过把括号中的两个数字相加说明了这一点：</p><p translation-origin=\"off\">More generally, the text between the braces is a <strong>template expression</strong>\nthat Angular first <strong>evaluates</strong> and then <strong>converts to a string</strong>.\nThe following interpolation illustrates the point by adding two numbers:</p>\n\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"convert-string\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- \"The sum of 1 + 1 is 2\" -->\n&#x3C;p>The sum of 1 + 1 is {{1 + 1}}.&#x3C;/p>\n\n</code-example>\n<p translation-result=\"on\">这个表达式可以调用宿主组件的方法，就像下面用的 <code>getVal()</code>：</p><p translation-origin=\"off\">The expression can invoke methods of the host component such as <code>getVal()</code> in\nthe following example:</p>\n\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"invoke-method\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- \"The sum of 1 + 1 is not 4\" -->\n&#x3C;p>The sum of 1 + 1 is not {{1 + 1 + getVal()}}.&#x3C;/p>\n\n</code-example>\n<p translation-result=\"on\">Angular 对所有双花括号中的表达式求值，把求值的结果转换成字符串，并把它们跟相邻的字符串字面量连接起来。最后，把这个组合出来的插值结果赋给<strong>元素或指令的属性</strong>。</p><p translation-origin=\"off\">Angular evaluates all expressions in double curly braces,\nconverts the expression results to strings, and links them with neighboring literal strings. Finally,\nit assigns this composite interpolated result to an <strong>element or directive property</strong>.</p>\n\n<p translation-result=\"on\">从表面上看，你就像是在元素标签之间插入了结果并对标签的属性进行了赋值。</p><p translation-origin=\"off\">You appear to be inserting the result between element tags and assigning it to attributes.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">但是，插值其实是一个特殊语法，Angular 会把它转换为属性绑定。</p><p translation-origin=\"off\">However, interpolation is a special syntax that Angular converts into a\nproperty binding.</p>\n\n<p translation-result=\"on\">如果你想用别的分隔符来代替 <code>{{</code> 和 <code>}}</code>，也可以通过 <code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 元数据中的 <a href=\"api/core/Component#interpolation\">interpolation</a> 选项来配置插值分隔符。</p><p translation-origin=\"off\">If you'd like to use something other than <code>{{</code> and <code>}}</code>, you can\nconfigure the interpolation delimiter via the\n<a href=\"api/core/Component#interpolation\">interpolation</a>\noption in the <code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> metadata.</p>\n\n</div>\n<h3 id=\"template-expressions\" translation-result=\"on\">模板表达式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#template-expressions\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"template-expressions\">Template expressions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#template-expressions\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">模板<strong>表达式</strong>会产生一个值，并出现在双花括号 <code>{{ }}</code> 中。\nAngular 执行这个表达式，并把它赋值给绑定目标的属性，这个绑定目标可能是 HTML 元素、组件或指令。</p><p translation-origin=\"off\">a template <strong>expression</strong> produces a value and appears within the double\ncurly braces, <code>{{ }}</code>.\nAngular executes the expression and assigns it to a property of a binding target;\nthe target could be an HTML element, a component, or a directive.</p>\n\n<p translation-result=\"on\"><code>{{1 + 1}}</code> 中所包含的模板表达式是 <code>1 + 1</code>。\n在属性绑定中会再次看到模板表达式，它出现在 <code>=</code> 右侧的引号中，就像这样：<code>[property]=\"expression\"</code>。</p><p translation-origin=\"off\">The interpolation braces in <code>{{1 + 1}}</code> surround the template expression <code>1 + 1</code>.\nIn the property binding,\na template expression appears in quotes to the right of the <code>=</code> symbol as in <code>[property]=\"expression\"</code>.</p>\n\n<p translation-result=\"on\">在语法上，模板表达式与 JavaScript 很像。很多 JavaScript 表达式都是合法的模板表达式，但也有一些例外。</p><p translation-origin=\"off\">In terms of syntax, template expressions are similar to JavaScript.\nMany JavaScript expressions are legal template expressions, with a few exceptions.</p>\n\n<p translation-result=\"on\">你不能使用那些具有或可能引发副作用的 JavaScript 表达式，包括： </p><p translation-origin=\"off\">You can't use JavaScript expressions that have or promote side effects,\nincluding:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">赋值 (<code>=</code>, <code>+=</code>, <code>-=</code>, <code>...</code>)</p><p translation-origin=\"off\">Assignments (<code>=</code>, <code>+=</code>, <code>-=</code>, <code>...</code>)</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>new</code>、<code>typeof</code>、<code>instanceof</code> 等操作符。</p><p translation-origin=\"off\">Operators such as <code>new</code>, <code>typeof</code>, <code>instanceof</code>, etc.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">使用 <code>;</code> 或 <code>,</code> 串联起来的表达式</p><p translation-origin=\"off\">Chaining expressions with <code>;</code> or <code>,</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">自增和自减运算符：<code>++</code> 和 <code>--</code></p><p translation-origin=\"off\">The increment and decrement operators <code>++</code> and <code>--</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">一些 ES2015+ 版本的操作符</p><p translation-origin=\"off\">Some of the ES2015+ operators</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">和 JavaScript 语法的其它显著差异包括：</p><p translation-origin=\"off\">Other notable differences from JavaScript syntax include:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">不支持位运算，比如 <code>|</code> 和 <code>&#x26;</code></p><p translation-origin=\"off\">No support for the bitwise operators such as <code>|</code> and <code>&#x26;</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">新的<a href=\"guide/template-syntax#expression-operators\">模板表达式运算符</a>，比如 <code>|</code>、<code>?.</code> 和 <code>!</code>。</p><p translation-origin=\"off\">New template expression operators, such as <code>|</code>, <code>?.</code> and <code>!</code></p>\n\n</li>\n</ul>\n<!-- link to: guide/template-syntax#expression-operators -->\n<h3 id=\"expression-context\" translation-result=\"on\">表达式上下文<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#expression-context\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"expression-context\">Expression context<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#expression-context\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">典型的<em>表达式上下文</em>就是这个<strong>组件实例</strong>，它是各种绑定值的来源。\n在下面的代码片段中，双花括号中的 <code>recommended</code> 和引号中的 <code>itemImageUrl2</code> 所引用的都是 <code>AppComponent</code> 中的属性。</p><p translation-origin=\"off\">The <em>expression context</em> is typically the <em>component</em> instance.\nIn the following snippets, the <code>recommended</code> within double curly braces and the\n<code>itemImageUrl2</code> in quotes refer to properties of the <code>AppComponent</code>.</p>\n\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"component-context\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;h4>{{recommended}}&#x3C;/h4>\n&#x3C;img [src]=\"itemImageUrl2\">\n\n</code-example>\n<p translation-result=\"on\">表达式的上下文可以包括组件之外的对象。\n比如<a href=\"guide/template-syntax#template-input-variable\">模板输入变量</a> (<code>let customer</code>)和<a href=\"guide/template-syntax#ref-vars\">模板引用变量</a>(<code>#customerInput</code>)就是备选的上下文对象之一。</p><p translation-origin=\"off\">An expression may also refer to properties of the <em>template's</em> context\nsuch as a template input variable,\n<code>let customer</code>, or a template reference variable, <code>#customerInput</code>.</p>\n\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"template-input-variable\" header=\"src/app/app.component.html (template input variable)\" linenums=\"false\">\n&#x3C;ul>\n  &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let customer of customers\">{{customer.name}}&#x3C;/li>\n&#x3C;/ul>\n\n</code-example>\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"template-reference-variable\" header=\"src/app/app.component.html (template reference variable)\" linenums=\"false\">\n&#x3C;label><a href=\"api/core/Type\" class=\"code-anchor\">Type</a> something:\n  &#x3C;input #customerInput>{{customerInput.value}}\n&#x3C;/label>\n\n</code-example>\n<p translation-result=\"on\">表达式中的上下文变量是由<em>模板变量</em>、指令的<em>上下文变量</em>（如果有）和组件的<em>成员</em>叠加而成的。\n如果你要引用的变量名存在于一个以上的命名空间中，那么，模板变量是最优先的，其次是指令的上下文变量，最后是组件的成员。</p><p translation-origin=\"off\">The context for terms in an expression is a blend of the <em>template variables</em>,\nthe directive's <em>context</em> object (if it has one), and the component's <em>members</em>.\nIf you reference a name that belongs to more than one of these namespaces,\nthe template variable name takes precedence, followed by a name in the directive's <em>context</em>,\nand, lastly, the component's member names.</p>\n\n<p translation-result=\"on\">上一个例子中就体现了这种命名冲突。组件具有一个名叫 <code>customer</code> 的属性，而 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 声明了一个也叫 <code>customer</code> 的模板变量。</p><p translation-origin=\"off\">The previous example presents such a name collision. The component has a <code>customer</code>\nproperty and the <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> defines a <code>customer</code> template variable.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">在 <code>{{customer.name}}</code> 表达式中的 <code>customer</code> 实际引用的是模板变量，而不是组件的属性。</p><p translation-origin=\"off\">The <code>customer</code> in <code>{{customer.name}}</code>\nrefers to the template input variable, not the component's property.</p>\n\n<p translation-result=\"on\">模板表达式不能引用全局命名空间中的任何东西，比如 <code>window</code> 或 <code><a href=\"api/platform-server/PlatformConfig#document\" class=\"code-anchor\">document</a></code>。它们也不能调用 <code>console.log</code> 或 <code>Math.max</code>。\n它们只能引用表达式上下文中的成员。</p><p translation-origin=\"off\">Template expressions cannot refer to anything in\nthe global namespace, except <code>undefined</code>. They can't refer to\n<code>window</code> or <code><a href=\"api/platform-server/PlatformConfig#document\" class=\"code-anchor\">document</a></code>. Additionally, they\ncan't call <code>console.log()</code> or <code>Math.max()</code> and they are restricted to referencing\nmembers of the expression context.</p>\n\n</div>\n<h3 id=\"expression-guidelines\" translation-result=\"on\">表达式使用指南<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#expression-guidelines\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"expression-guidelines\">Expression guidelines<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#expression-guidelines\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">当使用模板表达式时，请遵循下列指南：</p><p translation-origin=\"off\">When using template expressions follow these guidelines:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> <a href=\"guide/template-syntax#no-visible-side-effects\">没有可见的副作用</a></p><p translation-origin=\"off\"><a href=\"guide/template-syntax#no-visible-side-effects\">No visible side effects</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"> <a href=\"guide/template-syntax#quick-execution\">执行迅速</a></p><p translation-origin=\"off\"><a href=\"guide/template-syntax#quick-execution\">Quick execution</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"> <a href=\"guide/template-syntax#simplicity\">非常简单</a></p><p translation-origin=\"off\"><a href=\"guide/template-syntax#simplicity\">Simplicity</a></p>\n\n</li>\n</ul>\n<h3 id=\"no-visible-side-effects\" translation-result=\"on\">没有可见的副作用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#no-visible-side-effects\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"no-visible-side-effects\">No visible side effects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#no-visible-side-effects\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">模板表达式除了目标属性的值以外，不应该改变应用的任何状态。</p><p translation-origin=\"off\">A template expression should not change any application state other than the value of the\ntarget property.</p>\n\n<p translation-result=\"on\">这条规则是 Angular “单向数据流”策略的基础。\n永远不用担心读取组件值可能改变另外的显示值。\n在一次单独的渲染过程中，视图应该总是稳定的。</p><p translation-origin=\"off\">This rule is essential to Angular's \"unidirectional data flow\" policy.\nYou should never worry that reading a component value might change some other displayed value.\nThe view should be stable throughout a single rendering pass.</p>\n\n<p translation-result=\"on\">最好使用<a href=\"https://en.wikipedia.org/wiki/Idempotence\">幂等的</a>表达式，因为它没有副作用，并且能提升 Angular 变更检测的性能。</p><p translation-origin=\"off\">An <a href=\"https://en.wikipedia.org/wiki/Idempotence\">idempotent</a> expression is ideal because\nit is free of side effects and improves Angular's change detection performance.</p>\n\n<p translation-result=\"on\">在 Angular 的术语中，幂等的表达式应该总是返回<em>完全相同的东西</em>，直到某个依赖值发生改变。</p><p translation-origin=\"off\">In Angular terms, an idempotent expression always returns\n<em>exactly the same thing</em> until\none of its dependent values changes.</p>\n\n<p translation-result=\"on\">在单独的一次事件循环中，被依赖的值不应该改变。\n如果幂等的表达式返回一个字符串或数字，连续调用它两次，也应该返回相同的字符串或数字。\n如果幂等的表达式返回一个对象（包括 <code>Date</code> 或 <code>Array</code>），连续调用它两次，也应该返回同一个对象的<em>引用</em>。</p><p translation-origin=\"off\">Dependent values should not change during a single turn of the event loop.\nIf an idempotent expression returns a string or a number, it returns the same string or number when called twice in a row. If the expression returns an object, including an <code>array</code>, it returns the same object <em>reference</em> when called twice in a row.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">当用于 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 时，这种行为有一个例外。<code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 具有一个 <code>trackBy</code> 功能，它可以在迭代时把两个引用不等的对象视作同一个。</p><p translation-origin=\"off\">There is one exception to this behavior that applies to <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>. <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> has <code>trackBy</code> functionality that can deal with referential inequality of objects that when iterating over them.</p>\n\n<p translation-result=\"on\">欲知详情，参见<a href=\"guide/template-syntax#ngfor-with-trackby\">带 <code>trackBy</code> 的 *ngFor</a> 部分。</p><p translation-origin=\"off\">For more information, see the <a href=\"guide/template-syntax#ngfor-with-trackby\">*ngFor with <code>trackBy</code></a> section of this guide.</p>\n\n</div>\n<h3 id=\"quick-execution\" translation-result=\"on\">执行迅速<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#quick-execution\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"quick-execution\">Quick execution<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#quick-execution\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">Angular 会在每个变更检测周期后执行模板表达式。\n变更检测周期会被多种异步活动触发，比如 Promise 解析、HTTP 结果、定时器时间、按键或鼠标移动。</p><p translation-origin=\"off\">Angular executes template expressions after every change detection cycle.\nChange detection cycles are triggered by many asynchronous activities such as\npromise resolutions, HTTP results, timer events, key presses and mouse moves.</p>\n\n<p translation-result=\"on\">表达式应该快速结束，否则用户就会感到拖沓，特别是在较慢的设备上。\n当计算代价较高时，应该考虑缓存那些从其它值计算得出的值。</p><p translation-origin=\"off\">Expressions should finish quickly or the user experience may drag, especially on slower devices.\nConsider caching values when their computation is expensive.</p>\n\n<h3 id=\"simplicity\" translation-result=\"on\">非常简单<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#simplicity\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"simplicity\">Simplicity<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#simplicity\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">虽然也可以写复杂的模板表达式，不过最好避免那样做。</p><p translation-origin=\"off\">Although it's possible to write complex template expressions, it's a better\npractice to avoid them.</p>\n\n<p translation-result=\"on\">属性名或方法调用应该是常态，但偶然使用逻辑取反 <code>!</code> 也是可以的。\n其它情况下，应该把应用程序和业务逻辑限制在组件中，这样它才能更容易开发和测试。</p><p translation-origin=\"off\">A property name or method call should be the norm, but an occasional Boolean negation, <code>!</code>, is OK.\nOtherwise, confine application and business logic to the component,\nwhere it is easier to develop and test.</p>\n\n<!-- end of Interpolation doc -->\n<hr>\n<a id=\"template-statements\"></a>\n<h2 id=\"template-statements\" translation-result=\"on\">模板语句<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#template-statements\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"template-statements\">Template statements<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#template-statements\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">模板<strong>语句</strong>用来响应由绑定目标（如 HTML 元素、组件或指令）触发的<strong>事件</strong>。\n模板语句将在<a href=\"guide/template-syntax#event-binding\">事件绑定</a>一节看到，它出现在 <code>=</code> 号右侧的引号中，就像这样：<code>(event)=\"statement\"</code>。</p><p translation-origin=\"off\">A template <strong>statement</strong> responds to an <strong>event</strong> raised by a binding target\nsuch as an element, component, or directive.\nYou'll see template statements in the <a href=\"guide/template-syntax#event-binding\">event binding</a> section,\nappearing in quotes to the right of the <code>=</code> symbol as in <code>(event)=\"statement\"</code>.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"context-component-statement\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button (click)=\"deleteHero()\">Delete hero&#x3C;/button>\n\n</code-example>\n<p translation-result=\"on\">模板语句<em>有副作用</em>。\n这是事件处理的关键。因为你要根据用户的输入更新应用状态。</p><p translation-origin=\"off\">A template statement <em>has a side effect</em>.\nThat's the whole point of an event.\nIt's how you update application state from user action.</p>\n\n<p translation-result=\"on\">响应事件是 Angular 中“单向数据流”的另一面。\n在一次事件循环中，可以随意改变任何地方的任何东西。</p><p translation-origin=\"off\">Responding to events is the other side of Angular's \"unidirectional data flow\".\nYou're free to change anything, anywhere, during this turn of the event loop.</p>\n\n<p translation-result=\"on\">和模板表达式一样，模板<em>语句</em>使用的语言也像 JavaScript。\n模板语句解析器和模板表达式解析器有所不同，特别之处在于它支持基本赋值 (<code>=</code>) 和表达式链 (<code>;</code> 和 <code>,</code>)。</p><p translation-origin=\"off\">Like template expressions, template <em>statements</em> use a language that looks like JavaScript.\nThe template statement parser differs from the template expression parser and\nspecifically supports both basic assignment (<code>=</code>) and chaining expressions\n(with <code>;</code> or <code>,</code>).</p>\n\n<p translation-result=\"on\">然而，某些 JavaScript 语法仍然是不允许的：</p><p translation-origin=\"off\">However, certain JavaScript syntax is not allowed:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> <code>new</code> 运算符</p><p translation-origin=\"off\"><code>new</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 自增和自减运算符：<code>++</code> 和 <code>--</code></p><p translation-origin=\"off\">increment and decrement operators, <code>++</code> and <code>--</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 操作并赋值，例如 <code>+=</code> 和 <code>-=</code></p><p translation-origin=\"off\">operator assignment, such as <code>+=</code> and <code>-=</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 位操作符 <code>|</code> 和 <code>&#x26;</code></p><p translation-origin=\"off\">the bitwise operators <code>|</code> and <code>&#x26;</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\"> <a href=\"guide/template-syntax#expression-operators\">模板表达式运算符</a></p><p translation-origin=\"off\">the <a href=\"guide/template-syntax#expression-operators\">template expression operators</a></p>\n\n</li>\n</ul>\n<h3 id=\"statement-context\" translation-result=\"on\">语句上下文<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#statement-context\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"statement-context\">Statement context<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#statement-context\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">和表达式中一样，语句只能引用语句上下文中 —— 通常是正在绑定事件的那个<strong>组件实例</strong>。</p><p translation-origin=\"off\">As with expressions, statements can refer only to what's in the statement context\nsuch as an event handling method of the component instance.</p>\n\n<p translation-result=\"on\">典型的<em>语句上下文</em>就是当前组件的实例。\n<code>(click)=\"deleteHero()\"</code> 中的 <em>deleteHero</em> 就是这个数据绑定组件上的一个方法。</p><p translation-origin=\"off\">The <em>statement context</em> is typically the component instance.\nThe <em>deleteHero</em> in <code>(click)=\"deleteHero()\"</code> is a method of the data-bound component.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"context-component-statement\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button (click)=\"deleteHero()\">Delete hero&#x3C;/button>\n\n</code-example>\n<p translation-result=\"on\">语句上下文可以引用模板自身上下文中的属性。\n在下面的例子中，就把模板的 <code>$event</code> 对象、<a href=\"guide/template-syntax#template-input-variable\">模板输入变量</a> (<code>let hero</code>)和<a href=\"guide/template-syntax#ref-vars\">模板引用变量</a> (<code>#heroForm</code>)传给了组件中的一个事件处理器方法。</p><p translation-origin=\"off\">The statement context may also refer to properties of the template's own context.\nIn the following examples, the template <code>$event</code> object,\na <a href=\"guide/template-syntax#template-input-variable\">template input variable</a> (<code>let hero</code>),\nand a <a href=\"guide/template-syntax#ref-vars\">template reference variable</a> (<code>#heroForm</code>)\nare passed to an event handling method of the component.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"context-var-statement\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button (click)=\"onSave($event)\">Save&#x3C;/button>\n&#x3C;button *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" (click)=\"deleteHero(hero)\">{{hero.name}}&#x3C;/button>\n&#x3C;form #heroForm (ngSubmit)=\"onSubmit(heroForm)\"> ... &#x3C;/form>\n\n</code-example>\n<p translation-result=\"on\">模板上下文中的变量名的优先级高于组件上下文中的变量名。在上面的 <code>deleteHero(hero)</code> 中，<code>hero</code> 是一个模板输入变量，而不是组件中的 <code>hero</code> 属性。</p><p translation-origin=\"off\">Template context names take precedence over component context names.\nIn <code>deleteHero(hero)</code> above, the <code>hero</code> is the template input variable,\nnot the component's <code>hero</code> property.</p>\n\n<p translation-result=\"on\">模板语句不能引用全局命名空间的任何东西。比如不能引用 <code>window</code> 或 <code><a href=\"api/platform-server/PlatformConfig#document\" class=\"code-anchor\">document</a></code>，也不能调用 <code>console.log</code> 或 <code>Math.max</code>。</p><p translation-origin=\"off\">Template statements cannot refer to anything in the global namespace. They\ncan't refer to <code>window</code> or <code><a href=\"api/platform-server/PlatformConfig#document\" class=\"code-anchor\">document</a></code>.\nThey can't call <code>console.log</code> or <code>Math.max</code>.</p>\n\n<h3 id=\"statement-guidelines\" translation-result=\"on\">语句指南<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#statement-guidelines\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"statement-guidelines\">Statement guidelines<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#statement-guidelines\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">和表达式一样，避免写复杂的模板语句。\n常规是函数调用或者属性赋值。</p><p translation-origin=\"off\">As with expressions, avoid writing complex template statements.\nA method call or simple property assignment should be the norm.</p>\n\n<p translation-result=\"on\">现在，对模板表达式和语句有了一点感觉了吧。\n除插值外，还有各种各样的数据绑定语法，是学习它们是时候了。</p><p translation-origin=\"off\">Now that you have a feel for template expressions and statements,\nyou're ready to learn about the varieties of data binding syntax beyond interpolation.</p>\n\n<hr>\n<a id=\"binding-syntax\"></a>\n<h2 id=\"binding-syntax-an-overview\" translation-result=\"on\">绑定语法：概览<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#binding-syntax-an-overview\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"binding-syntax-an-overview\">Binding syntax: An overview<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#binding-syntax-an-overview\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">数据绑定是一种机制，用来协调用户所见和应用数据。\n虽然你能往 HTML 推送值或者从 HTML 拉取值，\n但如果把这些琐事交给数据绑定框架处理，\n应用会更容易编写、阅读和维护。\n只要简单地在绑定源和目标 HTML 元素之间声明绑定，框架就会完成这项工作。</p><p translation-origin=\"off\">Data binding is a mechanism for coordinating what users see, with application data values.\nWhile you could push values to and pull values from HTML,\nthe application is easier to write, read, and maintain if you turn these chores over to a binding framework.\nYou simply declare bindings between binding sources and target HTML elements and let the framework do the work.</p>\n\n<p translation-result=\"on\">Angular 提供了各种各样的数据绑定，本章将逐一讨论。\n先从高层视角来看看 Angular 数据绑定及其语法。</p><p translation-origin=\"off\">Angular provides many kinds of data binding.\nThis guide covers most of them, after a high-level view of Angular data binding and its syntax.</p>\n\n<p translation-result=\"on\">绑定的类型可以根据数据流的方向分成三类：\n<em>从数据源到视图</em>、<em>从视图到数据源</em>以及双向的<em>从视图到数据源再到视图</em>。</p><p translation-origin=\"off\">Binding types can be grouped into three categories distinguished by the direction of data flow:\nfrom the <em>source-to-view</em>, from <em>view-to-source</em>, and in the two-way sequence: <em>view-to-source-to-view</em>:</p>\n\n<style>\n  td, th {vertical-align: top}\n</style>\n<table width=\"100%\">\n  <colgroup><col width=\"30%\">\n  \n  <col width=\"50%\">\n  \n  <col width=\"20%\">\n  \n  </colgroup><tbody><tr>\n    <th>\n<p translation-result=\"on\">      数据方向</p><p translation-origin=\"off\">      Data direction</p>\n\n    </th>\n    <th>\n<p translation-result=\"on\">      语法</p><p translation-origin=\"off\">      Syntax</p>\n\n    </th>\n    <th>\n<p translation-result=\"on\">      绑定类型</p><p translation-origin=\"off\">      Type</p>\n\n    </th>\n  </tr>\n  <tr>\n    <td>\n<p translation-result=\"on\">      单向<br>从数据源<br>到视图</p><p translation-origin=\"off\">      One-way<br>from data source<br>to view target</p>\n\n    </td>\n    <td>\n      <code-example>\n        {{expression}}\n        [<a href=\"api/router/RouterLinkWithHref#target\" class=\"code-anchor\">target</a>]=\"expression\"\n        bind-target=\"expression\"\n      </code-example>\n    </td>\n    <td>\n<p translation-result=\"on\">      插值<br>\n属性<br>\nAttribute<br>\nCSS 类<br>\n样式</p><p translation-origin=\"off\">      Interpolation<br>\nProperty<br>\nAttribute<br>\nClass<br>\nStyle</p>\n\n    </td>\n    </tr><tr>\n      <td>\n<p translation-result=\"on\">        从视图到数据源的单向绑定</p><p translation-origin=\"off\">        One-way<br>from view target<br>to data source</p>\n\n      </td>\n      <td>\n        <code-example>\n          (<a href=\"api/router/RouterLinkWithHref#target\" class=\"code-anchor\">target</a>)=\"statement\"\n          on-target=\"statement\"\n        </code-example>\n      </td>\n      <td>\n<p translation-result=\"on\">        事件</p><p translation-origin=\"off\">        Event</p>\n\n      </td>\n    </tr>\n    <tr>\n      <td>\n<p translation-result=\"on\">        双向</p><p translation-origin=\"off\">        Two-way</p>\n\n      </td>\n      <td>\n        <code-example>\n          [(<a href=\"api/router/RouterLinkWithHref#target\" class=\"code-anchor\">target</a>)]=\"expression\"\n          bindon-target=\"expression\"\n        </code-example>\n      </td>\n      <td>\n<p translation-result=\"on\">        双向</p><p translation-origin=\"off\">        Two-way</p>\n\n      </td>\n    </tr>\n  \n</tbody></table>\n<div class=\"alert is-important\">\n<p>译注：由于 HTML attribute 和 DOM property 在中文中都被翻译成了“属性”，无法区分，\n而接下来的部分重点是对它们进行比较。</p>\n<p>我们无法改变历史，因此，在本章的翻译中，保留了它们的英文形式，不加翻译，以免混淆。\n本章中，如果提到“属性”的地方，一定是指 property，因为在 Angular 中，实际上很少涉及 attribute。</p>\n<p>但在其它章节中，为简单起见，凡是能通过上下文明显区分开的，就仍统一译为“属性”，\n区分不明显的，会加注英文。</p>\n</div>\n<p translation-result=\"on\">除了插值之外的绑定类型，在等号左边是<strong>目标名</strong>，\n无论是包在括号中 (<code>[]</code>、<code>()</code>) 还是用前缀形式 (<code>bind-</code>、<code>on-</code>、<code>bindon-</code>) 。</p><p translation-origin=\"off\">Binding types other than interpolation have a <strong>target name</strong> to the left of the equal sign,\neither surrounded by punctuation (<code>[]</code>, <code>()</code>) or preceded by a prefix (<code>bind-</code>, <code>on-</code>, <code>bindon-</code>).</p>\n\n<p translation-result=\"on\">这个目标名就是<em>属性（Property）</em>的名字。它可能看起来像是<em>元素属性（Attribute）</em>的名字，但它不是。\n要理解它们的不同点，你必须尝试用另一种方式来审视模板中的 HTML。</p><p translation-origin=\"off\">The target name is the name of a <em>property</em>. It may look like the name of an <em>attribute</em> but it never is.\nTo appreciate the difference, you must develop a new way to think about template HTML.</p>\n\n<h3 id=\"a-new-mental-model\" translation-result=\"on\">新的思维模型<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#a-new-mental-model\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"a-new-mental-model\">A new mental model<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#a-new-mental-model\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">数据绑定的威力和允许用自定义标记扩展 HTML 词汇的能力，会让你把模板 HTML 当成 <em>HTML+</em>。</p><p translation-origin=\"off\">With all the power of data binding and the ability to extend the HTML vocabulary\nwith custom markup, it is tempting to think of template HTML as <em>HTML Plus</em>.</p>\n\n<p translation-result=\"on\">它其实<em>就是</em> HTML+。\n但它也跟你曾使用的 HTML 有着显著的不同。\n这里需要一种新的思维模型。</p><p translation-origin=\"off\">It really <em>is</em> HTML Plus.\nBut it's also significantly different than the HTML you're used to.\nIt requires a new mental model.</p>\n\n<p translation-result=\"on\">在正常的 HTML 开发过程中，你使用 HTML 元素来创建视觉结构，\n通过把字符串常量设置到元素的 attribute 来修改那些元素。</p><p translation-origin=\"off\">In the normal course of HTML development, you create a visual structure with HTML elements, and\nyou modify those elements by setting element attributes with string constants.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"img+button\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div class=\"special\">Mental Model&#x3C;/div>\n&#x3C;img src=\"assets/images/hero.png\">\n&#x3C;button disabled>Save&#x3C;/button>\n\n</code-example>\n<p translation-result=\"on\">在 Angular 模板中，你仍使用同样的方式创建结构和初始化 attribute 值。</p><p translation-origin=\"off\">You still create a structure and initialize attribute values this way in Angular templates.</p>\n\n<p translation-result=\"on\">然后，用封装了 HTML 的组件创建新元素，并把它们当作原生 HTML 元素在模板中使用。</p><p translation-origin=\"off\">Then you learn to create new elements with components that encapsulate HTML\nand drop them into templates as if they were native HTML elements.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"hero-detail-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- Normal <a href=\"api/core/SecurityContext#HTML\" class=\"code-anchor\">HTML</a> -->\n&#x3C;div class=\"special\">Mental Model&#x3C;/div>\n&#x3C;!-- Wow! A new element! -->\n&#x3C;app-hero-detail>&#x3C;/app-hero-detail>\n\n</code-example>\n<p translation-result=\"on\">这就是 HTML+。</p><p translation-origin=\"off\">That's HTML Plus.</p>\n\n<p translation-result=\"on\">现在开始学习数据绑定。你碰到的第一种数据绑定是这样的：</p><p translation-origin=\"off\">Then you learn about data binding. The first binding you meet might look like this:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"disabled-button-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- Bind button disabled <a href=\"api/animations/state\" class=\"code-anchor\">state</a> to `isUnchanged` property -->\n&#x3C;button [disabled]=\"isUnchanged\">Save&#x3C;/button>\n\n</code-example>\n<p translation-result=\"on\">过会儿再认识那个怪异的方括号记法。直觉告诉你，你正在绑定按钮的 <code>disabled</code> attribute。\n并把它设置为组件的 <code>isUnchanged</code> 属性的当前值。</p><p translation-origin=\"off\">You'll get to that peculiar bracket notation in a moment. Looking beyond it,\nyour intuition suggests that you're binding to the button's <code>disabled</code> attribute and setting\nit to the current value of the component's <code>isUnchanged</code> property.</p>\n\n<p translation-result=\"on\">但你的直觉是错的！日常的 HTML 思维模式在误导着你。\n实际上，一旦开始数据绑定，就不再跟 HTML attribute 打交道了。\n这里不是设置 attribute，而是设置 DOM 元素、组件和指令的 property。</p><p translation-origin=\"off\">Your intuition is incorrect! Your everyday HTML mental model is misleading.\nIn fact, once you start data binding, you are no longer working with HTML <em>attributes</em>. You aren't setting attributes.\nYou are setting the <em>properties</em> of DOM elements, components, and directives.</p>\n\n<div class=\"alert is-helpful\">\n<h3 id=\"html-attribute-vs-dom-property\" translation-result=\"on\">HTML attribute 与 DOM property 的对比<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#html-attribute-vs-dom-property\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"html-attribute-vs-dom-property\">HTML attribute vs. DOM property<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#html-attribute-vs-dom-property\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要想理解 Angular 绑定如何工作，重点是搞清 HTML attribute 和 DOM property 之间的区别。</p><p translation-origin=\"off\">The distinction between an HTML attribute and a DOM property is crucial to understanding how Angular binding works.</p>\n\n<p translation-result=\"on\"><strong>attribute 是由 HTML 定义的。property 是由 DOM (Document Object Model) 定义的。</strong></p><p translation-origin=\"off\"><strong>Attributes are defined by HTML. Properties are defined by the DOM (Document Object Model).</strong></p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> 少量 HTML attribute 和 property 之间有着 1:1 的映射，如 <code>id</code>。</p><p translation-origin=\"off\">A few HTML attributes have 1:1 mapping to properties. <code>id</code> is one example.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 有些 HTML attribute 没有对应的 property，如 <code>colspan</code>。</p><p translation-origin=\"off\">Some HTML attributes don't have corresponding properties. <code>colspan</code> is one example.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 有些 DOM property 没有对应的 attribute，如 <code>textContent</code>。</p><p translation-origin=\"off\">Some DOM properties don't have corresponding attributes. <code>textContent</code> is one example.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 大量 HTML attribute 看起来映射到了 property…… 但却不像你想的那样！</p><p translation-origin=\"off\">Many HTML attributes appear to map to properties ... but not in the way you might think!</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">最后一类尤其让人困惑…… 除非你能理解这个普遍原则：</p><p translation-origin=\"off\">That last category is confusing until you grasp this general rule:</p>\n\n<p translation-result=\"on\"><strong>attribute <em>初始化</em> DOM property，然后它们的任务就完成了。property 的值可以改变；attribute 的值不能改变。</strong></p><p translation-origin=\"off\"><strong>Attributes <em>initialize</em> DOM properties and then they are done.\nProperty values can change; attribute values can't.</strong></p>\n\n<p translation-result=\"on\">例如，当浏览器渲染 <code>&#x3C;input type=\"text\" value=\"Bob\"></code> 时，它将创建相应 DOM 节点，\n它的 <code>value</code> 这个 property 被<em>初始化为</em> “Bob”。</p><p translation-origin=\"off\">For example, when the browser renders <code>&#x3C;input type=\"text\" value=\"Bob\"></code>, it creates a\ncorresponding DOM node with a <code>value</code> property <em>initialized</em> to \"Bob\".</p>\n\n<p translation-result=\"on\">当用户在输入框中输入 “Sally” 时，DOM 元素的 <code>value</code> 这个 <em>property</em> 变成了 “Sally”。\n但是该 HTML 的 <code>value</code> 这个 <em>attribute</em> 保持不变。如果你读取 input 元素的 attribute，就会发现确实没变：\n<code>input.getAttribute('value') // 返回 \"Bob\"</code>。</p><p translation-origin=\"off\">When the user enters \"Sally\" into the input box, the DOM element <code>value</code> <em>property</em> becomes \"Sally\".\nBut the HTML <code>value</code> <em>attribute</em> remains unchanged as you discover if you ask the input element\nabout that attribute: <code>input.getAttribute('value')</code> returns \"Bob\".</p>\n\n<p translation-result=\"on\">HTML 的 <code>value</code> 这个 attribute 指定了<em>初始</em>值；DOM 的 <code>value</code> 这个 property 是<em>当前</em>值。</p><p translation-origin=\"off\">The HTML attribute <code>value</code> specifies the <em>initial</em> value; the DOM <code>value</code> property is the <em>current</em> value.</p>\n\n<p translation-result=\"on\"><code>disabled</code> 这个 attribute 是另一种特例。按钮的 <code>disabled</code> 这个 <em>property</em> 是 <code>false</code>，因为默认情况下按钮是可用的。\n当你添加 <code>disabled</code> 这个 <em>attribute</em> 时，只要它出现了按钮的 <code>disabled</code> 这个 <em>property</em> 就初始化为 <code>true</code>，于是按钮就被禁用了。</p><p translation-origin=\"off\">The <code>disabled</code> attribute is another peculiar example. A button's <code>disabled</code> <em>property</em> is\n<code>false</code> by default so the button is enabled.\nWhen you add the <code>disabled</code> <em>attribute</em>, its presence alone initializes the  button's <code>disabled</code> <em>property</em> to <code>true</code>\nso the button is disabled.</p>\n\n<p translation-result=\"on\">添加或删除 <code>disabled</code> 这个 <em>attribute</em> 会禁用或启用这个按钮。但 <em>attribute</em> 的值无关紧要，这就是你为什么没法通过\n<code>&#x3C;button disabled=\"false\">仍被禁用&#x3C;/button></code> 这种写法来启用按钮。</p><p translation-origin=\"off\">Adding and removing the <code>disabled</code> <em>attribute</em> disables and enables the button. The value of the <em>attribute</em> is irrelevant,\nwhich is why you cannot enable a button by writing <code>&#x3C;button disabled=\"false\">Still Disabled&#x3C;/button></code>.</p>\n\n<p translation-result=\"on\">设置按钮的 <code>disabled</code> 这个 <em>property</em>（如，通过 Angular 绑定）可以禁用或启用这个按钮。\n这就是 <em>property</em> 的价值。</p><p translation-origin=\"off\">Setting the button's <code>disabled</code> <em>property</em>  (say, with an Angular binding) disables or enables the button.\nThe value of the <em>property</em> matters.</p>\n\n<p translation-result=\"on\"><strong>就算名字相同，HTML attribute 和 DOM property 也不是同一样东西。</strong></p><p translation-origin=\"off\"><strong>The HTML attribute and the DOM property are not the same thing, even when they have the same name.</strong></p>\n\n</div>\n<p translation-result=\"on\">这句话值得再强调一次：\n<strong>模板绑定是通过 <em>property</em> 和<em>事件</em>来工作的，而不是 <em>attribute</em>。</strong></p><p translation-origin=\"off\">This fact bears repeating:\n<strong>Template binding works with <em>properties</em> and <em>events</em>, not <em>attributes</em>.</strong></p>\n\n<div class=\"callout is-helpful\">\n<header translation-result=\"on\">没有 attribute 的世界</header><header translation-origin=\"off\">A world without attributes</header>\n\n<p translation-result=\"on\">在 Angular 的世界中，attribute 唯一的作用是用来初始化元素和指令的状态。\n当进行数据绑定时，只是在与元素和指令的 property 和事件打交道，而 attribute 就完全靠边站了。</p><p translation-origin=\"off\">In the world of Angular, the only role of attributes is to initialize element and directive state.\nWhen you write a data binding, you're dealing exclusively with properties and events of the target object.\nHTML attributes effectively disappear.</p>\n\n</div>\n<p translation-result=\"on\">把这个思维模型牢牢的印在脑子里，接下来，学习什么是绑定目标。</p><p translation-origin=\"off\">With this model firmly in mind, read on to learn about binding targets.</p>\n\n<h3 id=\"binding-targets\" translation-result=\"on\">绑定目标<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#binding-targets\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"binding-targets\">Binding targets<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#binding-targets\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><strong>数据绑定的目标</strong>是 DOM 中的某些东西。\n这个目标可能是（元素 | 组件 | 指令的）property、（元素 | 组件 | 指令的）事件，或(极少数情况下) attribute 名。\n下面是的汇总表：</p><p translation-origin=\"off\">The <strong>target of a data binding</strong> is something in the DOM.\nDepending on the binding type, the target can be an\n(element | component | directive) property, an\n(element | component | directive) event, or (rarely) an attribute name.\nThe following table summarizes:</p>\n\n<style>\n  td, th {vertical-align: top}\n</style>\n<table width=\"100%\">\n  <colgroup><col width=\"10%\">\n  \n  <col width=\"15%\">\n  \n  <col width=\"75%\">\n  \n  </colgroup><tbody><tr>\n    <th>\n<p translation-result=\"on\">      绑定类型</p><p translation-origin=\"off\">      Type</p>\n\n    </th>\n    <th>\n<p translation-result=\"on\">      目标</p><p translation-origin=\"off\">      Target</p>\n\n    </th>\n    <th>\n<p translation-result=\"on\">      范例</p><p translation-origin=\"off\">      Examples</p>\n\n    </th>\n  </tr>\n  <tr>\n    <td>\n<p translation-result=\"on\">      属性</p><p translation-origin=\"off\">      Property</p>\n\n    </td>\n    <td>\n<p translation-result=\"on\">      元素的 property<br>\n组件的 property<br>\n指令的 property</p><p translation-origin=\"off\">      Element property<br>\nComponent property<br>\nDirective property</p>\n\n    </td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-syntax-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;img [src]=\"heroImageUrl\">\n&#x3C;app-hero-detail [hero]=\"currentHero\">&#x3C;/app-hero-detail>\n&#x3C;div [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"{'special': isSpecial}\">&#x3C;/div>\n\n</code-example>\n    </td>\n  </tr>\n  <tr>\n    <td>\n<p translation-result=\"on\">      事件</p><p translation-origin=\"off\">      Event</p>\n\n    </td>\n    <td>\n<p translation-result=\"on\">      元素的事件<br>\n组件的事件<br>\n指令的事件</p><p translation-origin=\"off\">      Element event<br>\nComponent event<br>\nDirective event</p>\n\n    </td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"event-binding-syntax-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button (click)=\"onSave()\">Save&#x3C;/button>\n&#x3C;app-hero-detail (deleteRequest)=\"deleteHero()\">&#x3C;/app-hero-detail>\n&#x3C;div (myClick)=\"clicked=$event\" clickable>click me&#x3C;/div>\n\n</code-example>\n    </td>\n  </tr>\n  <tr>\n    <td>\n<p translation-result=\"on\">      双向</p><p translation-origin=\"off\">      Two-way</p>\n\n    </td>\n    <td>\n<p translation-result=\"on\">      事件与 property</p><p translation-origin=\"off\">      Event and property</p>\n\n    </td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"2-way-binding-syntax-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"name\">\n\n</code-example>\n    </td>\n  </tr>\n  <tr>\n    <td>\n<p>      Attribute</p>\n    </td>\n    <td>\n<p translation-result=\"on\">      attribute（例外情况）</p><p translation-origin=\"off\">      Attribute\n(the exception)</p>\n\n    </td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"attribute-binding-syntax-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button [attr.aria-label]=\"help\">help&#x3C;/button>\n\n</code-example>\n    </td>\n  </tr>\n  <tr>\n    <td>\n<p translation-result=\"on\">      CSS 类</p><p translation-origin=\"off\">      Class</p>\n\n    </td>\n    <td>\n<p>      <code>class</code> property</p>\n    </td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"class-binding-syntax-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div [class.special]=\"isSpecial\">Special&#x3C;/div>\n\n</code-example>\n    </td>\n  </tr>\n  <tr>\n    <td>\n<p translation-result=\"on\">      样式</p><p translation-origin=\"off\">      Style</p>\n\n    </td>\n    <td>\n<p>      <code><a href=\"api/animations/style\" class=\"code-anchor\">style</a></code> property</p>\n    </td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"style-binding-syntax-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button [style.color]=\"isSpecial ? 'red' : 'green'\">\n\n</code-example>\n    </td>\n  </tr>\n</tbody></table>\n<p translation-result=\"on\">放开眼界，来看看每种绑定类型的具体情况。</p><p translation-origin=\"off\">With this broad view in mind, you're ready to look at binding types in detail.</p>\n\n<hr>\n<a id=\"property-binding\"></a>\n<h2 id=\"property-binding--property-\" translation-result=\"on\">属性绑定 ( <span class=\"syntax\">[属性名]</span> )<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#property-binding--property-\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"property-binding--property-\">Property binding ( <span class=\"syntax\">[property]</span> )<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#property-binding--property-\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">当要把视图元素的属性 (property) 设置为<a href=\"guide/template-syntax#template-expressions\">模板表达式</a>时，就要写模板的<strong>属性 (property) 绑定</strong>。</p><p translation-origin=\"off\">Write a template <strong>property binding</strong> to set a property of a view element.\nThe binding sets the property to the value of a <a href=\"guide/template-syntax#template-expressions\">template expression</a>.</p>\n\n<p translation-result=\"on\">最常用的属性绑定是把元素属性设置为组件属性的值。\n下面这个例子中，image 元素的 <code>src</code> 属性会被绑定到组件的 <code>heroImageUrl</code> 属性上：</p><p translation-origin=\"off\">The most common property binding sets an element property to a component property value. An example is\nbinding the <code>src</code> property of an image element to a component's <code>heroImageUrl</code> property:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;img [src]=\"heroImageUrl\">\n\n</code-example>\n<p translation-result=\"on\">另一个例子是当组件说它 <code>isUnchanged</code>（未改变）时禁用按钮：</p><p translation-origin=\"off\">Another example is disabling a button when the component says that it <code>isUnchanged</code>:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button [disabled]=\"isUnchanged\">Cancel is disabled&#x3C;/button>\n\n</code-example>\n<p translation-result=\"on\">另一个例子是设置指令的属性：</p><p translation-origin=\"off\">Another is setting a property of a directive:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-3\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"<a href=\"api/core/DebugElement#classes\" class=\"code-anchor\">classes</a>\">[<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>] binding to the <a href=\"api/core/DebugElement#classes\" class=\"code-anchor\">classes</a> property&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\">还有另一个例子是设置自定义组件的模型属性（这是父子组件之间通讯的重要途径）：</p><p translation-origin=\"off\">Yet another is setting the model property of a custom component (a great way\nfor parent and child components to communicate):</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-4\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;app-hero-detail [hero]=\"currentHero\">&#x3C;/app-hero-detail>\n\n</code-example>\n<h3 id=\"one-way-in\" translation-result=\"on\">单向<em>输入</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#one-way-in\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"one-way-in\">One-way <em>in</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#one-way-in\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">人们经常把属性绑定描述成<em>单向数据绑定</em>，因为值的流动是单向的，从组件的数据属性流动到目标元素的属性。</p><p translation-origin=\"off\">People often describe property binding as <em>one-way data binding</em> because it flows a value in one direction,\nfrom a component's data property into a target element property.</p>\n\n<p translation-result=\"on\">不能使用属性绑定来从目标元素拉取值，也不能绑定到目标元素的属性来读取它。只能设置它。</p><p translation-origin=\"off\">You cannot use property binding to pull values <em>out</em> of the target element.\nYou can't bind to a property of the target element to <em>read</em> it. You can only <em>set</em> it.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">也不能使用属性 绑定 来<em>调用</em>目标元素上的方法。</p><p translation-origin=\"off\">Similarly, you cannot use property binding to <em>call</em> a method on the target element.</p>\n\n<p translation-result=\"on\">如果这个元素触发了事件，可以通过<a href=\"guide/template-syntax#event-binding\">事件绑定</a>来监听它们。</p><p translation-origin=\"off\">If the element raises events, you can listen to them with an <a href=\"guide/template-syntax#event-binding\">event binding</a>.</p>\n\n<p translation-result=\"on\">如果必须读取目标元素上的属性或调用它的某个方法，得用另一种技术。\n参见 API 参考手册中的\n<a href=\"api/core/ViewChild\">ViewChild</a> 和\n<a href=\"api/core/ContentChild\">ContentChild</a>。</p><p translation-origin=\"off\">If you must read a target element property or call one of its methods,\nyou'll need a different technique.\nSee the API reference for\n<a href=\"api/core/ViewChild\">ViewChild</a> and\n<a href=\"api/core/ContentChild\">ContentChild</a>.</p>\n\n</div>\n<h3 id=\"binding-target\" translation-result=\"on\">绑定目标<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#binding-target\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"binding-target\">Binding target<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#binding-target\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">包裹在方括号中的元素属性名标记着目标属性。下列代码中的目标属性是 image 元素的 <code>src</code> 属性。</p><p translation-origin=\"off\">An element property between enclosing square brackets identifies the target property.\nThe target property in the following code is the image element's <code>src</code> property.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;img [src]=\"heroImageUrl\">\n\n</code-example>\n<p translation-result=\"on\">有些人喜欢用 <code>bind-</code> 前缀的可选形式，并称之为<em>规范形式</em>：</p><p translation-origin=\"off\">Some people prefer the <code>bind-</code> prefix alternative, known as the <em>canonical form</em>:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-5\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;img bind-src=\"heroImageUrl\">\n\n</code-example>\n<p translation-result=\"on\">目标的名字总是 property 的名字。即使它看起来和别的名字一样。\n看到 <code>src</code> 时，可能会把它当做 attribute。不！它不是！它是 image 元素的 property 名。</p><p translation-origin=\"off\">The target name is always the name of a property, even when it appears to be the name of something else.\nYou see <code>src</code> and may think it's the name of an attribute. No. It's the name of an image element property.</p>\n\n<p translation-result=\"on\">元素属性可能是最常见的绑定目标，但 Angular 会先去看这个名字是否是某个已知指令的属性名，就像下面的例子中一样：</p><p translation-origin=\"off\">Element properties may be the more common targets,\nbut Angular looks first to see if the name is a property of a known directive,\nas it is in the following example:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-3\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"<a href=\"api/core/DebugElement#classes\" class=\"code-anchor\">classes</a>\">[<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>] binding to the <a href=\"api/core/DebugElement#classes\" class=\"code-anchor\">classes</a> property&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">严格来说，Angular 正在匹配指令的<a href=\"guide/template-syntax#inputs-outputs\">输入属性</a>的名字。\n这个名字是指令的 <code>inputs</code> 数组中所列的名字，或者是带有 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 装饰器的属性。\n这些输入属性被映射为指令自己的属性。</p><p translation-origin=\"off\">Technically, Angular is matching the name to a directive <a href=\"guide/template-syntax#inputs-outputs\">input</a>,\none of the property names listed in the directive's <code>inputs</code> array or a property decorated with <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>.\nSuch inputs map to the directive's own properties.</p>\n\n</div>\n<p translation-result=\"on\">如果名字没有匹配上已知指令或元素的属性，Angular 就会报告“未知指令”的错误。</p><p translation-origin=\"off\">If the name fails to match a property of a known directive or element, Angular reports an “unknown directive” error.</p>\n\n<h3 id=\"avoid-side-effects\" translation-result=\"on\">消除副作用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#avoid-side-effects\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"avoid-side-effects\">Avoid side effects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#avoid-side-effects\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">正如以前讨论过的，模板表达式的计算不能有可见的副作用。表达式语言本身可以提供一部分安全保障。\n不能在属性绑定表达式中对任何东西赋值，也不能使用自增、自减运算符。</p><p translation-origin=\"off\">As mentioned previously, evaluation of a template expression should have no visible side effects.\nThe expression language itself does its part to keep you safe.\nYou can't assign a value to anything in a property binding expression nor use the increment and decrement operators.</p>\n\n<p translation-result=\"on\">当然，表达式可能会调用具有副作用的属性或方法。但 Angular 没法知道这一点，也没法阻止你。</p><p translation-origin=\"off\">Of course, the expression might invoke a property or method that has side effects.\nAngular has no way of knowing that or stopping you.</p>\n\n<p translation-result=\"on\">表达式中可以调用像 <code>getFoo()</code> 这样的方法。只有你知道 <code>getFoo()</code> 干了什么。\n如果 <code>getFoo()</code> 改变了某个东西，恰好又绑定到个这个东西，你就可能把自己坑了。\nAngular 可能显示也可能不显示变化后的值。Angular 还可能检测到变化，并抛出警告型错误。\n一般建议是，只绑定数据属性和那些只返回值而不做其它事情的方法。</p><p translation-origin=\"off\">The expression could call something like <code>getFoo()</code>. Only you know what <code>getFoo()</code> does.\nIf <code>getFoo()</code> changes something and you happen to be binding to that something, you risk an unpleasant experience.\nAngular may or may not display the changed value. Angular may detect the change and throw a warning error.\nIn general, stick to data properties and to methods that return values and do no more.</p>\n\n<h3 id=\"return-the-proper-type\" translation-result=\"on\">返回恰当的类型<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#return-the-proper-type\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"return-the-proper-type\">Return the proper type<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#return-the-proper-type\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">模板表达式应该返回目标属性所需类型的值。\n如果目标属性想要个字符串，就返回字符串。\n如果目标属性想要个数字，就返回数字。\n如果目标属性想要个对象，就返回对象。</p><p translation-origin=\"off\">The template expression should evaluate to the type of value expected by the target property.\nReturn a string if the target property expects a string.\nReturn a number if the target property expects a number.\nReturn an object if the target property expects an object.</p>\n\n<p translation-result=\"on\"><code>HeroDetail</code> 组件的 <code>hero</code> 属性想要一个 <code>Hero</code> 对象，也就是你在属性绑定时发给它的那个：</p><p translation-origin=\"off\">The <code>hero</code> property of the <code>HeroDetail</code> component expects a <code>Hero</code> object, which is exactly what you're sending in the property binding:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-4\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;app-hero-detail [hero]=\"currentHero\">&#x3C;/app-hero-detail>\n\n</code-example>\n<h3 id=\"remember-the-brackets\" translation-result=\"on\">别忘了方括号<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#remember-the-brackets\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"remember-the-brackets\">Remember the brackets<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#remember-the-brackets\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">方括号告诉 Angular 要计算模板表达式。\n如果忘了加方括号，Angular 会把这个表达式当做字符串常量看待，并用该字符串来<em>初始化目标属性</em>。\n它<em>不会</em>计算这个字符串。</p><p translation-origin=\"off\">The brackets tell Angular to evaluate the template expression.\nIf you omit the brackets, Angular treats the string as a constant\nand <em>initializes the target property</em> with that string.\nIt does <em>not</em> evaluate the string!</p>\n\n<p translation-result=\"on\">不要出现这样的失误：</p><p translation-origin=\"off\">Don't make the following mistake:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-6\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- ERROR: HeroDetailComponent.hero expects <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>\n     Hero object, not the string \"currentHero\" -->\n  &#x3C;app-hero-detail hero=\"currentHero\">&#x3C;/app-hero-detail>\n\n</code-example>\n<a id=\"one-time-initialization\"></a>\n<h3 id=\"one-time-string-initialization\" translation-result=\"on\">一次性字符串初始化<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#one-time-string-initialization\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"one-time-string-initialization\">One-time string initialization<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#one-time-string-initialization\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">当满足下列条件时，<em>应该</em>省略括号：</p><p translation-origin=\"off\">You <em>should</em> omit the brackets when all of the following are true:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> 目标属性接受字符串值。</p><p translation-origin=\"off\">The target property accepts a string value.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 字符串是个固定值，可以直接合并到模块中。</p><p translation-origin=\"off\">The string is a fixed value that you can bake into the template.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 这个初始值永不改变。</p><p translation-origin=\"off\">This initial value never changes.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">你经常这样在标准 HTML 中用这种方式初始化 attribute，这种方式也可以用在初始化指令和组件的属性。\n下面这个例子把 <code>HeroDetailComponent</code> 的 <code>prefix</code> 属性初始化为固定的字符串，而不是模板表达式。Angular 设置它，然后忘记它。</p><p translation-origin=\"off\">You routinely initialize attributes this way in standard HTML, and it works\njust as well for directive and component property initialization.\nThe following example initializes the <code>prefix</code> property of the <code>HeroDetailComponent</code> to a fixed string,\nnot a template expression. Angular sets it and forgets about it.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-7\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;app-hero-detail prefix=\"You are my\" [hero]=\"currentHero\">&#x3C;/app-hero-detail>\n\n</code-example>\n<p translation-result=\"on\">作为对比，<code>[hero]</code> 绑定是组件的 <code>currentHero</code> 属性的活绑定，它会一直随着更新。</p><p translation-origin=\"off\">The <code>[hero]</code> binding, on the other hand, remains a live binding to the component's <code>currentHero</code> property.</p>\n\n<a id=\"property-binding-or-interpolation\"></a>\n<h3 id=\"property-binding-or-interpolation\" translation-result=\"on\">属性绑定还是插值？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#property-binding-or-interpolation\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"property-binding-or-interpolation\">Property binding or interpolation?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#property-binding-or-interpolation\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你通常得在插值和属性绑定之间做出选择。\n下列这几对绑定做的事情完全相同：</p><p translation-origin=\"off\">You often have a choice between interpolation and property binding.\nThe following binding pairs do the same thing:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-vs-interpolation\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;p>&#x3C;img src=\"{{heroImageUrl}}\"> is the &#x3C;i>interpolated&#x3C;/i> image.&#x3C;/p>\n&#x3C;p>&#x3C;img [src]=\"heroImageUrl\"> is the &#x3C;i>property bound&#x3C;/i> image.&#x3C;/p>\n\n&#x3C;p>&#x3C;span>\"{{title}}\" is the &#x3C;i>interpolated&#x3C;/i> title.&#x3C;/span>&#x3C;/p>\n&#x3C;p>\"&#x3C;span [innerHTML]=\"title\">&#x3C;/span>\" is the &#x3C;i>property bound&#x3C;/i> title.&#x3C;/p>\n\n</code-example>\n<p translation-result=\"on\">在多数情况下，插值是更方便的备选项。</p><p translation-origin=\"off\"><em>Interpolation</em> is a convenient alternative to <em>property binding</em> in many cases.</p>\n\n<p translation-result=\"on\">当要渲染的数据类型是字符串时，没有技术上的理由证明哪种形式更好。\n你倾向于可读性，所以倾向于插值。\n建议建立代码风格规则，选择一种形式，\n这样，既遵循了规则，又能让手头的任务做起来更自然。</p><p translation-origin=\"off\">When rendering data values as strings, there is no technical reason to prefer one form to the other.\nYou lean toward readability, which tends to favor interpolation.\nYou suggest establishing coding style rules and choosing the form that\nboth conforms to the rules and feels most natural for the task at hand.</p>\n\n<p translation-result=\"on\">但数据类型不是字符串时，就必须使用<em>属性绑定</em>了。</p><p translation-origin=\"off\">When setting an element property to a non-string data value, you must use <em>property binding</em>.</p>\n\n<h4 id=\"content-security\" translation-result=\"on\">内容安全<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#content-security\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"content-security\">Content security<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#content-security\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">假设下面的<em>恶意内容</em></p><p translation-origin=\"off\">Imagine the following <em>malicious content</em>.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.ts\" region=\"evil-title\" header=\"src/app/app.component.ts\" linenums=\"false\">\nevilTitle = '<a href=\"\" class=\"code-anchor\">Template</a> &#x3C;script>alert(\"evil never sleeps\")&#x3C;/script>Syntax';\n\n</code-example>\n<p translation-result=\"on\">幸运的是，Angular 数据绑定对危险 HTML 有防备。\n在显示它们之前，它对内容先进行<em>消毒</em>。\n不管是插值还是属性绑定，都<strong>不会</strong>允许带有 script 标签的 HTML 泄漏到浏览器中。</p><p translation-origin=\"off\">Fortunately, Angular data binding is on alert for dangerous HTML.\nIt <a href=\"guide/security#sanitization-and-security-contexts\"><em>sanitizes</em></a> the values before displaying them.\nIt <strong>will not</strong> allow HTML with script tags to leak into the browser, neither with interpolation\nnor property binding.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-vs-interpolation-sanitization\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!--\n  Angular generates warnings for these two lines as it sanitizes them\n  WARNING: sanitizing <a href=\"api/core/SecurityContext#HTML\" class=\"code-anchor\">HTML</a> stripped some content (see <a href=\"api/common/http\" class=\"code-anchor\">http</a>://g.co/ng/security#xss).\n -->\n&#x3C;p>&#x3C;span>\"{{evilTitle}}\" is the &#x3C;i>interpolated&#x3C;/i> evil title.&#x3C;/span>&#x3C;/p>\n&#x3C;p>\"&#x3C;span [innerHTML]=\"evilTitle\">&#x3C;/span>\" is the &#x3C;i>property bound&#x3C;/i> evil title.&#x3C;/p>\n\n</code-example>\n<p translation-result=\"on\">插值处理 script 标签与属性绑定有所不同，但是二者都只渲染没有危害的内容。</p><p translation-origin=\"off\">Interpolation handles the script tags differently than property binding but both approaches render the\ncontent harmlessly.</p>\n\n<figure>\n  <img src=\"generated/images/guide/template-syntax/evil-title.png\" alt=\"evil title made safe\" width=\"500\" height=\"40\">\n</figure>\n<hr>\n<a id=\"other-bindings\"></a>\n<h2 id=\"attribute-class-and-style-bindings\" translation-result=\"on\">attribute、class 和 style 绑定<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#attribute-class-and-style-bindings\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"attribute-class-and-style-bindings\">Attribute, class, and style bindings<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#attribute-class-and-style-bindings\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">模板语法为那些不太适合使用属性绑定的场景提供了专门的单向数据绑定形式。</p><p translation-origin=\"off\">The template syntax provides specialized one-way bindings for scenarios less well suited to property binding.</p>\n\n<h3 id=\"attribute-binding\" translation-result=\"on\">attribute 绑定<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#attribute-binding\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"attribute-binding\">Attribute binding<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#attribute-binding\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">可以通过<strong>attribute 绑定</strong>来直接设置 attribute 的值。</p><p translation-origin=\"off\">You can set the value of an attribute directly with an <strong>attribute binding</strong>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">这是“绑定到目标属性 (property)”这条规则中唯一的例外。这是唯一的能创建和设置 attribute 的绑定形式。</p><p translation-origin=\"off\">This is the only exception to the rule that a binding sets a target property.\nThis is the only binding that creates and sets an attribute.</p>\n\n</div>\n<p translation-result=\"on\">本章中，通篇都在说通过属性绑定来设置元素的属性总是好于用字符串设置 attribute。为什么 Angular 还提供了 attribute 绑定呢？</p><p translation-origin=\"off\">This guide stresses repeatedly that setting an element property with a property binding\nis always preferred to setting the attribute with a string. Why does Angular offer attribute binding?</p>\n\n<p translation-result=\"on\"><strong>因为当元素没有属性可绑的时候，就必须使用 attribute 绑定。</strong></p><p translation-origin=\"off\"><strong>You must use attribute binding when there is no element property to bind.</strong></p>\n\n<p translation-result=\"on\">考虑 <a href=\"https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA\">ARIA</a>，\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/SVG\">SVG</a> 和 table 中的 colspan/rowspan 等 attribute。\n它们是纯粹的 attribute，没有对应的属性可供绑定。</p><p translation-origin=\"off\">Consider the <a href=\"https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA\">ARIA</a>,\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/SVG\">SVG</a>, and\ntable span attributes. They are pure attributes.\nThey do not correspond to element properties, and they do not set element properties.\nThere are no property targets to bind to.</p>\n\n<p translation-result=\"on\">如果想写出类似下面这样的东西，就会暴露出痛点了：</p><p translation-origin=\"off\">This fact becomes painfully obvious when you write something like this.</p>\n\n<code-example language=\"html\">\n  &#x3C;tr>&#x3C;td colspan=\"{{1 + 1}}\">Three-Four&#x3C;/td>&#x3C;/tr>\n</code-example>\n<p translation-result=\"on\">会得到这个错误：</p><p translation-origin=\"off\">And you get this error:</p>\n\n<code-example format=\"nocode\">\n  <a href=\"\" class=\"code-anchor\">Template</a> parse errors:\n  Can't bind to 'colspan' since it isn't <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> known <a href=\"\" class=\"code-anchor\">native</a> property\n</code-example>\n<p translation-result=\"on\">正如提示中所说，<code>&#x3C;td></code> 元素没有 <code>colspan</code> 属性。\n但是插值和属性绑定只能设置<em>属性</em>，不能设置 attribute。</p><p translation-origin=\"off\">As the message says, the <code>&#x3C;td></code> element does not have a <code>colspan</code> property.\nIt has the \"colspan\" <em>attribute</em>, but\ninterpolation and property binding can set only <em>properties</em>, not attributes.</p>\n\n<p translation-result=\"on\">你需要 attribute 绑定来创建和绑定到这样的 attribute。</p><p translation-origin=\"off\">You need attribute bindings to create and bind to such attributes.</p>\n\n<p translation-result=\"on\">attribute 绑定的语法与属性绑定类似。\n但方括号中的部分不是元素的属性名，而是由<strong><code>attr</code></strong>前缀，一个点 (<code>.</code>) 和 attribute 的名字组成。\n可以通过值为字符串的表达式来设置 attribute 的值。</p><p translation-origin=\"off\">Attribute binding syntax resembles property binding.\nInstead of an element property between brackets, start with the prefix <strong><code>attr</code></strong>,\nfollowed by a dot (<code>.</code>) and the name of the attribute.\nYou then set the attribute value, using an expression that resolves to a string.</p>\n\n<p translation-result=\"on\">这里把 <code>[attr.colspan]</code> 绑定到一个计算值：</p><p translation-origin=\"off\">Bind <code>[attr.colspan]</code> to a calculated value:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"attrib-binding-colspan\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;table border=1>\n  &#x3C;!--  expression calculates colspan=2 -->\n  &#x3C;tr>&#x3C;td [attr.colspan]=\"1 + 1\">One-Two&#x3C;/td>&#x3C;/tr>\n\n  &#x3C;!-- ERROR: There is no `colspan` property to set!\n    &#x3C;tr>&#x3C;td colspan=\"{{1 + 1}}\">Three-Four&#x3C;/td>&#x3C;/tr>\n  -->\n\n  &#x3C;tr>&#x3C;td>Five&#x3C;/td>&#x3C;td>Six&#x3C;/td>&#x3C;/tr>\n&#x3C;/table>\n\n</code-example>\n<p translation-result=\"on\">这里是表格渲染出来的样子：</p><p translation-origin=\"off\">Here's how the table renders:</p>\n\n<table border=\"1px\">\n  <tbody><tr>\n      <td colspan=\"2\">\n<p>          One-Two</p>\n      </td>\n  </tr>\n  <tr>\n      <td>\n<p>          Five</p></td><td>Six<p></p>\n      </td>\n  </tr>\n </tbody></table>\n<p translation-result=\"on\">attribute 绑定的主要用例之一是设置 ARIA attribute（译注：ARIA 指可访问性，用于给残障人士访问互联网提供便利），\n就像这个例子中一样：</p><p translation-origin=\"off\">One of the primary use cases for attribute binding\nis to set ARIA attributes, as in this example:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"attrib-binding-aria\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- create and set an aria attribute for assistive technology -->\n&#x3C;button [attr.aria-label]=\"actionName\">{{actionName}} with Aria&#x3C;/button>\n\n</code-example>\n<hr>\n<h3 id=\"class-binding\" translation-result=\"on\">CSS 类绑定<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#class-binding\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"class-binding\">Class binding<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#class-binding\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">借助 <strong>CSS 类绑定</strong>，可以从元素的 <code>class</code> attribute 上添加和移除 CSS 类名。</p><p translation-origin=\"off\">You can add and remove CSS class names from an element's <code>class</code> attribute with\na <strong>class binding</strong>.</p>\n\n<p translation-result=\"on\">CSS 类绑定绑定的语法与属性绑定类似。\n但方括号中的部分不是元素的属性名，而是由<strong><code>class</code></strong>前缀，一个点 (<code>.</code>)和 CSS 类的名字组成，\n其中后两部分是可选的。形如：<code>[class.class-name]</code>。</p><p translation-origin=\"off\">Class binding syntax resembles property binding.\nInstead of an element property between brackets, start with the prefix <code>class</code>,\noptionally followed by a dot (<code>.</code>) and the name of a CSS class: <code>[class.class-name]</code>.</p>\n\n<p translation-result=\"on\">下列例子示范了如何通过 CSS 类绑定来添加和移除应用的 \"special\" 类。不用绑定直接设置 attribute 时是这样的：</p><p translation-origin=\"off\">The following examples show how to add and remove the application's \"special\" class\nwith class bindings.  Here's how to set the attribute without binding:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"class-binding-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- standard class attribute setting  -->\n&#x3C;div class=\"bad curly special\">Bad curly special&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\">可以把它改写为绑定到所需 CSS 类名的绑定；这是一个或者全有或者全无的替换型绑定。\n（译注：即当 badCurly 有值时 class 这个 attribute 设置的内容会被完全覆盖）</p><p translation-origin=\"off\">You can replace that with a binding to a string of the desired class names; this is an all-or-nothing, replacement binding.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"class-binding-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- reset/override all class names with <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> binding  -->\n&#x3C;div class=\"bad curly special\"\n     [class]=\"badCurly\">Bad curly&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\">最后，可以绑定到特定的类名。\n当模板表达式的求值结果是真值时，Angular 会添加这个类，反之则移除它。</p><p translation-origin=\"off\">Finally, you can bind to a specific class name.\nAngular adds the class when the template expression evaluates to truthy.\nIt removes the class when the expression is falsy.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"class-binding-3\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- toggle the \"special\" class on/off with <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> property -->\n&#x3C;div [class.special]=\"isSpecial\">The class binding is special&#x3C;/div>\n\n&#x3C;!-- binding to `class.special` trumps the class attribute -->\n&#x3C;div class=\"special\"\n     [class.special]=\"!isSpecial\">This one is not so special&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">虽然这是切换单一类名的好办法，但人们通常更喜欢使用 <a href=\"guide/template-syntax#ngClass\">NgClass 指令</a> 来同时管理多个类名。</p><p translation-origin=\"off\">While this is a fine way to toggle a single class name,\nthe <a href=\"guide/template-syntax#ngClass\">NgClass directive</a> is usually preferred when managing multiple class names at the same time.</p>\n\n</div>\n<hr>\n<h3 id=\"style-binding\" translation-result=\"on\">样式绑定<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#style-binding\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"style-binding\">Style binding<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#style-binding\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">通过<strong>样式绑定</strong>，可以设置内联样式。</p><p translation-origin=\"off\">You can set inline styles with a <strong>style binding</strong>.</p>\n\n<p translation-result=\"on\">样式绑定的语法与属性绑定类似。\n但方括号中的部分不是元素的属性名，而由<strong><code><a href=\"api/animations/style\" class=\"code-anchor\">style</a></code></strong>前缀，一个点 (<code>.</code>)和 CSS 样式的属性名组成。\n形如：<code>[style.style-property]</code>。</p><p translation-origin=\"off\">Style binding syntax resembles property binding.\nInstead of an element property between brackets, start with the prefix <code><a href=\"api/animations/style\" class=\"code-anchor\">style</a></code>,\nfollowed by a dot (<code>.</code>) and the name of a CSS style property: <code>[style.style-property]</code>.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"style-binding-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button [style.color]=\"isSpecial ? 'red': 'green'\">Red&#x3C;/button>\n&#x3C;button [style.background-color]=\"canSave ? 'cyan': 'grey'\" >Save&#x3C;/button>\n\n</code-example>\n<p translation-result=\"on\">有些样式绑定中的样式带有单位。在这里，以根据条件用 “em” 和 “%” 来设置字体大小的单位。</p><p translation-origin=\"off\">Some style binding styles have a unit extension.\nThe following example conditionally sets the font size in  “em” and “%” units .</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"style-binding-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button [style.font-size.em]=\"isSpecial ? 3 : 1\" >Big&#x3C;/button>\n&#x3C;button [style.font-size.%]=\"!isSpecial ? 150 : 50\" >Small&#x3C;/button>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">虽然这是设置单一样式的好办法，但人们通常更喜欢使用 <a href=\"guide/template-syntax#ngStyle\">NgStyle 指令</a> 来同时设置多个内联样式。</p><p translation-origin=\"off\">While this is a fine way to set a single style,\nthe <a href=\"guide/template-syntax#ngStyle\">NgStyle directive</a> is generally preferred when setting several inline styles at the same time.</p>\n\n</div>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">注意，<em>样式属性</em>命名方法可以用<a href=\"guide/glossary#dash-case\">中线命名法</a>，像上面的一样\n也可以用<a href=\"guide/glossary#camelcase\">驼峰式命名法</a>，如 <code>fontSize</code>。</p><p translation-origin=\"off\">Note that a <em>style property</em> name can be written in either\n<a href=\"guide/glossary#dash-case\">dash-case</a>, as shown above, or\n<a href=\"guide/glossary#camelcase\">camelCase</a>, such as <code>fontSize</code>.</p>\n\n</div>\n<hr>\n<a id=\"event-binding\"></a>\n<h2 id=\"event-binding-event\" translation-result=\"on\">事件绑定 <code>(event)</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#event-binding-event\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"event-binding-event\">Event binding <code>(event)</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#event-binding-event\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">事件绑定允许你侦听某些事件，比如按键、鼠标移动、点击和触屏。要查看本节中所有要点的演示，请参见<live-example name=\"event-binding\">事件绑定范例</live-example>。</p><p translation-origin=\"off\">Event binding allows you to listen for certain events such as\nkeystrokes, mouse movements, clicks, and touches. For an example\ndemonstrating all of the points in this section, see the <live-example name=\"event-binding\">event binding example</live-example>.</p>\n\n<p translation-result=\"on\">Angular 的事件绑定语法由等号左侧带圆括号的<strong>目标事件</strong>和右侧引号中的<a href=\"guide/template-syntax#template-statements\">模板语句</a>组成。\n下面事件绑定监听按钮的点击事件。每当点击发生时，都会调用组件的 <code>onSave()</code> 方法。</p><p translation-origin=\"off\">Angular event binding syntax consists of a <strong>target event</strong> name\nwithin parentheses on the left of an equal sign, and a quoted\ntemplate statement on the right.\nThe following event binding listens for the button's click events, calling\nthe component's <code>onSave()</code> method whenever a click occurs:</p>\n\n<figure>\n  <img src=\"generated/images/guide/template-syntax/syntax-diagram.svg\" alt=\"Syntax diagram\" width=\"600\" height=\"125\">\n</figure>\n<h3 id=\"target-event\" translation-result=\"on\">目标事件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#target-event\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"target-event\">Target event<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#target-event\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如前所述，其目标就是此按钮的单击事件。</p><p translation-origin=\"off\">As above, the target is the button's click event.</p>\n\n<code-example path=\"event-binding/src/app/app.component.html\" region=\"event-binding-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button (click)=\"onSave($event)\">Save&#x3C;/button>\n\n</code-example>\n<p translation-result=\"on\">有些人更喜欢带 <code>on-</code> 前缀的备选形式，称之为<strong>规范形式</strong>：</p><p translation-origin=\"off\">Alternatively, use the <code>on-</code> prefix, known as the canonical form:</p>\n\n<code-example path=\"event-binding/src/app/app.component.html\" region=\"event-binding-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button on-click=\"onSave($event)\">on-click Save&#x3C;/button>\n\n</code-example>\n<p translation-result=\"on\">元素事件可能是更常见的目标，但 Angular 会先看这个名字是否能匹配上已知指令的事件属性，就像下面这个例子：</p><p translation-origin=\"off\">Element events may be the more common targets, but Angular looks first to see if the name matches an event property\nof a known directive, as it does in the following example:</p>\n\n<code-example path=\"event-binding/src/app/app.component.html\" region=\"custom-directive\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;h4>myClick is an event on the custom ClickDirective:&#x3C;/h4>\n&#x3C;button (myClick)=\"clickMessage=$event\" clickable>click with myClick&#x3C;/button>\n{{clickMessage}}\n\n</code-example>\n<p translation-result=\"on\">如果这个名字没能匹配到元素事件或已知指令的输出属性，Angular 就会报“未知指令”错误。</p><p translation-origin=\"off\">If the name fails to match an element event or an output property of a known directive,\nAngular reports an “unknown directive” error.</p>\n\n<h3 id=\"event-and-event-handling-statements\" translation-result=\"on\"><em>$event</em> 和事件处理语句<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#event-and-event-handling-statements\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"event-and-event-handling-statements\"><em>$event</em> and event handling statements<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#event-and-event-handling-statements\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在事件绑定中，Angular 会为目标事件设置事件处理器。</p><p translation-origin=\"off\">In an event binding, Angular sets up an event handler for the target event.</p>\n\n<p translation-result=\"on\">当事件发生时，这个处理器会执行模板语句。\n典型的模板语句通常涉及到响应事件执行动作的接收器，例如从 HTML 控件中取得值，并存入模型。</p><p translation-origin=\"off\">When the event is raised, the handler executes the template statement.\nThe template statement typically involves a receiver, which performs an action\nin response to the event, such as storing a value from the HTML control\ninto a model.</p>\n\n<p translation-result=\"on\">绑定会通过<strong>名叫 <code>$event</code> 的事件对象</strong>传递关于此事件的信息（包括数据值）。</p><p translation-origin=\"off\">The binding conveys information about the event. This information can include data values such as an event object, string, or number named <code>$event</code>.</p>\n\n<p translation-result=\"on\">事件对象的形态取决于目标事件。如果目标事件是原生 DOM 元素事件，\n<code>$event</code> 就是 <a href=\"https://developer.mozilla.org/en-US/docs/Web/Events\">DOM 事件对象</a>，它有像 <code><a href=\"api/router/RouterLinkWithHref#target\" class=\"code-anchor\">target</a></code> 和 <code>target.value</code> 这样的属性。</p><p translation-origin=\"off\">The target event determines the shape of the <code>$event</code> object.\nIf the target event is a native DOM element event, then <code>$event</code> is a\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/Events\">DOM event object</a>,\nwith properties such as <code><a href=\"api/router/RouterLinkWithHref#target\" class=\"code-anchor\">target</a></code> and <code>target.value</code>.</p>\n\n<p translation-result=\"on\">考虑这个范例：</p><p translation-origin=\"off\">Consider this example:</p>\n\n<code-example path=\"event-binding/src/app/app.component.html\" region=\"event-binding-3\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;input [value]=\"currentItem.name\"\n       (input)=\"currentItem.name=$event.target.value\" >\nwithout <a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a>\n\n</code-example>\n<p translation-result=\"on\">上面的代码在把输入框的 <code>value</code> 属性绑定到 <code>name</code> 属性。\n要监听对值的修改，代码绑定到输入框的 <code>input</code> 事件。\n当用户造成更改时，<code>input</code> 事件被触发，并在包含了 DOM 事件对象 (<code>$event</code>) 的上下文中执行这条语句。</p><p translation-origin=\"off\">This code sets the <code>&#x3C;input></code> <code>value</code> property by binding to the <code>name</code> property.\nTo listen for changes to the value, the code binds to the <code>input</code>\nevent of the <code>&#x3C;input></code> element.\nWhen the user makes changes, the <code>input</code> event is raised, and the binding executes\nthe statement within a context that includes the DOM event object, <code>$event</code>.</p>\n\n<p translation-result=\"on\">要更新 <code>name</code> 属性，就要通过路径 <code>$event.target.value</code> 来获取更改后的值。</p><p translation-origin=\"off\">To update the <code>name</code> property, the changed text is retrieved by following the path <code>$event.target.value</code>.</p>\n\n<p translation-result=\"on\">如果事件属于指令（回想一下，组件是指令的一种），那么 <code>$event</code> 具体是什么由指令决定。</p><p translation-origin=\"off\">If the event belongs to a directive—recall that components\nare directives—<code>$event</code> has whatever shape the directive produces.</p>\n\n<h3 id=\"custom-events-with-eventemitter\" translation-result=\"on\">使用 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 实现自定义事件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#custom-events-with-eventemitter\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"custom-events-with-eventemitter\">Custom events with <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#custom-events-with-eventemitter\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">通常，指令使用 Angular <a href=\"api/core/EventEmitter\">EventEmitter</a> 来触发自定义事件。\n指令创建一个 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 实例，并且把它作为属性暴露出来。\n指令调用 <code>EventEmitter.emit(payload)</code> 来触发事件，可以传入任何东西作为消息载荷。\n父指令通过绑定到这个属性来监听事件，并通过 <code>$event</code> 对象来访问载荷。</p><p translation-origin=\"off\">Directives typically raise custom events with an Angular <a href=\"api/core/EventEmitter\">EventEmitter</a>.\nThe directive creates an <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> and exposes it as a property.\nThe directive calls <code>EventEmitter.emit(payload)</code> to fire an event, passing in a message payload, which can be anything.\nParent directives listen for the event by binding to this property and accessing the payload through the <code>$event</code> object.</p>\n\n<p translation-result=\"on\">假设 <code>HeroDetailComponent</code> 用于显示英雄的信息，并响应用户的动作。\n虽然 <code>HeroDetailComponent</code> 包含删除按钮，但它自己并不知道该如何删除这个英雄。\n最好的做法是触发事件来报告“删除用户”的请求。</p><p translation-origin=\"off\">Consider an <code>ItemDetailComponent</code> that presents item information and responds to user actions.\nAlthough the <code>ItemDetailComponent</code> has a delete button, it doesn't know how to delete the hero. It can only raise an event reporting the user's delete request.</p>\n\n<p translation-result=\"on\">下面的代码节选自 <code>HeroDetailComponent</code>：</p><p translation-origin=\"off\">Here are the pertinent excerpts from that <code>ItemDetailComponent</code>:</p>\n\n<code-example path=\"event-binding/src/app/item-detail/item-detail.component.html\" linenums=\"false\" header=\"src/app/item-detail/item-detail.component.html (template)\" region=\"line-through\">\n&#x3C;img src=\"{{itemImageUrl}}\" [style.display]=\"displayNone\">\n&#x3C;span [style.text-decoration]=\"lineThrough\">{{ item.name }}\n&#x3C;/span>\n&#x3C;button (click)=\"delete()\">Delete&#x3C;/button>\n\n</code-example>\n<code-example path=\"event-binding/src/app/item-detail/item-detail.component.ts\" linenums=\"false\" header=\"src/app/item-detail/item-detail.component.ts (deleteRequest)\" region=\"deleteRequest\">\n// This component makes <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/common/http/testing/TestRequest#request\" class=\"code-anchor\">request</a> but it can't actually delete <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> hero.\n@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() deleteRequest = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;Item>();\n\ndelete() {\n  this.deleteRequest.emit(this.item);\n  this.displayNone = this.displayNone ? '' : 'none';\n  this.lineThrough = this.lineThrough ? '' : 'line-through';\n}\n\n</code-example>\n<p translation-result=\"on\">组件定义了 <code>deleteRequest</code> 属性，它是 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 实例。\n当用户点击<em>删除</em>时，组件会调用 <code>delete()</code> 方法，让 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 发出一个 <code>Hero</code> 对象。</p><p translation-origin=\"off\">The component defines a <code>deleteRequest</code> property that returns an <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code>.\nWhen the user clicks <em>delete</em>, the component invokes the <code>delete()</code> method,\ntelling the <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> to emit an <code>Item</code> object.</p>\n\n<p translation-result=\"on\">现在，假设有个宿主的父组件，它绑定了 <code>HeroDetailComponent</code> 的 <code>deleteRequest</code> 事件。</p><p translation-origin=\"off\">Now imagine a hosting parent component that binds to the <code>deleteRequest</code> event\nof the <code>ItemDetailComponent</code>.</p>\n\n<code-example path=\"event-binding/src/app/app.component.html\" linenums=\"false\" header=\"src/app/app.component.html (event-binding-to-component)\" region=\"event-binding-to-component\">\n&#x3C;app-item-detail (deleteRequest)=\"deleteItem($event)\" [<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>]=\"currentItem\">&#x3C;/app-item-detail>\n\n</code-example>\n<p translation-result=\"on\">当 <code>deleteRequest</code> 事件触发时，Angular 调用父组件的 <code>deleteHero</code> 方法，\n在 <code>$event</code> 变量中传入<em>要删除的英雄</em>（来自 <code>HeroDetail</code>）。</p><p translation-origin=\"off\">When the <code>deleteRequest</code> event fires, Angular calls the parent component's\n<code>deleteItem()</code> method, passing the <em>item-to-delete</em> (emitted by <code>ItemDetail</code>)\nin the <code>$event</code> variable.</p>\n\n<h3 id=\"template-statements-have-side-effects\" translation-result=\"on\">模板语句有副作用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#template-statements-have-side-effects\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"template-statements-have-side-effects\">Template statements have side effects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#template-statements-have-side-effects\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">虽然<a href=\"guide/template-syntax#template-expressions\">模板表达式</a>不应该有<a href=\"guide/template-syntax#avoid-side-effects\">副作用</a>，但是模板语句通常会有。这里的 <code>deleteItem()</code> 方法就有一个副作用：它删除了一个条目。</p><p translation-origin=\"off\">Though <a href=\"guide/template-syntax#template-expressions\">template expressions</a> shouldn't have <a href=\"guide/template-syntax#avoid-side-effects\">side effects</a>, template\nstatements usually do. The <code>deleteItem()</code> method does have\na side effect: it deletes an item.</p>\n\n<p translation-result=\"on\">删除这个英雄会更新模型，还可能触发其它修改，包括向远端服务器的查询和保存。\n这些变更通过系统进行扩散，并最终显示到当前以及其它视图中。</p><p translation-origin=\"off\">Deleting an item updates the model, and depending on your code, triggers\nother changes including queries and saving to a remote server.\nThese changes propagate through the system and ultimately display in this and other views.</p>\n\n<hr>\n<a id=\"two-way\"></a>\n<h2 id=\"two-way-binding---\" translation-result=\"on\">双向数据绑定 ( <span class=\"syntax\">[(...)]</span> )<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#two-way-binding---\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"two-way-binding---\">Two-way binding ( <span class=\"syntax\">[(...)]</span> )<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#two-way-binding---\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你经常需要显示数据属性，并在用户作出更改时更新该属性。</p><p translation-origin=\"off\">You often want to both display a data property and update that property when the user makes changes.</p>\n\n<p translation-result=\"on\">在元素层面上，既要设置元素属性，又要监听元素事件变化。</p><p translation-origin=\"off\">On the element side that takes a combination of setting a specific element property\nand listening for an element change event.</p>\n\n<p translation-result=\"on\">Angular 为此提供一种特殊的<em>双向数据绑定</em>语法：<strong><code>[(x)]</code></strong>。\n<code>[(x)]</code> 语法结合了<em>属性绑定</em>的方括号 <code>[x]</code> 和<em>事件绑定</em>的圆括号 <code>(x)</code>。</p><p translation-origin=\"off\">Angular offers a special <em>two-way data binding</em> syntax for this purpose, <strong><code>[(x)]</code></strong>.\nThe <code>[(x)]</code> syntax combines the brackets\nof <em>property binding</em>, <code>[x]</code>, with the parentheses of <em>event binding</em>, <code>(x)</code>.</p>\n\n<div class=\"callout is-important\">\n<header translation-result=\"on\">[( )] = 盒子里的香蕉</header><header translation-origin=\"off\">[( )] = banana in a box</header>\n\n<p translation-result=\"on\">想象<em>盒子里的香蕉</em>来记住方括号套圆括号。</p><p translation-origin=\"off\">Visualize a <em>banana in a box</em> to remember that the parentheses go <em>inside</em> the brackets.</p>\n\n</div>\n<p translation-result=\"on\">当一个元素拥有可以设置的属性 <code>x</code> 和对应的事件 <code>xChange</code> 时，解释 <code>[(x)]</code> 语法就容易多了。\n下面的 <code>SizerComponent</code> 符合这个模式。它有 <code>size</code> 属性和配套的 <code>sizeChange</code> 事件：</p><p translation-origin=\"off\">The <code>[(x)]</code> syntax is easy to demonstrate when the element has a settable property called <code>x</code>\nand a corresponding event named <code>xChange</code>.\nHere's a <code>SizerComponent</code> that fits the pattern.\nIt has a <code>size</code> value property and a companion <code>sizeChange</code> event:</p>\n\n<code-example path=\"template-syntax/src/app/sizer.component.ts\" header=\"src/app/sizer.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-sizer',\n  template: `\n  &#x3C;div>\n    &#x3C;button (click)=\"dec()\" title=\"smaller\">-&#x3C;/button>\n    &#x3C;button (click)=\"inc()\" title=\"bigger\">+&#x3C;/button>\n    &#x3C;label [style.font-size.px]=\"size\">FontSize: {{size}}px&#x3C;/label>\n  &#x3C;/div>`\n})\nexport class SizerComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()  size: number | string;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() sizeChange = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;number>();\n\n  dec() { this.resize(-1); }\n  inc() { this.resize(+1); }\n\n  resize(delta: number) {\n    this.size = Math.min(40, Math.max(8, +this.size + delta));\n    this.sizeChange.emit(this.size);\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\"><code>size</code> 的初始值是一个输入值，来自属性绑定。（译注：注意 <code>size</code> 前面的 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code>）\n点击按钮，在最小/最大值范围限制内增加或者减少 <code>size</code>。\n然后用调整后的 <code>size</code> 触发 <code>sizeChange</code> 事件。</p><p translation-origin=\"off\">The initial <code>size</code> is an input value from a property binding.\nClicking the buttons increases or decreases the <code>size</code>, within min/max values constraints,\nand then raises (<em>emits</em>) the <code>sizeChange</code> event with the adjusted size.</p>\n\n<p translation-result=\"on\">下面的例子中，<code>AppComponent.fontSize</code> 被双向绑定到 <code>SizerComponent</code>：</p><p translation-origin=\"off\">Here's an example in which the <code>AppComponent.fontSizePx</code> is two-way bound to the <code>SizerComponent</code>:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" linenums=\"false\" header=\"src/app/app.component.html (two-way-1)\" region=\"two-way-1\">\n&#x3C;app-sizer [(size)]=\"fontSizePx\">&#x3C;/app-sizer>\n&#x3C;div [style.font-size.px]=\"fontSizePx\">Resizable Text&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\"><code>SizerComponent.size</code> 初始值是 <code>AppComponent.fontSizePx</code>。\n点击按钮时，通过双向绑定更新 <code>AppComponent.fontSizePx</code>。\n被修改的 <code>AppComponent.fontSizePx</code> 通过<em>样式</em>绑定，改变文本的显示大小。</p><p translation-origin=\"off\">The <code>AppComponent.fontSizePx</code> establishes the initial <code>SizerComponent.size</code> value.\nClicking the buttons updates the <code>AppComponent.fontSizePx</code> via the two-way binding.\nThe revised <code>AppComponent.fontSizePx</code> value flows through to the <em>style</em> binding,\nmaking the displayed text bigger or smaller.</p>\n\n<p translation-result=\"on\">双向绑定语法实际上是<em>属性</em>绑定和<em>事件绑定</em>的语法糖。\nAngular 将 <code>SizerComponent</code> 的绑定分解成这样：</p><p translation-origin=\"off\">The two-way binding syntax is really just syntactic sugar for a <em>property</em> binding and an <em>event</em> binding.\nAngular <em>desugars</em> the <code>SizerComponent</code> binding into this:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" linenums=\"false\" header=\"src/app/app.component.html (two-way-2)\" region=\"two-way-2\">\n&#x3C;app-sizer [size]=\"fontSizePx\" (sizeChange)=\"fontSizePx=$event\">&#x3C;/app-sizer>\n\n</code-example>\n<p translation-result=\"on\"><code>$event</code> 变量包含了 <code>SizerComponent.sizeChange</code> 事件的荷载。\n当用户点击按钮时，Angular 将 <code>$event</code> 赋值给 <code>AppComponent.fontSizePx</code>。</p><p translation-origin=\"off\">The <code>$event</code> variable contains the payload of the <code>SizerComponent.sizeChange</code> event.\nAngular assigns the <code>$event</code> value to the <code>AppComponent.fontSizePx</code> when the user clicks the buttons.</p>\n\n<p translation-result=\"on\">显然，比起单独绑定属性和事件，双向数据绑定语法显得非常方便。</p><p translation-origin=\"off\">Clearly the two-way binding syntax is a great convenience compared to separate property and event bindings.</p>\n\n<p translation-result=\"on\">如果能在像 <code>&#x3C;input></code> 和 <code>&#x3C;select></code> 这样的 HTML 元素上使用双向数据绑定就更好了。\n可惜，原生 HTML 元素不遵循 <code>x</code> 值和 <code>xChange</code> 事件的模式。</p><p translation-origin=\"off\">It would be convenient to use two-way binding with HTML form elements like <code>&#x3C;input></code> and <code>&#x3C;select></code>.\nHowever, no native HTML element follows the <code>x</code> value and <code>xChange</code> event pattern.</p>\n\n<p translation-result=\"on\">幸运的是，Angular 以 <a href=\"guide/template-syntax#ngModel\"><em>NgModel</em></a> 指令为桥梁，允许在表单元素上使用双向数据绑定。</p><p translation-origin=\"off\">Fortunately, the Angular <a href=\"guide/template-syntax#ngModel\"><em>NgModel</em></a> directive is a bridge that enables two-way binding to form elements.</p>\n\n<hr>\n<a id=\"directives\"></a>\n<h2 id=\"built-in-directives\" translation-result=\"on\">内置指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#built-in-directives\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"built-in-directives\">Built-in directives<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#built-in-directives\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">上一版本的 Angular 中包含了超过 70 个内置指令。\n社区贡献了更多，这还没算为内部应用而创建的无数私有指令。</p><p translation-origin=\"off\">Earlier versions of Angular included over seventy built-in directives.\nThe community contributed many more, and countless private directives\nhave been created for internal applications.</p>\n\n<p translation-result=\"on\">在新版的 Angular 中不需要那么多指令。\n使用更强大、更富有表现力的 Angular 绑定系统，其实可以达到同样的效果。\n如果能用简单的绑定达到目的，为什么还要创建指令来处理点击事件呢？</p><p translation-origin=\"off\">You don't need many of those directives in Angular.\nYou can often achieve the same results with the more capable and expressive Angular binding system.\nWhy create a directive to handle a click when you can write a simple binding such as this?</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"event-binding-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button (click)=\"onSave()\">Save&#x3C;/button>\n\n</code-example>\n<p translation-result=\"on\">你仍然可以从简化复杂任务的指令中获益。\nAngular 发布时仍然带有内置指令，只是没那么多了。\n你仍会写自己的指令，只是没那么多了。</p><p translation-origin=\"off\">You still benefit from directives that simplify complex tasks.\nAngular still ships with built-in directives; just not as many.\nYou'll write your own directives, just not as many.</p>\n\n<p translation-result=\"on\">下面来看一下那些最常用的内置指令。它们可分为<a href=\"guide/template-syntax#attribute-directives\"><em>属性型</em>指令</a> 或 <a href=\"guide/template-syntax#structural-directives\"><em>结构型</em>指令</a>。</p><p translation-origin=\"off\">This segment reviews some of the most frequently used built-in directives,\nclassified as either <a href=\"guide/template-syntax#attribute-directives\"><em>attribute</em> directives</a> or <a href=\"guide/template-syntax#structural-directives\"><em>structural</em> directives</a>.</p>\n\n<hr>\n<a id=\"attribute-directives\"></a>\n<h2 id=\"built-in-attribute-directives\" translation-result=\"on\">内置<em>属性型</em>指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#built-in-attribute-directives\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"built-in-attribute-directives\">Built-in <em>attribute</em> directives<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#built-in-attribute-directives\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">属性型指令会监听和修改其它 HTML 元素或组件的行为、元素属性（Attribute）、DOM 属性（Property）。\n它们通常会作为 HTML 属性的名称而应用在元素上。</p><p translation-origin=\"off\">Attribute directives listen to and modify the behavior of\nother HTML elements, attributes, properties, and components.\nThey are usually applied to elements as if they were HTML attributes, hence the name.</p>\n\n<p translation-result=\"on\">更多的细节参见<a href=\"guide/attribute-directives\"><em>属性型指令</em></a>一章。\n很多 NgModules，比如<a href=\"guide/router\" title=\"Routing and Navigation\"><code>RouterModule</code></a>和<a href=\"guide/forms\" title=\"Forms\"><code>FormsModule</code></a>都定义了自己的属性型指令。\n本节将会介绍几个最常用的属性型指令：</p><p translation-origin=\"off\">Many details are covered in the <a href=\"guide/attribute-directives\"><em>Attribute Directives</em></a> guide.\nMany NgModules such as the <a href=\"guide/router\" title=\"Routing and Navigation\"><code>RouterModule</code></a>\nand the <a href=\"guide/forms\" title=\"Forms\"><code>FormsModule</code></a> define their own attribute directives.\nThis section is an introduction to the most commonly used attribute directives:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> <a href=\"guide/template-syntax#ngClass\"><code>NgClass</code></a> - 添加或移除一组 CSS 类</p><p translation-origin=\"off\"><a href=\"guide/template-syntax#ngClass\"><code>NgClass</code></a> - add and remove a set of CSS classes</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> <a href=\"guide/template-syntax#ngStyle\"><code>NgStyle</code></a> - 添加或移除一组 CSS 样式</p><p translation-origin=\"off\"><a href=\"guide/template-syntax#ngStyle\"><code>NgStyle</code></a> - add and remove a set of HTML styles</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> <a href=\"guide/template-syntax#ngModel\"><code>NgModel</code></a> - 双向绑定到 HTML 表单元素</p><p translation-origin=\"off\"><a href=\"guide/template-syntax#ngModel\"><code>NgModel</code></a> - two-way data binding to an HTML form element</p>\n\n</li>\n</ul>\n<hr>\n<a id=\"ngClass\"></a>\n<h3 id=\"ngclass\">NgClass<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngclass\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">你经常用动态添加或删除 CSS 类的方式来控制元素如何显示。\n通过绑定到 <code><a href=\"api/common/NgClass\" class=\"code-anchor\">NgClass</a></code>，可以同时添加或移除多个类。</p><p translation-origin=\"off\">You typically control how elements appear\nby adding and removing CSS classes dynamically.\nYou can bind to the <code><a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a></code> to add or remove several classes simultaneously.</p>\n\n<p translation-result=\"on\"><a href=\"guide/template-syntax#class-binding\">CSS 类绑定</a> 是添加或删除<em>单个</em>类的最佳途径。</p><p translation-origin=\"off\">A <a href=\"guide/template-syntax#class-binding\">class binding</a> is a good way to add or remove a <em>single</em> class.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"class-binding-3a\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- toggle the \"special\" class on/off with <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> property -->\n&#x3C;div [class.special]=\"isSpecial\">The class binding is special&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\">当想要同时添加或移除<em>多个</em> CSS 类时，<code><a href=\"api/common/NgClass\" class=\"code-anchor\">NgClass</a></code> 指令可能是更好的选择。</p><p translation-origin=\"off\">To add or remove <em>many</em> CSS classes at the same time, the <code><a href=\"api/common/NgClass\" class=\"code-anchor\">NgClass</a></code> directive may be the better choice.</p>\n\n<p translation-result=\"on\">试试把 <code><a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a></code> 绑定到一个 key:value 形式的控制对象。这个对象中的每个 key 都是一个 CSS 类名，如果它的 value 是 <code>true</code>，这个类就会被加上，否则就会被移除。</p><p translation-origin=\"off\">Try binding <code><a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a></code> to a key:value control object.\nEach key of the object is a CSS class name; its value is <code>true</code> if the class should be added,\n<code>false</code> if it should be removed.</p>\n\n<p translation-result=\"on\">组件方法 <code>setCurrentClasses</code> 可以把组件的属性 <code>currentClasses</code> 设置为一个对象，它将会根据三个其它组件的状态为 <code>true</code> 或 <code>false</code> 而添加或移除三个类。</p><p translation-origin=\"off\">Consider a <code>setCurrentClasses</code> component method that sets a component property,\n<code>currentClasses</code> with an object that adds or removes three classes based on the\n<code>true</code>/<code>false</code> state of three other component properties:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.ts\" region=\"setClasses\" header=\"src/app/app.component.ts\" linenums=\"false\">\ncurrentClasses: {};\nsetCurrentClasses() {\n  // CSS <a href=\"api/core/DebugElement#classes\" class=\"code-anchor\">classes</a>: added/removed per current <a href=\"api/animations/state\" class=\"code-anchor\">state</a> of component <a href=\"api/core/DebugElement#properties\" class=\"code-anchor\">properties</a>\n  this.currentClasses =  {\n    'saveable': this.canSave,\n    'modified': !this.isUnchanged,\n    'special':  this.isSpecial\n  };\n}\n\n</code-example>\n<p translation-result=\"on\">把 <code><a href=\"api/common/NgClass\" class=\"code-anchor\">NgClass</a></code> 属性绑定到 <code>currentClasses</code>，根据它来设置此元素的 CSS 类：</p><p translation-origin=\"off\">Adding an <code><a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a></code> property binding to <code>currentClasses</code> sets the element's classes accordingly:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgClass-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"currentClasses\">This div is initially saveable, unchanged, and special&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">你既可以在初始化时调用 <code>setCurrentClasses()</code>，也可以在所依赖的属性变化时调用。</p><p translation-origin=\"off\">It's up to you to call <code>setCurrentClasses()</code>, both initially and when the dependent properties change.</p>\n\n</div>\n<hr>\n<a id=\"ngStyle\"></a>\n<h3 id=\"ngstyle\">NgStyle<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngstyle\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">你可以根据组件的状态动态设置内联样式。\n<code><a href=\"api/common/NgStyle\" class=\"code-anchor\">NgStyle</a></code> 绑定可以同时设置多个内联样式。</p><p translation-origin=\"off\">You can set inline styles dynamically, based on the state of the component.\nWith <code><a href=\"api/common/NgStyle\" class=\"code-anchor\">NgStyle</a></code> you can set many inline styles simultaneously.</p>\n\n<p translation-result=\"on\"><a href=\"guide/template-syntax#style-binding\">样式绑定</a>是设置<em>单一</em>样式值的简单方式。</p><p translation-origin=\"off\">A <a href=\"guide/template-syntax#style-binding\">style binding</a> is an easy way to set a <em>single</em> style value.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgStyle-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div [style.font-size]=\"isSpecial ? 'x-large' : 'smaller'\" >\n  This div is x-large or smaller.\n&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\">如果要同时设置<em>多个</em>内联样式，<code><a href=\"api/common/NgStyle\" class=\"code-anchor\">NgStyle</a></code> 指令可能是更好的选择。</p><p translation-origin=\"off\">To set <em>many</em> inline styles at the same time, the <code><a href=\"api/common/NgStyle\" class=\"code-anchor\">NgStyle</a></code> directive may be the better choice.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/common/NgStyle\" class=\"code-anchor\">NgStyle</a></code> 需要绑定到一个 key:value 控制对象。\n对象的每个 key 是样式名，它的 value 是能用于这个样式的任何值。</p><p translation-origin=\"off\">Try binding <code><a href=\"api/common/NgStyle\" class=\"code-anchor\">ngStyle</a></code> to a key:value control object.\nEach key of the object is a style name; its value is whatever is appropriate for that style.</p>\n\n<p translation-result=\"on\">来看看组件的 <code>setCurrentStyles</code> 方法，它会根据另外三个属性的状态把组件的 <code>currentStyles</code> 属性设置为一个定义了三个样式的对象：</p><p translation-origin=\"off\">Consider a <code>setCurrentStyles</code> component method that sets a component property, <code>currentStyles</code>\nwith an object that defines three styles, based on the state of three other component properties:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.ts\" region=\"setStyles\" header=\"src/app/app.component.ts\" linenums=\"false\">\ncurrentStyles: {};\nsetCurrentStyles() {\n  // CSS styles: set per current <a href=\"api/animations/state\" class=\"code-anchor\">state</a> of component <a href=\"api/core/DebugElement#properties\" class=\"code-anchor\">properties</a>\n  this.currentStyles = {\n    'font-style':  this.canSave      ? 'italic' : 'normal',\n    'font-weight': !this.isUnchanged ? 'bold'   : 'normal',\n    'font-size':   this.isSpecial    ? '24px'   : '12px'\n  };\n}\n\n</code-example>\n<p translation-result=\"on\">把 <code><a href=\"api/common/NgStyle\" class=\"code-anchor\">ngStyle</a></code> 属性绑定到 <code>currentStyles</code>，来根据它设置此元素的样式：</p><p translation-origin=\"off\">Adding an <code><a href=\"api/common/NgStyle\" class=\"code-anchor\">ngStyle</a></code> property binding to <code>currentStyles</code> sets the element's styles accordingly:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgStyle-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div [<a href=\"api/common/NgStyle\" class=\"code-anchor\">ngStyle</a>]=\"currentStyles\">\n  This div is initially italic, normal weight, and extra large (24px).\n&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">你既可以在初始化时调用 <code>setCurrentStyles()</code>，也可以在所依赖的属性变化时调用。</p><p translation-origin=\"off\">It's up to you to call <code>setCurrentStyles()</code>, both initially and when the dependent properties change.</p>\n\n</div>\n<hr>\n<a id=\"ngModel\"></a>\n<h3 id=\"ngmodel---two-way-binding-to-form-elements-with-ngmodel\" translation-result=\"on\">NgModel - 使用<span class=\"syntax\">[(ngModel)]</span>双向绑定到表单元素<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngmodel---two-way-binding-to-form-elements-with-ngmodel\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"ngmodel---two-way-binding-to-form-elements-with-ngmodel\">NgModel - Two-way binding to form elements with <span class=\"syntax\">[(ngModel)]</span><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngmodel---two-way-binding-to-form-elements-with-ngmodel\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">当开发数据输入表单时，你通常都要既显示数据属性又根据用户的更改去修改那个属性。</p><p translation-origin=\"off\">When developing data entry forms, you often both display a data property and\nupdate that property when the user makes changes.</p>\n\n<p translation-result=\"on\">使用 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 指令进行双向数据绑定可以简化这种工作。例子如下：</p><p translation-origin=\"off\">Two-way data binding with the <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> directive makes that easy. Here's an example:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" linenums=\"false\" header=\"src/app/app.component.html (NgModel-1)\" region=\"NgModel-1\">\n&#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"currentHero.name\">\n\n</code-example>\n<h4 id=\"formsmodule-is-required-to-use-ngmodel\" translation-result=\"on\">使用 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 时需要 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#formsmodule-is-required-to-use-ngmodel\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"formsmodule-is-required-to-use-ngmodel\"><em>FormsModule</em> is required to use <em>ngModel</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#formsmodule-is-required-to-use-ngmodel\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">在使用 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 指令进行双向数据绑定之前，你必须导入 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 并把它添加到 NgModule 的 <code>imports</code> 列表中。\n要了解 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 和 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 的更多知识，参见<a href=\"guide/forms#ngModel\">表单</a>一章。</p><p translation-origin=\"off\">Before using the <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> directive in a two-way data binding,\nyou must import the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> and add it to the NgModule's <code>imports</code> list.\nLearn more about the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> and <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> in the\n<a href=\"guide/forms#ngModel\">Forms</a> guide.</p>\n\n<p translation-result=\"on\">导入 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 并让 <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> 可用的代码如下：</p><p translation-origin=\"off\">Here's how to import the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> to make <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> available.</p>\n\n<code-example path=\"template-syntax/src/app/app.module.1.ts\" linenums=\"false\" header=\"src/app/app.module.ts (FormsModule import)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> }  from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms'; // &#x3C;--- JavaScript import from Angular\n\n/* <a href=\"api/common/Plural#Other\" class=\"code-anchor\">Other</a> imports */\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>  // &#x3C;--- import into the <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>\n  ],\n  /* <a href=\"api/common/Plural#Other\" class=\"code-anchor\">Other</a> module metadata */\n})\nexport class AppModule { }\n\n\n</code-example>\n<h4 id=\"inside-ngmodel\" translation-result=\"on\"><span class=\"syntax\">[(ngModel)]</span>内幕<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#inside-ngmodel\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"inside-ngmodel\">Inside <span class=\"syntax\">[(ngModel)]</span><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#inside-ngmodel\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">回头看看 <code>name</code> 绑定，注意，你可以通过分别绑定到 <code>&#x3C;input></code> 元素的 <code>value</code> 属性和 <code>input</code> 事件来达到同样的效果。</p><p translation-origin=\"off\">Looking back at the <code>name</code> binding, note that\nyou could have achieved the same result with separate bindings to\nthe <code>&#x3C;input></code> element's  <code>value</code> property and <code>input</code> event.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"without-NgModel\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;input [value]=\"currentHero.name\"\n       (input)=\"currentHero.name=$event.target.value\" >\n\n</code-example>\n<p translation-result=\"on\">那样显得很笨重，谁会记得该设置哪个元素属性以及当用户修改时触发哪个事件？\n你该如何提取输入框中的文本并且更新数据属性？谁会希望每次都去查资料来确定这些？</p><p translation-origin=\"off\">That's cumbersome. Who can remember which element property to set and which element event emits user changes?\nHow do you extract the currently displayed text from the input box so you can update the data property?\nWho wants to look that up each time?</p>\n\n<p translation-result=\"on\"><code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 指令通过自己的输入属性 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 和输出属性 <code>ngModelChange</code> 隐藏了那些细节。</p><p translation-origin=\"off\">That <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> directive hides these onerous details behind its own  <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> input and <code>ngModelChange</code> output properties.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgModel-3\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;input\n  [<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>]=\"currentHero.name\"\n  (ngModelChange)=\"currentHero.name=$event\">\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 输入属性会设置该元素的值，并通过 <code>ngModelChange</code> 的输出属性来监听元素值的变化。</p><p translation-origin=\"off\">The <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> data property sets the element's value property and the <code>ngModelChange</code> event property\nlistens for changes to the element's value.</p>\n\n<p translation-result=\"on\">各种元素都有很多特有的处理细节，因此 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 指令只支持实现了<a href=\"api/forms/ControlValueAccessor\">ControlValueAccessor</a>的元素，\n它们能让元素适配本协议。\n<code>&#x3C;input></code> 输入框正是其中之一。\nAngular 为所有的基础 HTML 表单都提供了<em>值访问器（Value accessor）</em>，<a href=\"guide/forms\"><em>表单</em></a>一章展示了如何绑定它们。</p><p translation-origin=\"off\">The details are specific to each kind of element and therefore the <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> directive only works for an element\nsupported by a <a href=\"api/forms/ControlValueAccessor\">ControlValueAccessor</a>\nthat adapts an element to this protocol.\nThe <code>&#x3C;input></code> box is one of those elements.\nAngular provides <em>value accessors</em> for all of the basic HTML form elements and the\n<a href=\"guide/forms\"><em>Forms</em></a> guide shows how to bind to them.</p>\n\n<p translation-result=\"on\">你不能把 <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> 用到非表单类的原生元素或第三方自定义组件上，除非写一个合适的<em>值访问器</em>，这种技巧超出了本章的范围。</p><p translation-origin=\"off\">You can't apply <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> to a non-form native element or a third-party custom component\nuntil you write a suitable <em>value accessor</em>,\na technique that is beyond the scope of this guide.</p>\n\n<p translation-result=\"on\">你自己写的 Angular 组件不需要<em>值访问器</em>，因为你可以让值和事件的属性名适应 Angular 基本的<a href=\"guide/template-syntax#two-way\">双向绑定语法</a>，而不使用 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code>。\n<a href=\"guide/template-syntax#two-way\">前面看过的 <code>sizer</code></a>就是使用这种技巧的例子。</p><p translation-origin=\"off\">You don't need a <em>value accessor</em> for an Angular component that you write because you\ncan name the value and event properties\nto suit Angular's basic <a href=\"guide/template-syntax#two-way\">two-way binding syntax</a> and skip <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> altogether.\nThe <a href=\"guide/template-syntax#two-way\"><code>sizer</code> shown above</a> is an example of this technique.</p>\n\n</div>\n<p translation-result=\"on\">使用独立的 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 绑定优于绑定到该元素的原生属性，你可以做得更好。</p><p translation-origin=\"off\">Separate <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> bindings is an improvement over binding to the element's native properties. You can do better.</p>\n\n<p translation-result=\"on\">你不用被迫两次引用这个数据属性，Angular 可以捕获该元素的数据属性，并且通过一个简单的声明来设置它，这样它就可以使用 <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> 语法了。</p><p translation-origin=\"off\">You shouldn't have to mention the data property twice. Angular should be able to capture\nthe component's data property and set it\nwith a single declaration, which it can with the <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> syntax:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgModel-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"currentHero.name\">\n\n</code-example>\n<p translation-result=\"on\"><code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> 就是你需要的一切吗？有没有什么理由回退到它的展开形式？</p><p translation-origin=\"off\">Is <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> all you need? Is there ever a reason to fall back to its expanded form?</p>\n\n<p translation-result=\"on\"><code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> 语法只能<em>设置</em>数据绑定属性。\n如果要做更多或者做点不一样的事，也可以写它的展开形式。</p><p translation-origin=\"off\">The <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> syntax can only <em>set</em> a data-bound property.\nIf you need to do something more or something different, you can write the expanded form.</p>\n\n<p translation-result=\"on\">下面这个生造的例子强制输入框的内容变成大写：</p><p translation-origin=\"off\">The following contrived example forces the input value to uppercase:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgModel-4\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;input\n  [<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>]=\"currentHero.name\"\n  (ngModelChange)=\"setUppercaseName($event)\">\n\n</code-example>\n<p translation-result=\"on\">这里是所有这些变体的动画，包括这个大写转换的版本：</p><p translation-origin=\"off\">Here are all variations in action, including the uppercase version:</p>\n\n<figure>\n  <img src=\"generated/images/guide/template-syntax/ng-model-anim.gif\" alt=\"NgModel variations\" width=\"548\" height=\"208\">\n</figure>\n<hr>\n<a id=\"structural-directives\"></a>\n<h2 id=\"built-in-structural-directives\" translation-result=\"on\">内置<em>结构型</em>指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#built-in-structural-directives\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"built-in-structural-directives\">Built-in <em>structural</em> directives<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#built-in-structural-directives\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">结构型指令的职责是 HTML 布局。\n它们塑造或重塑 DOM 的<em>结构</em>，这通常是通过添加、移除和操纵它们所附加到的宿主元素来实现的。</p><p translation-origin=\"off\">Structural directives are responsible for HTML layout.\nThey shape or reshape the DOM's <em>structure</em>, typically by adding, removing, and manipulating\nthe host elements to which they are attached.</p>\n\n<p translation-result=\"on\">关于结构型指令的详情参见<a href=\"guide/structural-directives\"><em>结构型指令</em></a>一章，在那里你将学到：</p><p translation-origin=\"off\">The deep details of structural directives are covered in the\n<a href=\"guide/structural-directives\"><em>Structural Directives</em></a> guide\nwhere you'll learn:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">   为什么要<a href=\"guide/structural-directives#asterisk\" title=\"The * in *ngIf\">给结构型指令的名字加上(*)前缀？</a></p><p translation-origin=\"off\">why you\n<a href=\"guide/structural-directives#asterisk\" title=\"The * in *ngIf\"><em>prefix the directive name with an asterisk</em> (*)</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">   当没有合适的宿主元素放置指令时，可用 <a href=\"guide/structural-directives#ngcontainer\" title=\"<ng-container>\"><code>&#x3C;ng-container></code></a> 对元素进行分组。</p><p translation-origin=\"off\">to use <a href=\"guide/structural-directives#ngcontainer\" title=\"<ng-container>\"><code>&#x3C;ng-container></code></a>\nto group elements when there is no suitable host element for the directive.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 如何写自己的结构型指令。</p><p translation-origin=\"off\">how to write your own structural directive.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 你只能往一个元素上应用<a href=\"guide/structural-directives#one-per-element\" title=\"one per host element\">一个结构型指令</a>。</p><p translation-origin=\"off\">that you can only apply <a href=\"guide/structural-directives#one-per-element\" title=\"one per host element\">one structural directive</a> to an element.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\"><em>本节</em>是对常见结构型指令的简介：</p><p translation-origin=\"off\"><em>This</em> section is an introduction to the common structural directives:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> <a href=\"guide/template-syntax#ngIf\"><code>NgIf</code></a> - 根据条件把一个元素添加到 DOM 中或从 DOM 移除</p><p translation-origin=\"off\"><a href=\"guide/template-syntax#ngIf\"><code>NgIf</code></a> - conditionally add or remove an element from the DOM</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> <a href=\"guide/template-syntax#ngSwitch\"><code>NgSwitch</code></a> 一组指令，用来在多个可选视图之间切换。</p><p translation-origin=\"off\"><a href=\"guide/template-syntax#ngSwitch\"><code>NgSwitch</code></a> - a set of directives that switch among alternative views</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> <a href=\"guide/template-syntax#ngFor\">NgForOf</a> - 对列表中的每个条目重复套用同一个模板</p><p translation-origin=\"off\"><a href=\"guide/template-syntax#ngFor\">NgForOf</a> - repeat a template for each item in a list</p>\n\n</li>\n</ul>\n<hr>\n<a id=\"ngIf\"></a>\n<h3 id=\"ngif\">NgIf<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngif\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">通过把 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 指令应用到元素上（称为<em>宿主元素</em>），你可以往 DOM 中添加或从 DOM 中移除这个元素。\n在下面的例子中，该指令绑定到了类似于 <code><a href=\"api/router/RouterLinkActive#isActive\" class=\"code-anchor\">isActive</a></code> 这样的条件表达式。</p><p translation-origin=\"off\">You can add or remove an element from the DOM by applying an <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> directive to\nthat element (called the <em>host element</em>).\nBind the directive to a condition expression like <code><a href=\"api/router/RouterLinkActive#isActive\" class=\"code-anchor\">isActive</a></code> in this example.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgIf-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;app-hero-detail *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"<a href=\"api/router/RouterLinkActive#isActive\" class=\"code-anchor\">isActive</a>\">&#x3C;/app-hero-detail>\n\n</code-example>\n<div class=\"alert is-critical\">\n<p translation-result=\"on\">别忘了 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 前面的星号(<code>*</code>)。</p><p translation-origin=\"off\">Don't forget the asterisk (<code>*</code>) in front of <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>.</p>\n\n</div>\n<p translation-result=\"on\">当 <code><a href=\"api/router/RouterLinkActive#isActive\" class=\"code-anchor\">isActive</a></code> 表达式返回真值时，<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 把 <code>HeroDetailComponent</code> 添加到 DOM 中；为假时，<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 会从 DOM 中移除 <code>HeroDetailComponent</code>，并销毁该组件及其所有子组件。</p><p translation-origin=\"off\">When the <code><a href=\"api/router/RouterLinkActive#isActive\" class=\"code-anchor\">isActive</a></code> expression returns a truthy value, <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> adds the <code>HeroDetailComponent</code> to the DOM.\nWhen the expression is falsy, <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> removes the <code>HeroDetailComponent</code>\nfrom the DOM, destroying that component and all of its sub-components.</p>\n\n<h4 id=\"showhide-is-not-the-same-thing\" translation-result=\"on\">这和显示/隐藏不是一回事<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#showhide-is-not-the-same-thing\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"showhide-is-not-the-same-thing\">Show/hide is not the same thing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#showhide-is-not-the-same-thing\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">你也可以通过<a href=\"guide/template-syntax#class-binding\">类绑定</a>或<a href=\"guide/template-syntax#style-binding\">样式绑定</a>来显示或隐藏一个元素。</p><p translation-origin=\"off\">You can control the visibility of an element with a\n<a href=\"guide/template-syntax#class-binding\">class</a> or <a href=\"guide/template-syntax#style-binding\">style</a> binding:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgIf-3\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- isSpecial is true -->\n&#x3C;div [class.hidden]=\"!isSpecial\">Show with class&#x3C;/div>\n&#x3C;div [class.hidden]=\"isSpecial\">Hide with class&#x3C;/div>\n\n&#x3C;!-- HeroDetail is in the DOM but hidden -->\n&#x3C;app-hero-detail [class.hidden]=\"isSpecial\">&#x3C;/app-hero-detail>\n\n&#x3C;div [style.display]=\"isSpecial ? 'block' : 'none'\">Show with <a href=\"api/animations/style\" class=\"code-anchor\">style</a>&#x3C;/div>\n&#x3C;div [style.display]=\"isSpecial ? 'none'  : 'block'\">Hide with <a href=\"api/animations/style\" class=\"code-anchor\">style</a>&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\">但隐藏子树和用 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 排除子树是截然不同的。</p><p translation-origin=\"off\">Hiding an element is quite different from removing an element with <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>.</p>\n\n<p translation-result=\"on\">当隐藏子树时，它仍然留在 DOM 中。\n子树中的组件及其状态仍然保留着。\n即使对于不可见属性，Angular 也会继续检查变更。\n子树可能占用相当可观的内存和运算资源。</p><p translation-origin=\"off\">When you hide an element, that element and all of its descendents remain in the DOM.\nAll components for those elements stay in memory and\nAngular may continue to check for changes.\nYou could be holding onto considerable computing resources and degrading performance,\nfor something the user can't see.</p>\n\n<p translation-result=\"on\">当 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 为 <code>false</code> 时，Angular 从 DOM 中物理地移除了这个元素子树。\n它销毁了子树中的组件及其状态，也潜在释放了可观的资源，最终让用户体验到更好的性能。</p><p translation-origin=\"off\">When <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> is <code>false</code>, Angular removes the element and its descendents from the DOM.\nIt destroys their components, potentially freeing up substantial resources,\nresulting in a more responsive user experience.</p>\n\n<p translation-result=\"on\">显示/隐藏的技术对于只有少量子元素的元素是很好用的，但要当心别试图隐藏大型组件树。相比之下，<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 则是个更安全的选择。</p><p translation-origin=\"off\">The show/hide technique is fine for a few elements with few children.\nYou should be wary when hiding large component trees; <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> may be the safer choice.</p>\n\n<h4 id=\"guard-against-null\" translation-result=\"on\">防范空指针错误<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#guard-against-null\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"guard-against-null\">Guard against null<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#guard-against-null\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 指令通常会用来防范空指针错误。\n而显示/隐藏的方式是无法防范的，当一个表达式尝试访问空值的属性时，Angular 就会抛出一个异常。</p><p translation-origin=\"off\">The <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> directive is often used to guard against null.\nShow/hide is useless as a guard.\nAngular will throw an error if a nested expression tries to access a property of <code>null</code>.</p>\n\n<p translation-result=\"on\">这里我们用 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 来保护了两个 <code>&#x3C;div></code> 防范空指针错误。\n<code>currentHero</code> 的名字只有当存在 <code>currentHero</code> 时才会显示出来。\n而 <code>nullHero</code> 永远不会显示。</p><p translation-origin=\"off\">Here we see <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> guarding two <code>&#x3C;div></code>s.\nThe <code>currentHero</code> name will appear only when there is a <code>currentHero</code>.\nThe <code>nullHero</code> will never be displayed.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgIf-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"currentHero\">Hello, {{currentHero.name}}&#x3C;/div>\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"nullHero\">Hello, {{nullHero.name}}&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">参见稍后的<a href=\"guide/template-syntax#safe-navigation-operator\" title=\"Safe naviation operator (?.)\"><em>安全导航操作符</em></a>部分。</p><p translation-origin=\"off\">See also the\n<a href=\"guide/template-syntax#safe-navigation-operator\" title=\"Safe navigation operator (?.)\"><em>safe navigation operator</em></a>\ndescribed below.</p>\n\n</div>\n<hr>\n<a id=\"ngFor\"></a>\n<h3 id=\"ngforof\">NgForOf<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngforof\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\"><code>NgFor</code> 是一个<em>重复器</em>指令 —— 自定义数据显示的一种方式。\n你的目标是展示一个由多个条目组成的列表。首先定义了一个 HTML 块，它规定了单个条目应该如何显示。\n再告诉 Angular 把这个块当做模板，渲染列表中的每个条目。</p><p translation-origin=\"off\"><code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> is a <em>repeater</em> directive — a way to present a list of items.\nYou define a block of HTML that defines how a single item should be displayed.\nYou tell Angular to use that block as a template for rendering each item in the list.</p>\n\n<p translation-result=\"on\">下例中，<code>NgFor</code> 应用在一个简单的 <code>&#x3C;div></code> 上：</p><p translation-origin=\"off\">Here is an example of <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> applied to a simple <code>&#x3C;div></code>:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgFor-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">{{hero.name}}&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\">也可以把 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 应用在一个组件元素上，就下例这样：</p><p translation-origin=\"off\">You can also apply an <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> to a component element, as in this example:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgFor-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;app-hero-detail *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" [hero]=\"hero\">&#x3C;/app-hero-detail>\n\n</code-example>\n<div class=\"alert is-critical\">\n<p translation-result=\"on\">不要忘了 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 前面的星号 (<code>*</code>)。</p><p translation-origin=\"off\">Don't forget the asterisk (<code>*</code>) in front of <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>.</p>\n\n</div>\n<p translation-result=\"on\">赋值给 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 的文本是用于指导重复器如何工作的指令。</p><p translation-origin=\"off\">The text assigned to <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> is the instruction that guides the repeater process.</p>\n\n<a id=\"microsyntax\"></a>\n<h4 id=\"ngfor-microsyntax\" translation-result=\"on\">NgFor 微语法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngfor-microsyntax\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"ngfor-microsyntax\">*ngFor microsyntax<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngfor-microsyntax\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">赋值给 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 的字符串不是<a href=\"guide/template-syntax#template-expressions\">模板表达式</a>。\n它是一个<em>微语法</em> —— 由 Angular 自己解释的小型语言。在这个例子中，字符串 <code>\"let hero of heroes\"</code> 的含义是：</p><p translation-origin=\"off\">The string assigned to <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> is not a <a href=\"guide/template-syntax#template-expressions\">template expression</a>.\nIt's a <em>microsyntax</em> — a little language of its own that Angular interprets.\nThe string <code>\"let hero of heroes\"</code> means:</p>\n\n<blockquote>\n<p translation-result=\"on\"><em>取出 <code>heroes</code> 数组中的每个英雄，把它存入局部变量 <code>hero</code> 中，并在每次迭代时对模板 HTML 可用</em></p><p translation-origin=\"off\"><em>Take each hero in the <code>heroes</code> array, store it in the local <code>hero</code> looping variable, and\nmake it available to the templated HTML for each iteration.</em></p>\n\n</blockquote>\n<p translation-result=\"on\">Angular 把这个指令翻译成了一个 <code>&#x3C;ng-template></code> 包裹的宿主元素，然后使用这个模板重复创建出一组新元素，并且绑定到列表中的每一个 <code>hero</code>。</p><p translation-origin=\"off\">Angular translates this instruction into a <code>&#x3C;ng-template></code> around the host element,\nthen uses this template repeatedly to create a new set of elements and bindings for each <code>hero</code>\nin the list.</p>\n\n<p translation-result=\"on\">要了解<em>微语法</em>的更多知识，参见<a href=\"guide/structural-directives#microsyntax\"><em>结构型指令</em></a>一章。</p><p translation-origin=\"off\">Learn about the <em>microsyntax</em> in the <a href=\"guide/structural-directives#microsyntax\"><em>Structural Directives</em></a> guide.</p>\n\n<a id=\"template-input-variable\"></a>\n<a id=\"template-input-variables\"></a>\n<h3 id=\"template-input-variables\" translation-result=\"on\">模板输入变量<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#template-input-variables\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"template-input-variables\">Template input variables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#template-input-variables\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>hero</code> 前的 <code>let</code> 关键字创建了一个名叫 <code>hero</code> 的<em>模板输入变量</em>。\n<code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 指令在由父组件的 <code>heroes</code> 属性返回的 <code>heroes</code> 数组上迭代，每次迭代都从数组中把当前元素赋值给 <code>hero</code> 变量。</p><p translation-origin=\"off\">The <code>let</code> keyword before <code>hero</code> creates a <em>template input variable</em> called <code>hero</code>.\nThe <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> directive iterates over the <code>heroes</code> array returned by the parent component's <code>heroes</code> property\nand sets <code>hero</code> to the current item from the array during each iteration.</p>\n\n<p translation-result=\"on\">你可以在 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 的宿主元素（及其子元素）中引用模板输入变量 <code>hero</code>，从而访问该英雄的属性。\n这里的第一个语句示范了如何在一个插值中引用它，第二个语句则示范了如何用一个输入绑定把它传给 <code>&#x3C;hero-detail></code> 组件的 <code>hero</code> 属性。</p><p translation-origin=\"off\">You reference the <code>hero</code> input variable within the <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> host element\n(and within its descendants) to access the hero's properties.\nHere it is referenced first in an interpolation\nand then passed in a binding to the <code>hero</code> property of the <code>&#x3C;hero-detail></code> component.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgFor-1-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">{{hero.name}}&#x3C;/div>\n&#x3C;app-hero-detail *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" [hero]=\"hero\">&#x3C;/app-hero-detail>\n\n</code-example>\n<p translation-result=\"on\">要了解更多<em>模板输入变量</em>的知识，参见<a href=\"guide/structural-directives#template-input-variable\"><em>结构型指令</em></a>一章。</p><p translation-origin=\"off\">Learn more about <em>template input variables</em> in the\n<a href=\"guide/structural-directives#template-input-variable\"><em>Structural Directives</em></a> guide.</p>\n\n<h4 id=\"ngfor-with-index\" translation-result=\"on\">带索引的 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngfor-with-index\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"ngfor-with-index\">*ngFor with <em>index</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngfor-with-index\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><code>NgFor</code> 指令上下文中的 <code>index</code> 属性返回一个从零开始的索引，表示当前条目在迭代中的顺序。\n你可以通过模板输入变量捕获这个 <code>index</code> 值，并把它用在模板中。</p><p translation-origin=\"off\">The <code>index</code> property of the <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> directive context returns the zero-based index of the item in each iteration.\nYou can capture the <code>index</code> in a template input variable and use it in the template.</p>\n\n<p translation-result=\"on\">下面这个例子把 <code>index</code> 捕获到了 <code>i</code> 变量中，并且把它显示在英雄名字的前面。</p><p translation-origin=\"off\">The next example captures the <code>index</code> in a variable named <code>i</code> and displays it with the hero name like this.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgFor-3\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes; let i=index\">{{i + 1}} - {{hero.name}}&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">要学习更多的<em>类似 index</em> 的值，例如 <code>last</code>、<code><a href=\"api/common/NgForOfContext#even\" class=\"code-anchor\">even</a></code> 和 <code><a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a></code>，请参阅 <a href=\"api/common/NgForOf\">NgFor API 参考</a>。</p><p translation-origin=\"off\"><code>NgFor</code> is implemented by the <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> directive. Read more about the other <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> context values such as <code>last</code>, <code><a href=\"api/common/NgForOfContext#even\" class=\"code-anchor\">even</a></code>,\nand <code><a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a></code> in the <a href=\"api/common/NgForOf\">NgForOf API reference</a>.</p>\n\n</div>\n<a id=\"trackBy\"></a>\n<h4 id=\"ngfor-with-trackby\" translation-result=\"on\">带 <code>trackBy</code> 的 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngfor-with-trackby\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"ngfor-with-trackby\">*ngFor with <em>trackBy</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngfor-with-trackby\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 指令有时候会性能较差，特别是在大型列表中。\n对一个条目的一丁点改动、移除或添加，都会导致级联的 DOM 操作。</p><p translation-origin=\"off\">The <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> directive may perform poorly, especially with large lists.\nA small change to one item, an item removed, or an item added can trigger a cascade of DOM manipulations.</p>\n\n<p translation-result=\"on\">例如，重新从服务器查询可以刷新包括所有新英雄在内的英雄列表。</p><p translation-origin=\"off\">For example, re-querying the server could reset the list with all new hero objects.</p>\n\n<p translation-result=\"on\">他们中的绝大多数（如果不是所有的话）都是以前显示过的英雄。<em>你</em>知道这一点，是因为每个英雄的 <code>id</code> 没有变化。\n但在 Angular 看来，它只是一个由新的对象引用构成的新列表，\n它没有选择，只能清理旧列表、舍弃那些 DOM 元素，并且用新的 DOM 元素来重建一个新列表。</p><p translation-origin=\"off\">Most, if not all, are previously displayed heroes.\n<em>You</em> know this because the <code>id</code> of each hero hasn't changed.\nBut Angular sees only a fresh list of new object references.\nIt has no choice but to tear down the old DOM elements and insert all new DOM elements.</p>\n\n<p translation-result=\"on\">如果给它指定一个 <code>trackBy</code>，Angular 就可以避免这种折腾。\n往组件中添加一个方法，它会返回 <code>NgFor</code><em>应该</em>追踪的值。\n在这里，这个值就是英雄的 <code>id</code>。</p><p translation-origin=\"off\">Angular can avoid this churn with <code>trackBy</code>.\nAdd a method to the component that returns the value <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> <em>should</em> track.\nIn this case, that value is the hero's <code>id</code>.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.ts\" region=\"trackByHeroes\" header=\"src/app/app.component.ts\" linenums=\"false\">\ntrackByHeroes(index: number, hero: Hero): number { return hero.id; }\n\n</code-example>\n<p translation-result=\"on\">在微语法中，把 <code>trackBy</code> 设置为该方法。</p><p translation-origin=\"off\">In the microsyntax expression, set <code>trackBy</code> to this method.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"trackBy\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes; trackBy: trackByHeroes\">\n  ({{hero.id}}) {{hero.name}}\n&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\">这里展示了 <code>trackBy</code> 的效果。\n\"Reset heroes\"会创建一个具有相同 <code>hero.id</code> 的新英雄。\n\"Change ids\"则会创建一个具有新 <code>hero.id</code> 的新英雄。</p><p translation-origin=\"off\">Here is an illustration of the <em>trackBy</em> effect.\n\"Reset heroes\" creates new heroes with the same <code>hero.id</code>s.\n\"Change ids\" creates new heroes with new <code>hero.id</code>s.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> 如果没有 <code>trackBy</code>，这些按钮都会触发完全的 DOM 元素替换。</p><p translation-origin=\"off\">With no <code>trackBy</code>, both buttons trigger complete DOM element replacement.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 有了 <code>trackBy</code>，则只有修改了 <code>id</code> 的按钮才会触发元素替换。</p><p translation-origin=\"off\">With <code>trackBy</code>, only changing the <code>id</code> triggers element replacement.</p>\n\n</li>\n</ul>\n<figure>\n  <img src=\"generated/images/guide/template-syntax/ng-for-track-by-anim.gif\" alt=\"trackBy\" width=\"626\" height=\"578\">\n</figure>\n<hr>\n<a id=\"ngSwitch\"></a>\n<h3 id=\"the-ngswitch-directives\" translation-result=\"on\"><code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code> 指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#the-ngswitch-directives\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"the-ngswitch-directives\">The <em>NgSwitch</em> directives<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#the-ngswitch-directives\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code> 指令类似于 JavaScript 的 <code>switch</code> 语句。\n它可以从多个可能的元素中根据<em>switch 条件</em>来显示某一个。\nAngular 只会把<em>选中的</em>元素放进 DOM 中。</p><p translation-origin=\"off\"><em>NgSwitch</em> is like the JavaScript <code>switch</code> statement.\nIt can display <em>one</em> element from among several possible elements, based on a <em>switch condition</em>.\nAngular puts only the <em>selected</em> element into the DOM.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code> 实际上包括三个相互协作的指令：<code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>、<code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code> 和 <code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code>，例子如下：</p><p translation-origin=\"off\"><em>NgSwitch</em> is actually a set of three, cooperating directives:\n<code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>, <code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code>, and <code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code> as seen in this example.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgSwitch\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div [<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]=\"currentHero.emotion\">\n  &#x3C;app-happy-hero    *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'happy'\"    [hero]=\"currentHero\">&#x3C;/app-happy-hero>\n  &#x3C;app-sad-hero      *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'sad'\"      [hero]=\"currentHero\">&#x3C;/app-sad-hero>\n  &#x3C;app-confused-hero *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'confused'\" [hero]=\"currentHero\">&#x3C;/app-confused-hero>\n  &#x3C;app-unknown-hero  *<a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a>           [hero]=\"currentHero\">&#x3C;/app-unknown-hero>\n&#x3C;/div>\n\n</code-example>\n<figure>\n  <img src=\"generated/images/guide/template-syntax/switch-anim.gif\" alt=\"trackBy\" width=\"444\" height=\"100\">\n</figure>\n<p translation-result=\"on\"><code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code> 是主控指令，要把它绑定到一个返回<em>候选值</em>的表达式。\n本例子中的 <code>emotion</code> 是个字符串，但实际上这个候选值可以是任意类型。</p><p translation-origin=\"off\"><code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code> is the controller directive. Bind it to an expression that returns the <em>switch value</em>.\nThe <code>emotion</code> value in this example is a string, but the switch value can be of any type.</p>\n\n<p translation-result=\"on\"><strong>绑定到 <code>[<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]</code></strong>。如果试图用 <code>*<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a></code> 的形式使用它就会报错，这是因为 <code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code> 是一个<em>属性型</em>指令，而不是<em>结构型指令</em>。\n它要修改的是所在元素的行为，而不会直接接触 DOM 结构。</p><p translation-origin=\"off\"><strong>Bind to <code>[<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]</code></strong>. You'll get an error if you try to set <code>*<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a></code> because\n<code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code> is an <em>attribute</em> directive, not a <em>structural</em> directive.\nIt changes the behavior of its companion directives.\nIt doesn't touch the DOM directly.</p>\n\n<p translation-result=\"on\"><strong>绑定到 <code>*<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a></code> 和 <code>*<a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a></code></strong>\n<code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code> 和 <code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code> 指令都是<em>结构型指令</em>，因为它们会从 DOM 中添加或移除元素。</p><p translation-origin=\"off\"><strong>Bind to <code>*<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a></code> and <code>*<a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a></code></strong>.\nThe <code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code> and <code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code> directives are <em>structural</em> directives\nbecause they add or remove elements from the DOM.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> <code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code> 会在它绑定到的值等于候选值时，把它所在的元素加入到 DOM 中。</p><p translation-origin=\"off\"><code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code> adds its element to the DOM when its bound value equals the switch value.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> <code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code> 会在没有任何一个 <code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code> 被选中时把它所在的元素加入 DOM 中。</p><p translation-origin=\"off\"><code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code> adds its element to the DOM when there is no selected <code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code>.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">这组指令在要添加或移除<em>组件元素</em>时会非常有用。\n这个例子会在 <code>hero-switch.components.ts</code> 中定义的四个“感人英雄”组件之间选择。\n每个组件都有一个<a href=\"guide/template-syntax#inputs-outputs\" title=\"Input property\">输入属性</a><code>hero</code>，它绑定到父组件的 <code>currentHero</code> 上。</p><p translation-origin=\"off\">The switch directives are particularly useful for adding and removing <em>component elements</em>.\nThis example switches among four \"emotional hero\" components defined in the <code>hero-switch.components.ts</code> file.\nEach component has a <code>hero</code> <a href=\"guide/template-syntax#inputs-outputs\" title=\"Input property\">input property</a>\nwhich is bound to the <code>currentHero</code> of the parent component.</p>\n\n<p translation-result=\"on\">这组指令在原生元素和<a href=\"https://developer.mozilla.org/en-US/docs/Web/Web_Components\" target=\"_blank\" title=\"MDN: Web Components\">Web Component</a>上都可以正常工作。\n比如，你可以把 <code>&#x3C;confused-hero></code> 分支改成这样：</p><p translation-origin=\"off\">Switch directives work as well with native elements and web components too.\nFor example, you could replace the <code>&#x3C;confused-hero></code> switch case with the following.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgSwitch-div\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'confused'\">Are you as confused as {{currentHero.name}}?&#x3C;/div>\n\n</code-example>\n<hr>\n<a id=\"template-reference-variable\"></a>\n<a id=\"ref-vars\"></a>\n<a id=\"ref-var\"></a>\n<h2 id=\"template-reference-variables--var-\" translation-result=\"on\">模板引用变量 ( <span class=\"syntax\">#var</span> )<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#template-reference-variables--var-\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"template-reference-variables--var-\">Template reference variables ( <span class=\"syntax\">#var</span> )<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#template-reference-variables--var-\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><strong>模板引用变量</strong>通常用来引用模板中的某个 DOM 元素，它还可以引用 Angular 组件或指令或<a href=\"https://developer.mozilla.org/en-US/docs/Web/Web_Components\" target=\"_blank\" title=\"MDN: Web Components\">Web Component</a>。</p><p translation-origin=\"off\">A <strong>template reference variable</strong> is often a reference to a DOM element within a template.\nIt can also be a reference to an Angular component or directive or a\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/Web_Components\" title=\"MDN: Web Components\">web component</a>.</p>\n\n<p translation-result=\"on\">使用井号 (#) 来声明引用变量。\n<code>#phone</code> 的意思就是声明一个名叫 <code>phone</code> 的变量来引用 <code>&#x3C;input></code> 元素。</p><p translation-origin=\"off\">Use the hash symbol (#) to declare a reference variable.\nThe <code>#phone</code> declares a <code>phone</code> variable on an <code>&#x3C;input></code> element.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"ref-var\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;input #phone placeholder=\"phone number\">\n\n</code-example>\n<p translation-result=\"on\">你可以在模板中的任何地方引用模板引用变量。\n比如声明在 <code>&#x3C;input></code> 上的 <code>phone</code> 变量就是在模板另一侧的 <code>&#x3C;button></code> 上使用的。</p><p translation-origin=\"off\">You can refer to a template reference variable <em>anywhere</em> in the template.\nThe <code>phone</code> variable declared on this <code>&#x3C;input></code> is\nconsumed in a <code>&#x3C;button></code> on the other side of the template</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"ref-phone\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;input #phone placeholder=\"phone number\">\n\n&#x3C;!-- lots of other elements -->\n\n&#x3C;!-- phone refers to the input element; pass its `value` to an event handler -->\n&#x3C;button (click)=\"callPhone(phone.value)\">Call&#x3C;/button>\n\n</code-example>\n<h3 class=\"no-toc\" id=\"how-a-reference-variable-gets-its-value\" translation-result=\"on\">模板引用变量怎么得到它的值？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#how-a-reference-variable-gets-its-value\"><i class=\"material-icons\">link</i></a></h3><h3 class=\"no-toc\" translation-origin=\"off\" id=\"how-a-reference-variable-gets-its-value\">How a reference variable gets its value<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#how-a-reference-variable-gets-its-value\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">大多数情况下，Angular 会把模板引用变量的值设置为声明它的那个元素。\n在上一个例子中，<code>phone</code> 引用的是表示<em>电话号码</em>的 <code>&#x3C;input></code> 框。\n\"拨号\"按钮的点击事件处理器把这个 <em>input</em> 值传给了组件的 <code>callPhone</code> 方法。\n不过，指令也可以修改这种行为，让这个值引用到别处，比如它自身。\n<code><a href=\"api/forms/NgForm\" class=\"code-anchor\">NgForm</a></code> 指令就是这么做的。</p><p translation-origin=\"off\">In most cases, Angular sets the reference variable's value to the element on which it was declared.\nIn the previous example, <code>phone</code> refers to the <em>phone number</em> <code>&#x3C;input></code> box.\nThe phone button click handler passes the <em>input</em> value to the component's <code>callPhone</code> method.\nBut a directive can change that behavior and set the value to something else, such as itself.\nThe <code><a href=\"api/forms/NgForm\" class=\"code-anchor\">NgForm</a></code> directive does that.</p>\n\n<p translation-result=\"on\">下面是<a href=\"guide/forms\">表单</a>一章中表单范例的<em>简化版</em>。</p><p translation-origin=\"off\">The following is a <em>simplified</em> version of the form example in the <a href=\"guide/forms\">Forms</a> guide.</p>\n\n<code-example path=\"template-syntax/src/app/hero-form.component.html\" header=\"src/app/hero-form.component.html\" linenums=\"false\">\n&#x3C;form (ngSubmit)=\"onSubmit(heroForm)\" #heroForm=\"<a href=\"api/forms/NgForm\" class=\"code-anchor\">ngForm</a>\">\n  &#x3C;div class=\"form-group\">\n    &#x3C;label for=\"name\">Name\n      &#x3C;input class=\"form-control\" name=\"name\" required [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\">\n    &#x3C;/label>\n  &#x3C;/div>\n  &#x3C;button type=\"submit\" [disabled]=\"!heroForm.form.valid\">Submit&#x3C;/button>\n&#x3C;/form>\n&#x3C;div [hidden]=\"!heroForm.form.valid\">\n  {{submitMessage}}\n&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\">模板引用变量 <code>heroForm</code> 在这个例子中出现了三次，中间隔着一大堆 HTML。\n<code>heroForm</code> 的值是什么？</p><p translation-origin=\"off\">A template reference variable, <code>heroForm</code>, appears three times in this example, separated\nby a large amount of HTML.\nWhat is the value of <code>heroForm</code>?</p>\n\n<p translation-result=\"on\">如果你没有导入过 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>，Angular 就不会控制这个表单，那么它就是一个<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement\">HTMLFormElement</a>实例。\n这里的 <code>heroForm</code> 实际上是一个 Angular <a href=\"api/forms/NgForm\" title=\"API: NgForm\">NgForm</a> 指令的引用，\n因此具备了跟踪表单中的每个控件的值和有效性的能力。</p><p translation-origin=\"off\">If Angular hadn't taken it over when you imported the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>,\nit would be the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement\">HTMLFormElement</a>.\nThe <code>heroForm</code> is actually a reference to an Angular <a href=\"api/forms/NgForm\" title=\"API: NgForm\">NgForm</a>\ndirective with the ability to track the value and validity of every control in the form.</p>\n\n<p translation-result=\"on\">原生的 <code>&#x3C;form></code> 元素没有 <code>form</code> 属性，但 <code><a href=\"api/forms/NgForm\" class=\"code-anchor\">NgForm</a></code> 指令有。这就解释了为何当 <code>heroForm.form.valid</code> 是无效时你可以禁用提交按钮，\n并能把整个表单控件树传给父组件的 <code>onSubmit</code> 方法。</p><p translation-origin=\"off\">The native <code>&#x3C;form></code> element doesn't have a <code>form</code> property.\nBut the <code><a href=\"api/forms/NgForm\" class=\"code-anchor\">NgForm</a></code> directive does, which explains how you can disable the submit button\nif the <code>heroForm.form.valid</code> is invalid and pass the entire form control tree\nto the parent component's <code>onSubmit</code> method.</p>\n\n<h3 class=\"no-toc\" id=\"template-reference-variable-warning-notes\" translation-result=\"on\">关于模板引用变量的注意事项<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#template-reference-variable-warning-notes\"><i class=\"material-icons\">link</i></a></h3><h3 class=\"no-toc\" translation-origin=\"off\" id=\"template-reference-variable-warning-notes\">Template reference variable warning notes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#template-reference-variable-warning-notes\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">模板<em>引用</em>变量 (<code>#phone</code>) 和<a href=\"guide/template-syntax#template-input-variable\"><code>*ngFor</code></a>部分看到过的模板<em>输入</em>变量 (<code>let phone</code>) 是不同的。\n要了解详情，参见<a href=\"guide/structural-directives#template-input-variable\">结构型指令</a>一章。</p><p translation-origin=\"off\">A template <em>reference</em> variable (<code>#phone</code>) is <em>not</em> the same as a template <em>input</em> variable (<code>let phone</code>)\nsuch as you might see in an <a href=\"guide/template-syntax#template-input-variable\"><code>*ngFor</code></a>.\nLearn the difference in the <a href=\"guide/structural-directives#template-input-variable\"><em>Structural Directives</em></a> guide.</p>\n\n<p translation-result=\"on\">模板引用变量的作用范围是<em>整个模板</em>。\n不要在同一个模板中多次定义同一个变量名，否则它在运行期间的值是无法确定的。</p><p translation-origin=\"off\">The scope of a reference variable is the <em>entire template</em>.\nDo not define the same variable name more than once in the same template.\nThe runtime value will be unpredictable.</p>\n\n<p translation-result=\"on\">你也可以用 <code>ref-</code> 前缀代替 <code>#</code>。\n下面的例子中就用把 <code>fax</code> 变量声明成了 <code>ref-fax</code> 而不是 <code>#fax</code>。</p><p translation-origin=\"off\">You can use the <code>ref-</code> prefix alternative to <code>#</code>.\nThis example declares the <code>fax</code> variable as <code>ref-fax</code> instead of <code>#fax</code>.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"ref-fax\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;input ref-fax placeholder=\"fax number\">\n&#x3C;button (click)=\"callFax(fax.value)\">Fax&#x3C;/button>\n\n</code-example>\n<hr>\n<a id=\"inputs-outputs\"></a>\n<h2 id=\"input-and-output-properties\" translation-result=\"on\">输入和输出属性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#input-and-output-properties\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"input-and-output-properties\">Input and Output properties<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#input-and-output-properties\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><strong>输入</strong>属性是一个带有 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 装饰器的<strong>可设置</strong>属性。当它通过<a href=\"guide/template-syntax#property-binding\">属性绑定</a>的形式被绑定时，值会“流入”这个属性。</p><p translation-origin=\"off\">An <em>Input</em> property is a <em>settable</em> property annotated with an <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> decorator.\nValues flow <em>into</em> the property when it is data bound with a <a href=\"guide/template-syntax#property-binding\">property binding</a></p>\n\n<p translation-result=\"on\"><strong>输出</strong>属性是一个带有 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> 装饰器的<strong>可观察对象</strong>型的属性。\n这个属性几乎总是返回 Angular 的<a href=\"api/core/EventEmitter\"><code>EventEmitter</code></a>。\n当它通过<a href=\"guide/template-syntax#event-binding\">事件绑定</a>的形式被绑定时，值会“流出”这个属性。</p><p translation-origin=\"off\">An <em>Output</em> property is an <em>observable</em> property annotated with an <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> decorator.\nThe property almost always returns an Angular <a href=\"api/core/EventEmitter\"><code>EventEmitter</code></a>.\nValues flow <em>out</em> of the component as events bound with an <a href=\"guide/template-syntax#event-binding\">event binding</a>.</p>\n\n<p translation-result=\"on\">你只能通过它的<strong>输入</strong>和<strong>输出</strong>属性将其绑定到<strong>其它</strong>组件或指令。</p><p translation-origin=\"off\">You can only bind to <em>another</em> component or directive through its <em>Input</em> and <em>Output</em> properties.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">记住，所有的<strong>组件</strong>都是<strong>指令</strong>。</p><p translation-origin=\"off\">Remember that all <strong>components</strong> are <strong>directives</strong>.</p>\n\n<p translation-result=\"on\">为简洁起见，以下讨论会涉及到<strong>组件</strong>，因为这个主题主要是组件作者所关心的问题。</p><p translation-origin=\"off\">The following discussion refers to <em>components</em> for brevity and\nbecause this topic is mostly a concern for component authors. </p>\n\n</div>\n<h3 class=\"no-toc\" id=\"discussion\" translation-result=\"on\">讨论<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#discussion\"><i class=\"material-icons\">link</i></a></h3><h3 class=\"no-toc\" translation-origin=\"off\" id=\"discussion\">Discussion<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#discussion\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在下面的例子中，<code>iconUrl</code> 和 <code>onSave</code> 是组件的成员，它们在 <code>=</code> 右侧引号语法中被引用了。</p><p translation-origin=\"off\">You are usually binding a template to its <em>own component class</em>.\nIn such binding expressions, the component's property or method is to the <em>right</em> of the (<code>=</code>).</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"io-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;img [src]=\"iconUrl\"/>\n&#x3C;button (click)=\"onSave()\">Save&#x3C;/button>\n\n</code-example>\n<p translation-result=\"on\"><code>iconUrl</code> 和 <code>onSave</code> 是 <code>AppComponent</code> 类的成员。但它们并没有带 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 或 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 装饰器。\nAngular 不在乎。</p><p translation-origin=\"off\">The <code>iconUrl</code> and <code>onSave</code> are members of the <code>AppComponent</code> class.\nThey are <em>not</em> decorated with <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> or <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code>.\nAngular does not object.</p>\n\n<p translation-result=\"on\"><strong>你总是可以在组件自己的模板中绑定到组件的公共属性，</strong>而不用管它们是否输入（Input）属性或输出（Output）属性。</p><p translation-origin=\"off\"><strong>You can always bind to a public property of a component in its own template.</strong>\nIt doesn't have to be an <em>Input</em> or <em>Output</em> property</p>\n\n<p translation-result=\"on\">这是因为组件类和模板是紧耦合的，它们是同一个东西的两个部分，合起来构成组件。\n组件类及其模板之间的交互属于实现细节。</p><p translation-origin=\"off\">A component's class and template are closely coupled.\nThey are both parts of the same thing.\nTogether they <em>are</em> the component.\nExchanges between a component class and its template are internal implementation details.</p>\n\n<h3 id=\"binding-to-a-different-component\" translation-result=\"on\">绑定到其它组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#binding-to-a-different-component\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"binding-to-a-different-component\">Binding to a different component<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#binding-to-a-different-component\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你也可以绑定到<em>其它</em>组件的属性。\n这种绑定形式下，<em>其它</em>组件的属性位于等号（<code>=</code>）的<em>左侧</em>。</p><p translation-origin=\"off\">You can also bind to a property of a <em>different</em> component.\nIn such bindings, the <em>other</em> component's property is to the <em>left</em> of the (<code>=</code>).</p>\n\n<p translation-result=\"on\">下面的例子中，<code>AppComponent</code> 的模板把 <code>AppComponent</code> 类的成员绑定到了 <code>HeroDetailComponent</code>（选择器为 <code>'app-hero-detail'</code>） 的属性上。</p><p translation-origin=\"off\">In the following example, the <code>AppComponent</code> template binds <code>AppComponent</code> class members to properties of the <code>HeroDetailComponent</code> whose selector is <code>'app-hero-detail'</code>.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"io-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;app-hero-detail [hero]=\"currentHero\" (deleteRequest)=\"deleteHero($event)\">\n&#x3C;/app-hero-detail>\n\n</code-example>\n<p translation-result=\"on\">Angular 的编译器<em>可能</em>会对这些绑定报错，就像这样：</p><p translation-origin=\"off\">The Angular compiler <em>may</em> reject these bindings with errors like this one:</p>\n\n<code-example language=\"sh\" class=\"code-shell\">\nUncaught <a href=\"api/core/MissingTranslationStrategy#Error\" class=\"code-anchor\">Error</a>: <a href=\"\" class=\"code-anchor\">Template</a> parse errors:\nCan't bind to 'hero' since it isn't <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> known property of 'app-hero-detail'\n</code-example>\n<p translation-result=\"on\">你自己知道 <code>HeroDetailComponent</code> 有两个属性 <code>hero</code> 和 <code>detectRequest</code>，但 Angular 编译器并不知道。</p><p translation-origin=\"off\">You know that <code>HeroDetailComponent</code> has <code>hero</code> and <code>deleteRequest</code> properties.\nBut the Angular compiler refuses to recognize them.</p>\n\n<p translation-result=\"on\"><strong>Angular 编译器不会绑定到其它组件的属性上  —— 除非这些属性是输入或输出属性。</strong></p><p translation-origin=\"off\"><strong>The Angular compiler won't bind to properties of a different component\nunless they are Input or Output properties</strong>.</p>\n\n<p translation-result=\"on\">这条规则是有充分理由的。</p><p translation-origin=\"off\">There's a good reason for this rule.</p>\n\n<p translation-result=\"on\">组件绑定到它<em>自己</em>的属性当然没问题。\n该组件的作者对这些绑定有完全的控制权。</p><p translation-origin=\"off\">It's OK for a component to bind to its <em>own</em> properties.\nThe component author is in complete control of those bindings.</p>\n\n<p translation-result=\"on\">但是，其它组件不应该进行这种毫无限制的访问。\n如果任何人都可以绑定到你的组件的任何属性上，那么这个组件就很难维护。\n所以，外部组件应该只能绑定到组件的公共（允许绑定） API 上。</p><p translation-origin=\"off\">But other components shouldn't have that kind of unrestricted access.\nYou'd have a hard time supporting your component if anyone could bind to any of its properties.\nOutside components should only be able to bind to the component's public binding API.</p>\n\n<p translation-result=\"on\">Angular 要求你<em>显式声明</em>那些 API。\n它让<em>你</em>可以自己决定哪些属性是可以被外部组件绑定的。</p><p translation-origin=\"off\">Angular asks you to be <em>explicit</em> about that API.\nIt's up to <em>you</em> to decide which properties are available for binding by\nexternal components.</p>\n\n<h4 id=\"typescript-public-doesnt-matter\" translation-result=\"on\">TypeScript 的 <code>public</code> 是没用的<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#typescript-public-doesnt-matter\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"typescript-public-doesnt-matter\">TypeScript <em>public</em> doesn't matter<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#typescript-public-doesnt-matter\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">你不能用 TypeScript 的 <code>public</code> 和 <code>private</code> 访问控制符来标明组件的公共 API。</p><p translation-origin=\"off\">You can't use the TypeScript <em>public</em> and <em>private</em> access modifiers to\nshape the component's public binding API.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">所有数据绑定属性必须是 TypeScript 的公共属性，Angular 永远不会绑定到 TypeScript 中的私有属性。</p><p translation-origin=\"off\">All data bound properties must be TypeScript <em>public</em> properties.\nAngular never binds to a TypeScript <em>private</em> property.</p>\n\n</div>\n<p translation-result=\"on\">因此，Angular 需要一些其它方式来标记出那些允许被<em>外部</em>组件绑定到的属性。\n这种<em>其它方式</em>，就是 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 和 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 装饰器。</p><p translation-origin=\"off\">Angular requires some other way to identify properties that <em>outside</em> components are allowed to bind to.\nThat <em>other way</em> is the <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> and <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> decorators.</p>\n\n<h3 id=\"declaring-input-and-output-properties\" translation-result=\"on\">声明输入与输出属性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#declaring-input-and-output-properties\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"declaring-input-and-output-properties\">Declaring Input and Output properties<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#declaring-input-and-output-properties\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在本章的例子中，绑定到 <code>HeroDetailComponent</code> 不会失败，这是因为这些要进行数据绑定的属性都带有 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 和 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 装饰器。</p><p translation-origin=\"off\">In the sample for this guide, the bindings to <code>HeroDetailComponent</code> do not fail\nbecause the data bound properties are annotated with <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> and <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> decorators.</p>\n\n<code-example path=\"template-syntax/src/app/hero-detail.component.ts\" region=\"input-output-1\" header=\"src/app/hero-detail.component.ts\" linenums=\"false\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()  hero: Hero;\n@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() deleteRequest = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;Hero>();\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">另外，还可以在指令元数据的 <code>inputs</code> 或 <code>outputs</code> 数组中标记出这些成员。比如这个例子：</p><p translation-origin=\"off\">Alternatively, you can identify members in the <code>inputs</code> and <code>outputs</code> arrays\nof the directive metadata, as in this example:</p>\n\n<code-example path=\"template-syntax/src/app/hero-detail.component.ts\" region=\"input-output-2\" header=\"src/app/hero-detail.component.ts\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  inputs: ['hero'],\n  outputs: ['deleteRequest'],\n})\n\n</code-example>\n</div>\n<h3 id=\"input-or-output\" translation-result=\"on\">输入还是输出？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#input-or-output\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"input-or-output\">Input or output?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#input-or-output\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><em>输入</em>属性通常接收数据值。\n<em>输出</em>属性暴露事件生产者，如 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 对象。</p><p translation-origin=\"off\"><em>Input</em> properties usually receive data values.\n<em>Output</em> properties expose event producers, such as <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> objects.</p>\n\n<p translation-result=\"on\"><em>输入</em>和<em>输出</em>这两个词是从目标指令的角度来说的。</p><p translation-origin=\"off\">The terms <em>input</em> and <em>output</em> reflect the perspective of the target directive.</p>\n\n<figure>\n  <img src=\"generated/images/guide/template-syntax/input-output.png\" alt=\"Inputs and outputs\" width=\"546\" height=\"50\">\n</figure>\n<p translation-result=\"on\">从 <code>HeroDetailComponent</code> 角度来看，<code>HeroDetailComponent.hero</code> 是个<strong>输入</strong>属性，\n因为数据流从模板绑定表达式流<em>入</em>那个属性。</p><p translation-origin=\"off\"><code>HeroDetailComponent.hero</code> is an <strong>input</strong> property from the perspective of <code>HeroDetailComponent</code>\nbecause data flows <em>into</em> that property from a template binding expression.</p>\n\n<p translation-result=\"on\">从 <code>HeroDetailComponent</code> 角度来看，<code>HeroDetailComponent.deleteRequest</code> 是个<strong>输出</strong>属性，\n因为事件从那个属性流<em>出</em>，流向模板绑定语句中的处理器。</p><p translation-origin=\"off\"><code>HeroDetailComponent.deleteRequest</code> is an <strong>output</strong> property from the perspective of <code>HeroDetailComponent</code>\nbecause events stream <em>out</em> of that property and toward the handler in a template binding statement.</p>\n\n<h3 id=\"aliasing-io\" translation-result=\"on\">给输入/输出属性起别名<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#aliasing-io\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"aliasing-inputoutput-properties\">Aliasing input/output properties<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#aliasing-inputoutput-properties\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">有时需要让输入/输出属性的公共名字不同于内部名字。</p><p translation-origin=\"off\">Sometimes the public name of an input/output property should be different from the internal name.</p>\n\n<p translation-result=\"on\">这是使用 <a href=\"guide/attribute-directives\">attribute 指令</a>时的常见情况。\n指令的使用者期望绑定到指令名。例如，在 <code>&#x3C;div></code> 上用 <code>myClick</code> 选择器应用指令时，\n希望绑定的事件属性也叫 <code>myClick</code>。</p><p translation-origin=\"off\">This is frequently the case with <a href=\"guide/attribute-directives\">attribute directives</a>.\nDirective consumers expect to bind to the name of the directive.\nFor example, when you apply a directive with a <code>myClick</code> selector to a <code>&#x3C;div></code> tag,\nyou expect to bind to an event property that is also called <code>myClick</code>.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"myClick\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div (myClick)=\"clickMessage=$event\" clickable>click with myClick&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\">然而，在指令类中，直接用指令名作为自己的属性名通常都不是好的选择。\n指令名很少能描述这个属性是干嘛的。\n<code>myClick</code> 这个指令名对于用来发出 click 消息的属性就算不上一个好名字。</p><p translation-origin=\"off\">However, the directive name is often a poor choice for the name of a property within the directive class.\nThe directive name rarely describes what the property does.\nThe <code>myClick</code> directive name is not a good name for a property that emits click messages.</p>\n\n<p translation-result=\"on\">幸运的是，可以使用约定俗成的公共名字，同时在内部使用不同的名字。\n在上面例子中，实际上是把 <code>myClick</code> 这个别名指向了指令自己的 <code>clicks</code> 属性。</p><p translation-origin=\"off\">Fortunately, you can have a public name for the property that meets conventional expectations,\nwhile using a different name internally.\nIn the example immediately above, you are actually binding <em>through the</em> <code>myClick</code> <em>alias</em> to\nthe directive's own <code>clicks</code> property.</p>\n\n<p translation-result=\"on\">把别名传进@Input/@Output 装饰器，就可以为属性指定别名，就像这样：</p><p translation-origin=\"off\">You can specify the alias for the property name by passing it into the input/output decorator like this:</p>\n\n<code-example path=\"template-syntax/src/app/click.directive.ts\" region=\"output-myClick\" header=\"src/app/click.directive.ts\" linenums=\"false\">\n@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>('myClick') clicks = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;string>(); //  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>(alias) propertyName = ...\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">也可在 <code>inputs</code> 和 <code>outputs</code> 数组中为属性指定别名。\n可以写一个冒号 (<code>:</code>) 分隔的字符串，<em>左侧</em>是指令中的属性名，<em>右侧</em>则是公共别名。</p><p translation-origin=\"off\">You can also alias property names in the <code>inputs</code> and <code>outputs</code> arrays.\nYou write a colon-delimited (<code>:</code>) string with\nthe directive property name on the <em>left</em> and the public alias on the <em>right</em>:</p>\n\n<code-example path=\"template-syntax/src/app/click.directive.ts\" region=\"output-myClick2\" header=\"src/app/click.directive.ts\" linenums=\"false\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  outputs: ['clicks:myClick']  // propertyName:alias\n})\n\n</code-example>\n</div>\n<hr>\n<a id=\"expression-operators\"></a>\n<h2 id=\"template-expression-operators\" translation-result=\"on\">模板表达式操作符<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#template-expression-operators\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"template-expression-operators\">Template expression operators<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#template-expression-operators\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">模板表达式语言使用了 JavaScript 语法的子集，并补充了几个用于特定场景的特殊操作符。\n下面介绍其中的两个：<em>管道</em>和<em>安全导航操作符</em>。</p><p translation-origin=\"off\">The template expression language employs a subset of JavaScript syntax supplemented with a few special operators\nfor specific scenarios. The next sections cover two of these operators: <em>pipe</em> and <em>safe navigation operator</em>.</p>\n\n<a id=\"pipe\"></a>\n<h3 id=\"the-pipe-operator---\" translation-result=\"on\">管道操作符 ( | )<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#the-pipe-operator---\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"the-pipe-operator---\">The pipe operator ( <span class=\"syntax\">|</span> )<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#the-pipe-operator---\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在绑定之前，表达式的结果可能需要一些转换。例如，可能希望把数字显示成金额、强制文本变成大写，或者过滤列表以及进行排序。</p><p translation-origin=\"off\">The result of an expression might require some transformation before you're ready to use it in a binding.\nFor example, you might display a number as a currency, force text to uppercase, or filter a list and sort it.</p>\n\n<p translation-result=\"on\">Angular <a href=\"guide/pipes\">管道</a>对像这样的小型转换来说是个明智的选择。\n管道是一个简单的函数，它接受一个输入值，并返回转换结果。\n它们很容易用于模板表达式中，只要使用<strong>管道操作符 (<code>|</code>) </strong>就行了。</p><p translation-origin=\"off\">Angular <a href=\"guide/pipes\">pipes</a> are a good choice for small transformations such as these.\nPipes are simple functions that accept an input value and return a transformed value.\nThey're easy to apply within template expressions, using the <strong>pipe operator (<code>|</code>)</strong>:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"pipes-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div><a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> through uppercase pipe: {{title | <a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">uppercase</a>}}&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\">管道操作符会把它左侧的表达式结果传给它右侧的管道函数。</p><p translation-origin=\"off\">The pipe operator passes the result of an expression on the left to a pipe function on the right.</p>\n\n<p translation-result=\"on\">还可以通过多个管道串联表达式：</p><p translation-origin=\"off\">You can chain expressions through multiple pipes:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"pipes-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- <a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a> chaining: convert title to uppercase, then to lowercase -->\n&#x3C;div>\n  <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> through <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> pipe chain:\n  {{title | <a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">uppercase</a> | <a href=\"api/common/LowerCasePipe\" class=\"code-anchor\">lowercase</a>}}\n&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\">还能对它们使用参数：</p><p translation-origin=\"off\">And you can also <a href=\"guide/pipes#parameterizing-a-pipe\">apply parameters</a> to a pipe:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"pipes-3\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- pipe with configuration argument => \"February 25, 1970\" -->\n&#x3C;div>Birthdate: {{currentHero?.birthdate | date:'longDate'}}&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\"><code><a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> 管道对调试绑定特别有用：</p><p translation-origin=\"off\">The <code><a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> pipe is particularly helpful for debugging bindings:</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" linenums=\"false\" header=\"src/app/app.component.html (pipes-json)\" region=\"pipes-json\">\n&#x3C;div>{{currentHero | <a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>}}&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\">它生成的输出是这样的：</p><p translation-origin=\"off\">The generated output would look something like this</p>\n\n<code-example language=\"json\">\n  { \"id\": 0, \"name\": \"Hercules\", \"emotion\": \"happy\",\n    \"birthdate\": \"1970-02-25T08:00:00.000Z\",\n    \"url\": \"<a href=\"api/common/http\" class=\"code-anchor\">http</a>://www.imdb.com/title/tt0065832/\",\n    \"rate\": 325 }\n</code-example>\n<hr>\n<a id=\"safe-navigation-operator\"></a>\n<h3 id=\"the-safe-navigation-operator----and-null-property-paths\" translation-result=\"on\">安全导航操作符 ( ?. ) 和空属性路径<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#the-safe-navigation-operator----and-null-property-paths\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"the-safe-navigation-operator----and-null-property-paths\">The safe navigation operator ( <span class=\"syntax\">?.</span> ) and null property paths<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#the-safe-navigation-operator----and-null-property-paths\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">Angular 的<strong>安全导航操作符 (<code>?.</code>) </strong>是一种流畅而便利的方式，用来保护出现在属性路径中 null 和 undefined 值。\n下例中，当 <code>currentHero</code> 为空时，保护视图渲染器，让它免于失败。</p><p translation-origin=\"off\">The Angular <strong>safe navigation operator (<code>?.</code>)</strong> is a fluent and convenient way to\nguard against null and undefined values in property paths.\nHere it is, protecting against a view render failure if the <code>currentHero</code> is null.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"safe-2\" header=\"src/app/app.component.html\" linenums=\"false\">\nThe current hero's name is {{currentHero?.name}}\n\n</code-example>\n<p translation-result=\"on\">如果下列数据绑定中 <code>title</code> 属性为空，会发生什么？</p><p translation-origin=\"off\">What happens when the following data bound <code>title</code> property is null?</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"safe-1\" header=\"src/app/app.component.html\" linenums=\"false\">\nThe title is {{title}}\n\n</code-example>\n<p translation-result=\"on\">这个视图仍然被渲染出来，但是显示的值是空；只能看到 “The title is”，它后面却没有任何东西。\n这是合理的行为。至少应用没有崩溃。</p><p translation-origin=\"off\">The view still renders but the displayed value is blank; you see only \"The title is\" with nothing after it.\nThat is reasonable behavior. At least the app doesn't crash.</p>\n\n<p translation-result=\"on\">假设模板表达式涉及属性路径，在下例中，显示一个空 (null) 英雄的 <code>firstName</code>。</p><p translation-origin=\"off\">Suppose the template expression involves a property path, as in this next example\nthat displays the <code>name</code> of a null hero.</p>\n\n<code-example language=\"html\">\n  The null hero's name is {{nullHero.name}}\n</code-example>\n<p translation-result=\"on\">JavaScript 抛出了空引用错误，Angular 也是如此：</p><p translation-origin=\"off\">JavaScript throws a null reference error, and so does Angular:</p>\n\n<code-example format=\"nocode\">\n  TypeError: Cannot <a href=\"api/core/Query#read\" class=\"code-anchor\">read</a> property 'name' of null in [null].\n</code-example>\n<p translation-result=\"on\">晕，<em>整个视图都不见了</em>。</p><p translation-origin=\"off\">Worse, the <em>entire view disappears</em>.</p>\n\n<p translation-result=\"on\">如果确信 <code>hero</code> 属性永远不可能为空，可以声称这是合理的行为。\n如果它必须不能为空，但它仍然是空值，实际上是制造了一个编程错误，它应该被捕获和修复。\n这种情况应该抛出异常。</p><p translation-origin=\"off\">This would be reasonable behavior if the <code>hero</code> property could never be null.\nIf it must never be null and yet it is null,\nthat's a programming error that should be caught and fixed.\nThrowing an exception is the right thing to do.</p>\n\n<p translation-result=\"on\">另一方面，属性路径中的空值可能会时常发生，特别是数据目前为空但最终会出现。</p><p translation-origin=\"off\">On the other hand, null values in the property path may be OK from time to time,\nespecially when the data are null now and will arrive eventually.</p>\n\n<p translation-result=\"on\">当等待数据的时候，视图渲染器不应该抱怨，而应该把这个空属性路径显示为空白，就像上面 <code>title</code> 属性那样。</p><p translation-origin=\"off\">While waiting for data, the view should render without complaint, and\nthe null property path should display as blank just as the <code>title</code> property does.</p>\n\n<p translation-result=\"on\">不幸的是，当 <code>currentHero</code> 为空的时候，应用崩溃了。</p><p translation-origin=\"off\">Unfortunately, the app crashes when the <code>currentHero</code> is null.</p>\n\n<p translation-result=\"on\">可以通过用<a href=\"guide/template-syntax#ngIf\">NgIf</a>代码环绕它来解决这个问题。</p><p translation-origin=\"off\">You could code around that problem with <a href=\"guide/template-syntax#ngIf\">*ngIf</a>.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"safe-4\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!--No hero, div not displayed, no error -->\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"nullHero\">The null hero's name is {{nullHero.name}}&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\">还可以尝试通过 <code>&#x26;&#x26;</code> 来把属性路径的各部分串起来，让它在遇到第一个空值的时候，就返回空。</p><p translation-origin=\"off\">You could try to chain parts of the property path with <code>&#x26;&#x26;</code>, knowing that the expression bails out\nwhen it encounters the first null.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"safe-5\" header=\"src/app/app.component.html\" linenums=\"false\">\nThe null hero's name is {{nullHero &#x26;&#x26; nullHero.name}}\n\n</code-example>\n<p translation-result=\"on\">这些方法都有价值，但是会显得笨重，特别是当这个属性路径非常长的时候。\n想象一下在一个很长的属性路径（如 <code>a.b.c.d</code>）中对空值提供保护。</p><p translation-origin=\"off\">These approaches have merit but can be cumbersome, especially if the property path is long.\nImagine guarding against a null somewhere in a long property path such as <code>a.b.c.d</code>.</p>\n\n<p translation-result=\"on\">Angular 安全导航操作符 (<code>?.</code>) 是在属性路径中保护空值的更加流畅、便利的方式。\n表达式会在它遇到第一个空值的时候跳出。\n显示是空的，但应用正常工作，而没有发生错误。</p><p translation-origin=\"off\">The Angular safe navigation operator (<code>?.</code>) is a more fluent and convenient way to guard against nulls in property paths.\nThe expression bails out when it hits the first null value.\nThe display is blank, but the app keeps rolling without errors.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"safe-6\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- No hero, no problem! -->\nThe null hero's name is {{nullHero?.name}}\n\n</code-example>\n<p translation-result=\"on\">在像 <code><a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>?.b?.c?.d</code> 这样的长属性路径中，它工作得很完美。<a href=\"guide/template-syntax#top-of-page\">back to top</a></p><p translation-origin=\"off\">It works perfectly with long property paths such as <code><a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>?.b?.c?.d</code>.</p>\n\n<hr>\n<a id=\"non-null-assertion-operator\"></a>\n<h3 id=\"the-non-null-assertion-operator---\" translation-result=\"on\">非空断言操作符（<span class=\"syntax\">!</span>）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#the-non-null-assertion-operator---\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"the-non-null-assertion-operator---\">The non-null assertion operator ( <span class=\"syntax\">!</span> )<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#the-non-null-assertion-operator---\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在 TypeScript 2.0 中，你可以使用 <code>--strictNullChecks</code> 标志强制开启<a href=\"http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html\" title=\"Strict null checking in TypeScript\">严格空值检查</a>。TypeScript 就会确保不存在意料之外的 null 或 undefined。</p><p translation-origin=\"off\">As of Typescript 2.0, you can enforce <a href=\"http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html\" title=\"Strict null checking in TypeScript\">strict null checking</a> with the <code>--strictNullChecks</code> flag. TypeScript then ensures that no variable is <em>unintentionally</em> null or undefined.</p>\n\n<p translation-result=\"on\">在这种模式下，有类型的变量默认是不允许 null 或 undefined 值的，如果有未赋值的变量，或者试图把 null 或 undefined 赋值给不允许为空的变量，类型检查器就会抛出一个错误。</p><p translation-origin=\"off\">In this mode, typed variables disallow null and undefined by default. The type checker throws an error if you leave a variable unassigned or try to assign null or undefined to a variable whose type disallows null and undefined.</p>\n\n<p translation-result=\"on\">如果类型检查器在运行期间无法确定一个变量是 null 或 undefined，那么它也会抛出一个错误。\n你自己可能知道它不会为空，但类型检查器不知道。\n所以你要告诉类型检查器，它不会为空，这时就要用到<a href=\"http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator\" title=\"Non-null assertion operator\"><em>非空断言操作符</em></a>。</p><p translation-origin=\"off\">The type checker also throws an error if it can't determine whether a variable will be null or undefined at runtime.\nYou may know that can't happen but the type checker doesn't know.\nYou tell the type checker that it can't happen by applying the post-fix\n<a href=\"http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator\" title=\"Non-null assertion operator\"><em>non-null assertion operator (!)</em></a>.</p>\n\n<p translation-result=\"on\"><em>Angular</em> 模板中的**非空断言操作符（<code>!</code>）也是同样的用途。</p><p translation-origin=\"off\">The <em>Angular</em> <strong>non-null assertion operator (<code>!</code>)</strong> serves the same purpose in an Angular template.</p>\n\n<p translation-result=\"on\">例如，在用<a href=\"guide/template-syntax#ngIf\">*ngIf</a>来检查过 <code>hero</code> 是已定义的之后，就可以断言 <code>hero</code> 属性一定是已定义的。</p><p translation-origin=\"off\">For example, after you use <a href=\"guide/template-syntax#ngIf\">*ngIf</a> to check that <code>hero</code> is defined, you can assert that\n<code>hero</code> properties are also defined.</p>\n\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"non-null-assertion-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!--No hero, no text -->\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\">\n  The hero's name is {{hero!.name}}\n&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\">在 Angular 编译器把你的模板转换成 TypeScript 代码时，这个操作符会防止 TypeScript 报告 \"<code>hero.name</code> 可能为 null 或 undefined\"的错误。</p><p translation-origin=\"off\">When the Angular compiler turns your template into TypeScript code,\nit prevents TypeScript from reporting that <code>hero.name</code> might be null or undefined.</p>\n\n<p translation-result=\"on\">与<a href=\"guide/template-syntax#safe-navigation-operator\" title=\"Safe naviation operator (?.)\"><em>安全导航操作符</em></a>不同的是，<strong>非空断言操作符</strong>不会防止出现 null 或 undefined。\n它只是告诉 TypeScript 的类型检查器对特定的属性表达式，不做 \"严格空值检测\"。</p><p translation-origin=\"off\">Unlike the <a href=\"guide/template-syntax#safe-navigation-operator\" title=\"Safe navigation operator (?.)\"><em>safe navigation operator</em></a>,\nthe <strong>non-null assertion operator</strong> does not guard against null or undefined.\nRather it tells the TypeScript type checker to suspend strict null checks for a specific property expression.</p>\n\n<p translation-result=\"on\">如果你打开了严格控制检测，那就要用到这个模板操作符，而其它情况下则是可选的。</p><p translation-origin=\"off\">You'll need this template operator when you turn on strict null checks. It's optional otherwise.</p>\n\n<p translation-result=\"on\"><a href=\"guide/template-syntax#top-of-page\">回到顶部</a></p><p translation-origin=\"off\"><a href=\"guide/template-syntax#top-of-page\">back to top</a></p>\n\n<hr>\n<a id=\"built-in-template-functions\"></a>\n<h2 id=\"built-in-template-functions\" translation-result=\"on\">内置模板函数<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#built-in-template-functions\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"built-in-template-functions\">Built-in template functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#built-in-template-functions\"><i class=\"material-icons\">link</i></a></h2>\n\n<a id=\"any-type-cast-function\"></a>\n<h3 id=\"the-any-type-cast-function\" translation-result=\"on\">类型转换函数 <code>$any()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#the-any-type-cast-function\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"the-any-type-cast-function\">The <code>$any()</code> type cast function<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#the-any-type-cast-function\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">有时候，绑定表达式可能会在 <a href=\"guide/aot-compiler\">AOT 编译</a>时报类型错误，并且它不能或很难指定类型。要消除这种报错，你可以使用 <code>$any()</code> 转换函数来把表达式转换成 <a href=\"http://www.typescriptlang.org/docs/handbook/basic-types.html#any\"><code>any</code> 类型</a>，范例如下：</p><p translation-origin=\"off\">Sometimes a binding expression triggers a type error during <a href=\"guide/aot-compiler\">AOT compilation</a> and it is not possible or difficult\nto fully specify the type. To silence the error, you can use the <code>$any()</code> cast function to cast\nthe expression to <a href=\"http://www.typescriptlang.org/docs/handbook/basic-types.html#any\">the <code>any</code> type</a> as in the following example:</p>\n\n<code-example path=\"built-in-template-functions/src/app/app.component.html\" region=\"any-type-cast-function-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;p>The <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>'s undeclared best by date is: {{$any(<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>).bestByDate}}&#x3C;/p>\n\n</code-example>\n<p translation-result=\"on\">当 Angular 编译器把模板转换成 TypeScript 代码时，<code>$any</code> 表达式可以防止 TypeScript 编译器在进行类型检查时报错说 <code>bestByDate</code> 不是 <code><a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a></code> 对象的成员。</p><p translation-origin=\"off\">When the Angular compiler turns this template into TypeScript code,\nit prevents TypeScript from reporting that <code>bestByDate</code> is not a member of the <code><a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a></code>\nobject when it runs type checking on the template.</p>\n\n<p translation-result=\"on\"><code>$any()</code> 转换函数可以和 <code>this</code> 联合使用，以便访问组件中未声明过的成员。</p><p translation-origin=\"off\">The <code>$any()</code> cast function also works with <code>this</code> to allow access to undeclared members of\nthe component.</p>\n\n<code-example path=\"built-in-template-functions/src/app/app.component.html\" region=\"any-type-cast-function-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;p>The <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>'s undeclared best by date is: {{$any(this).bestByDate}}&#x3C;/p>\n\n</code-example>\n<p translation-result=\"on\"><code>$any()</code> 转换函数可以用在绑定表达式中任何可以进行方法调用的地方。</p><p translation-origin=\"off\">The <code>$any()</code> cast function works anywhere in a binding expression where a method call is valid.</p>\n\n\n</div>\n\n<!-- links to this doc:\n - api/common/NgForOf\n - api/common/NgIf\n - guide/ajs-quick-reference\n - guide/aot-compiler\n - guide/architecture-components\n - guide/attribute-directives\n - guide/component-interaction\n - guide/displaying-data\n - guide/forms\n - guide/glossary\n - guide/pipes\n - guide/router\n - guide/structural-directives\n - guide/styleguide\n - guide/upgrade\n - guide/user-input\n - start\n - tutorial/toh-pt2\n - tutorial/toh-pt3\n - tutorial/toh-pt4\n - tutorial/toh-pt5\n-->\n<!-- links from this doc:\n - api/animations/state\n - api/animations/style\n - api/common/JsonPipe\n - api/common/LowerCasePipe\n - api/common/NgClass\n - api/common/NgForOf\n - api/common/NgForOfContext#even\n - api/common/NgForOfContext#odd\n - api/common/NgIf\n - api/common/NgStyle\n - api/common/NgSwitch\n - api/common/NgSwitchCase\n - api/common/NgSwitchDefault\n - api/common/Plural#Other\n - api/common/UpperCasePipe\n - api/common/http\n - api/common/http/testing/TestRequest#request\n - api/core/Component\n - api/core/Component#interpolation\n - api/core/ContentChild\n - api/core/DebugElement#classes\n - api/core/DebugElement#properties\n - api/core/Directive\n - api/core/EventEmitter\n - api/core/Input\n - api/core/IterableChangeRecord#item\n - api/core/MissingTranslationStrategy#Error\n - api/core/NgModule\n - api/core/Output\n - api/core/Pipe\n - api/core/Query#read\n - api/core/SecurityContext#HTML\n - api/core/Type\n - api/core/ViewChild\n - api/forms/ControlValueAccessor\n - api/forms/FormsModule\n - api/forms/NgForm\n - api/forms/NgModel\n - api/platform-browser/BrowserModule\n - api/platform-browser/Title\n - api/platform-server/PlatformConfig#document\n - api/router/RouterLinkActive#isActive\n - api/router/RouterLinkWithHref\n - api/router/RouterLinkWithHref#target\n - guide/aot-compiler\n - guide/attribute-directives\n - guide/forms\n - guide/forms#ngModel\n - guide/glossary#camelcase\n - guide/glossary#dash-case\n - guide/pipes\n - guide/pipes#parameterizing-a-pipe\n - guide/router\n - guide/security\n - guide/security#sanitization-and-security-contexts\n - guide/structural-directives\n - guide/structural-directives#asterisk\n - guide/structural-directives#microsyntax\n - guide/structural-directives#ngcontainer\n - guide/structural-directives#one-per-element\n - guide/structural-directives#template-input-variable\n - guide/template-syntax#a-new-mental-model\n - guide/template-syntax#aliasing-inputoutput-properties\n - guide/template-syntax#aliasing-io\n - guide/template-syntax#attribute-binding\n - guide/template-syntax#attribute-class-and-style-bindings\n - guide/template-syntax#attribute-directives\n - guide/template-syntax#avoid-side-effects\n - guide/template-syntax#binding-syntax-an-overview\n - guide/template-syntax#binding-target\n - guide/template-syntax#binding-targets\n - guide/template-syntax#binding-to-a-different-component\n - guide/template-syntax#built-in-attribute-directives\n - guide/template-syntax#built-in-directives\n - guide/template-syntax#built-in-structural-directives\n - guide/template-syntax#built-in-template-functions\n - guide/template-syntax#class-binding\n - guide/template-syntax#content-security\n - guide/template-syntax#custom-events-with-eventemitter\n - guide/template-syntax#declaring-input-and-output-properties\n - guide/template-syntax#discussion\n - guide/template-syntax#event-and-event-handling-statements\n - guide/template-syntax#event-binding\n - guide/template-syntax#event-binding-event\n - guide/template-syntax#expression-context\n - guide/template-syntax#expression-guidelines\n - guide/template-syntax#expression-operators\n - guide/template-syntax#formsmodule-is-required-to-use-ngmodel\n - guide/template-syntax#guard-against-null\n - guide/template-syntax#how-a-reference-variable-gets-its-value\n - guide/template-syntax#html-attribute-vs-dom-property\n - guide/template-syntax#html-in-templates\n - guide/template-syntax#input-and-output-properties\n - guide/template-syntax#input-or-output\n - guide/template-syntax#inputs-outputs\n - guide/template-syntax#inside-ngmodel\n - guide/template-syntax#interpolation-\n - guide/template-syntax#interpolation-and-template-expressions\n - guide/template-syntax#ngClass\n - guide/template-syntax#ngFor\n - guide/template-syntax#ngIf\n - guide/template-syntax#ngModel\n - guide/template-syntax#ngStyle\n - guide/template-syntax#ngSwitch\n - guide/template-syntax#ngclass\n - guide/template-syntax#ngfor-microsyntax\n - guide/template-syntax#ngfor-with-index\n - guide/template-syntax#ngfor-with-trackby\n - guide/template-syntax#ngforof\n - guide/template-syntax#ngif\n - guide/template-syntax#ngmodel---two-way-binding-to-form-elements-with-ngmodel\n - guide/template-syntax#ngstyle\n - guide/template-syntax#no-visible-side-effects\n - guide/template-syntax#one-time-string-initialization\n - guide/template-syntax#one-way-in\n - guide/template-syntax#property-binding\n - guide/template-syntax#property-binding--property-\n - guide/template-syntax#property-binding-or-interpolation\n - guide/template-syntax#quick-execution\n - guide/template-syntax#ref-vars\n - guide/template-syntax#remember-the-brackets\n - guide/template-syntax#return-the-proper-type\n - guide/template-syntax#safe-navigation-operator\n - guide/template-syntax#showhide-is-not-the-same-thing\n - guide/template-syntax#simplicity\n - guide/template-syntax#statement-context\n - guide/template-syntax#statement-guidelines\n - guide/template-syntax#structural-directives\n - guide/template-syntax#style-binding\n - guide/template-syntax#target-event\n - guide/template-syntax#template-expression-operators\n - guide/template-syntax#template-expressions\n - guide/template-syntax#template-input-variable\n - guide/template-syntax#template-input-variables\n - guide/template-syntax#template-reference-variable-warning-notes\n - guide/template-syntax#template-reference-variables--var-\n - guide/template-syntax#template-statements\n - guide/template-syntax#template-statements-have-side-effects\n - guide/template-syntax#template-syntax\n - guide/template-syntax#the-any-type-cast-function\n - guide/template-syntax#the-ngswitch-directives\n - guide/template-syntax#the-non-null-assertion-operator---\n - guide/template-syntax#the-pipe-operator---\n - guide/template-syntax#the-safe-navigation-operator----and-null-property-paths\n - guide/template-syntax#top-of-page\n - guide/template-syntax#two-way\n - guide/template-syntax#two-way-binding---\n - guide/template-syntax#typescript-public-doesnt-matter\n - http://www.typescriptlang.org/docs/handbook/basic-types.html#any\n - http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html\n - http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator\n - https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement\n - https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA\n - https://developer.mozilla.org/en-US/docs/Web/Events\n - https://developer.mozilla.org/en-US/docs/Web/SVG\n - https://developer.mozilla.org/en-US/docs/Web/Web_Components\n - https://en.wikipedia.org/wiki/Idempotence\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/template-syntax.md?message=docs%3A%20请简述你的修改...\n-->"
}