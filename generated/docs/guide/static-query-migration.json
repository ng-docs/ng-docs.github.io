{
  "id": "guide/static-query-migration",
  "title": "静态查询（Static Query）迁移指南",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/static-query-migration.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"static-query-migration-guide\">Static query migration guide<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#static-query-migration-guide\"><i class=\"material-icons\">link</i></a></h1>\n<p>​</p>\n<h1 id=\"静态查询（static-query）迁移指南\">静态查询（Static Query）迁移指南<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#静态查询（static-query）迁移指南\"><i class=\"material-icons\">link</i></a></h1>\n<p translation-result=\"on\"><strong>给库作者的重要提示：这份迁移指南对于库作者非常重要，可以方便他们的用户升级到（Angular 的）版本 9（大约在 2019 年 10 月发布）。</strong></p><p translation-origin=\"off\">​\n<strong>Important note for library authors: This migration is especially crucial for library authors to facilitate their users upgrading to version 9 when it becomes available (approx Oct 2019).</strong></p>\n\n<p translation-result=\"on\">在版本 9 中，<code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 和 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 这两个查询的默认设置会改变，以修复查询中的 BUG 和意外行为（详情参阅<a href=\"guide/static-query-migration#what-does-this-flag-mean\">此处</a>）。</p><p translation-origin=\"off\">In version 9, the default setting for <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> and <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> queries is changing in order to fix buggy and surprising behavior in queries (read more about that <a href=\"guide/static-query-migration#what-does-this-flag-mean\">here</a>).</p>\n\n<p translation-result=\"on\">为了应对这个变化，我们从版本 8 开始就要开始迁移所有应用和库，显式指定 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 和 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 查询的解析策略。</p><p translation-origin=\"off\">In preparation for this change, in version 8, we are migrating all applications and libraries to explicitly specify the resolution strategy for <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> and <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> queries.</p>\n\n<p translation-result=\"on\">具体来说，这次迁移会添加一个显式的 “static” 标志，用来指出应该何时对该查询的结果进行赋值。等升级到版本 9 的时候，这个标志可以确保这些代码的工作方式都是一样的。</p><p translation-origin=\"off\">Specifically, this migration adds an explicit \"static\" flag that dictates when that query's results should be assigned.\nAdding this flag will ensure your code works the same way when upgrading to version 9.</p>\n\n<p translation-result=\"on\">之前：</p><p translation-origin=\"off\">Before:</p>\n\n<code-example>\n// <a href=\"api/animations/query\" class=\"code-anchor\">query</a> results sometimes available in `ngOnInit`, sometimes in `ngAfterViewInit` (based on template)\n@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('foo') foo: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n</code-example>\n<p translation-result=\"on\">之后：</p><p translation-origin=\"off\">After:</p>\n\n<code-example>\n// <a href=\"api/animations/query\" class=\"code-anchor\">query</a> results available in ngOnInit\n@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('foo', {<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}) foo: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n\nOR\n\n// <a href=\"api/animations/query\" class=\"code-anchor\">query</a> results available in ngAfterViewInit\n@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('foo', {<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}) foo: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n</code-example>\n<p translation-result=\"on\">从版本 9 开始，<code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 标志将默认为 <code>false</code>。那时候，可以安全地删除所有 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code> 标志，而且我们还会提供一个能帮你更新代码的原理图（schematic）。</p><p translation-origin=\"off\">Starting with version 9, the <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> flag will default to false.\nAt that time, any <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code> flags can be safely removed, and we will have a schematic that will update your code for you.</p>\n\n<p translation-result=\"on\">注意：这个标志只适用于 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 和 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 这两个查询，这是因为 <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 和 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查询都没有静态和动态的概念（它们总是“动态”解析）。</p><p translation-origin=\"off\">Note: this flag only applies to <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> and <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> queries specifically, as <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> and <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> queries do not have a concept of static and dynamic (they are always resolved as if they are \"dynamic\").</p>\n\n<h2 id=\"faq\" translation-result=\"on\">常见问题<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#faq\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"faq\">FAQ<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#faq\"><i class=\"material-icons\">link</i></a></h2>\n\n<a id=\"what-to-do-with-todo\"></a>\n<h3 id=\"what-should-i-do-if-i-see-a--todo-add-static-flag--comment-printed-by-the-schematic\" translation-result=\"on\">当看到由原理图添加的 <code>/* TODO: add <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> flag */</code> 注释时，我该怎么办？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#what-should-i-do-if-i-see-a--todo-add-static-flag--comment-printed-by-the-schematic\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"what-should-i-do-if-i-see-a--todo-add-static-flag--comment-printed-by-the-schematic\">What should I do if I see a <code>/* TODO: add <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> flag */</code> comment printed by the schematic?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#what-should-i-do-if-i-see-a--todo-add-static-flag--comment-printed-by-the-schematic\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果你看到这个注释，就意味着原理图无法自己找到恰当的标志。在这种情况下，你必须根据应用的行为添加正确的标志。要了解如何进行选择，请参阅<a href=\"guide/static-query-migration#how-do-i-choose\">下一个问题</a> 。</p><p translation-origin=\"off\">If you see this comment, it means that the schematic couldn't statically figure out the correct flag. In this case, you'll have to add the correct flag based on your application's behavior.\nFor more information on how to choose, see the <a href=\"guide/static-query-migration#how-do-i-choose\">next question</a>.</p>\n\n<a id=\"how-do-i-choose\"></a>\n<h3 id=\"how-do-i-choose-which-static-flag-value-to-use-true-or-false\" translation-result=\"on\">如何选择 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 标志：<code>true</code> 还是 <code>false</code>？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#how-do-i-choose-which-static-flag-value-to-use-true-or-false\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"how-do-i-choose-which-static-flag-value-to-use-true-or-false\">How do I choose which <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> flag value to use: <code>true</code> or <code>false</code>?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#how-do-i-choose-which-static-flag-value-to-use-true-or-false\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在官方 API 文档中，我们建议对于<a href=\"https://angular.io/api/core/ViewChild#description\">视图查询</a> 总是在 <code>ngAfterViewInit</code>中获取查询结果，对于<a href=\"https://angular.io/api/core/ContentChild#description\">内容查询</a> 总是在 <code>ngAfterContentInit</code> 中获取查询结果。\n这是因为当这些生命周期钩子运行时，相关节点的变更检测已完成，我们可以确信收集到了所有可能的查询结果。</p><p translation-origin=\"off\">In the official API docs, we have always recommended retrieving query results in <a href=\"https://angular.io/api/core/ViewChild#description\"><code>ngAfterViewInit</code> for view queries</a> and <a href=\"https://angular.io/api/core/ContentChild#description\"><code>ngAfterContentInit</code> for content queries</a>.\nThis is because by the time those lifecycle hooks run, change detection has completed for the relevant nodes and we can guarantee that we have collected all the possible query results.</p>\n\n<p translation-result=\"on\">由于这个原因，大多数应用都应该使用 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code>。这个设置可以确保找出那些依赖于绑定解析的查询结果（比如 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 内的查询）。</p><p translation-origin=\"off\">Most applications will want to use <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code> for the same reason. This setting will ensure query matches that are dependent on binding resolution (e.g. results inside <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>s or <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>s) will be found by the query.</p>\n\n<p translation-result=\"on\">在某些很少见的情况下，必须使用 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}</code> 标志（参见<a href=\"guide/static-query-migration#should-i-use-static-true\">这里的回答</a>）。</p><p translation-origin=\"off\">There are rarer cases where <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}</code> flag might be necessary (see <a href=\"guide/static-query-migration#should-i-use-static-true\">answer here</a>).</p>\n\n<a id=\"should-i-use-static-true\"></a>\n<h3 id=\"is-there-a-case-where-i-should-use-static-true\" translation-result=\"on\">什么情况下我应该用 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}</code>？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#is-there-a-case-where-i-should-use-static-true\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"is-there-a-case-where-i-should-use-static-true\">Is there a case where I should use <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}</code>?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#is-there-a-case-where-i-should-use-static-true\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">这个选项的引入是为了支持动态创建嵌入式视图。如果你要查询一个 <code><a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a></code> 以便动态创建一个视图，将无法在 <code>ngAfterViewInit</code> 中这样做。这是因为变量检测已在该视图上运行过，所以这时候使用该模板创建一个新视图就会抛出 <code>ExpressionHasChangedAfterChecked</code> 错误。在这种情况下，你要把 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 标志设置为 <code>true</code>，并在 <code>ngOnInit</code> 中创建你的视图。在其他大多数情况下，最好的做法是使用 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code>。</p><p translation-origin=\"off\">This option was introduced to support creating embedded views on the fly.\nIf you need access to a <code><a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a></code> in a query to create a view dynamically, you won't be able to do so in <code>ngAfterViewInit</code>.\nChange detection has already run on that view, so creating a new view with the template will cause an <code>ExpressionHasChangedAfterChecked</code> error to be thrown.\nIn this case, you will want to set the <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> flag to <code>true</code> and create your view in <code>ngOnInit</code>.\nIn most other cases, the best practice is to use <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code>.</p>\n\n<p translation-result=\"on\">为了便于迁移到版本 8 中，如果你的组件代码期望这些查询的结果在 <code>ngAfterViewInit</code>（对于视图查询）或 <code>ngAfterContentInit</code>（对于内容查询）<strong>之前</strong>的某个时刻就已经可用，可能也要把 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 标志设置为 <code>true</code>。例如，如果你的组件期望在 <code>ngOnInit</code> 钩子或 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 的 setter 中这些查询结果已经就绪，就要把该标志设置为 <code>true</code> 或者改写你的组件以推迟它的执行时间。</p><p translation-origin=\"off\">However, to facilitate the migration to version 8, you may also want to set the <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> flag to <code>true</code> if your component code already depends on the query results being available some time <strong>before</strong> <code>ngAfterViewInit</code> (for view queries) or <code>ngAfterContentInit</code> (for content queries).\nFor example, if your component relies on the query results being populated in the <code>ngOnInit</code> hook or in <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> setters, you will need to either set the flag to <code>true</code> or re-work your component to adjust to later timing.</p>\n\n<p translation-result=\"on\">注意：把 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 设置为 <code>true</code> 意味着此查询将不会发现嵌在 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 中的查询结果。只有在运行过变更检测之后才能取得这些结果。</p><p translation-origin=\"off\">Note: Selecting the static option means that query results nested in <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> or <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> will not be found by the query.\nThese results are only retrievable after change detection runs.</p>\n\n<a id=\"what-does-this-flag-mean\"></a>\n<h3 id=\"what-does-this-flag-mean-and-why-is-it-necessary\" translation-result=\"on\">这个标志是什么意思，它有什么必要？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#what-does-this-flag-mean-and-why-is-it-necessary\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"what-does-this-flag-mean-and-why-is-it-necessary\">What does this flag mean and why is it necessary?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#what-does-this-flag-mean-and-why-is-it-necessary\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">以前，默认的查询行为一直没有文档记载，这会令人困惑，而且也常导致难以调试的问题。在版本 9 中，我们希望这种查询行为更加一致，也更容易理解。</p><p translation-origin=\"off\">The default behavior for queries has historically been undocumented and confusing, and has also commonly led to issues that are difficult to debug.\nIn version 9, we would like to make query behavior more consistent and simple to understand.</p>\n\n<p translation-result=\"on\">为了解释其原由，首先要弄清楚到目前为止这些查询是如何工作的。</p><p translation-origin=\"off\">To explain why, first it's important to understand how queries have worked up until now.</p>\n\n<p translation-result=\"on\">当没有 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 标志时，编译器会自行决定每个查询该如何解析。所有的 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> / <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 查询在编译时都会被归类为两种方式之一：“static” 或 “dynamic”。当查询结果可供用户使用时，就会决定该使用何种方式。</p><p translation-origin=\"off\">Without the <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> flag, the compiler decided when each query would be resolved on a case-by-case basis.\nAll <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code>/<code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> queries were categorized into one of two buckets at compile time: \"static\" or \"dynamic\".\nThis classification determined when query results would become available to users.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">  <strong>静态查询</strong>的查询结果是可以静态确定的，因为其结果并不依赖运行期间的值（比如数据绑定）。静态查询的结果在该视图运行变更检测之前就是可用的（可以在<code>ngOnInit</code>访问）。</p><p translation-origin=\"off\"><strong>Static queries</strong> were queries where the result could be determined statically because the result didn't depend on runtime values like bindings.\nResults from queries classified as static were available before change detection ran for that view (accessible in <code>ngOnInit</code>).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">  <strong>动态查询</strong>是那些无法静态确定结果的查询，因为其结果取决于运行期间的值（比如数据绑定）。动态查询的结果在运行该视图的变更检测之前是不可用的（只能在 <code>ngAfterContentInit</code> 中访问内容查询或在 <code>ngAfterViewInit</code> 中访问视图查询）。</p><p translation-origin=\"off\"><strong>Dynamic queries</strong> were queries where the result could NOT be determined statically because the result depended on runtime values (aka bindings).\nResults from queries classified as dynamic were not available until after change detection ran for that view (accessible in <code>ngAfterContentInit</code> for content queries or <code>ngAfterViewInit</code> for view queries).</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">例如，假设我们有一个组件 <code>Comp</code> 。在其中，我们有这样一个查询：</p><p translation-origin=\"off\">For example, let's say we have a component, <code>Comp</code>. Inside it, we have this query:</p>\n\n<code-example>\n@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>(Foo) foo: Foo;\n</code-example>\n<p translation-result=\"on\">和这样的模板：</p><p translation-origin=\"off\">and this template:</p>\n\n<code-example>\n&#x3C;div foo>&#x3C;/div>\n</code-example>\n<p translation-result=\"on\">这个 <code>Foo</code> 查询会被归类为静态查询，这是因为在编译时，就已经知道 <code>&#x3C;div></code> 上的 <code>Foo</code> 实例是正确的查询结果了。由于查询结果并不依赖于运行时的值，所以在解析此查询之前，我们不必等待模板上的变更检测。因此，在 <code>ngOnInit</code> 中这些结果就已经可用了。</p><p translation-origin=\"off\">This <code>Foo</code> query would be categorized as static because at compile-time it's known that the <code>Foo</code> instance on the <code>&#x3C;div></code> is the correct result for the query.\nBecause the query result is not dependent on runtime values, we don't have to wait for change detection to run on the template before resolving the query.\nConsequently, results can be made available in <code>ngOnInit</code>.</p>\n\n<p translation-result=\"on\">假设查询不变，但组件模板改成了这样：</p><p translation-origin=\"off\">Let's say the query is the same, but the component template looks like this:</p>\n\n<code-example>\n&#x3C;div foo *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"showing\">&#x3C;/div>\n</code-example>\n<p translation-result=\"on\">对于该模板，该查询将被归类为动态查询。我们需要知道 <code>showing</code> 在运行期间的值以确定该查询的正确结果应该是什么。因此，必须首先运行变更检测，其结果只能在 <code>ngAfterViewInit</code> 或该查询属性的 setter 中才能使用。</p><p translation-origin=\"off\">With that template, the query would be categorized as a dynamic query.\nWe would need to know the runtime value of <code>showing</code> before determining what the correct results are for the query.\nAs a result, change detection must run first, and results can only be made available in <code>ngAfterViewInit</code> or a setter for the query property.</p>\n\n<p translation-result=\"on\">这种实现方式的效果是，在查询匹配的任何父级节点添加 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 会导致：当查询结果可用之后，其匹配结果也会发生变化。</p><p translation-origin=\"off\">The effect of this implementation is that adding an <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> or <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> anywhere above a query match can change when that query's results become available.</p>\n\n<p translation-result=\"on\">请记住，这些类别只能用于 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 和 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 这两种查询。而 <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 和 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查询都没有静态和动态的概念，它们总是“动态”解析。</p><p translation-origin=\"off\">Keep in mind that these categories only applied to <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> and <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> queries specifically.\n<code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> and <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> queries did not have a concept of static and dynamic, so they were always resolved as if they were \"dynamic\".</p>\n\n<p translation-result=\"on\">这种策略会根据查询所在的位置，在不同的时机进行解析，这引起了很大的困惑。即：</p><p translation-origin=\"off\">This strategy of resolving queries at different times based on the location of potential query matches has caused a lot of confusion. Namely:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">其查询结果在 <code>ngOnInit</code> 中有时可用有时不可用，而且还不清楚为什么（参见 <a href=\"https://github.com/angular/angular/issues/21800\">21800</a> 或 <a href=\"https://github.com/angular/angular/issues/19872\">19872</a>）。</p><p translation-origin=\"off\">Sometimes query results are available in <code>ngOnInit</code>, but sometimes they aren't and it's not clear why (see <a href=\"https://github.com/angular/angular/issues/21800\">21800</a> or <a href=\"https://github.com/angular/angular/issues/19872\">19872</a>).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">  <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 查询和 <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 查询的解析时机不一样，而 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 查询和 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查询的解析时机也不一样。如果用户把 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 查询换成 <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 查询，那么他们的代码就会突然崩溃，因为其解析时机已经变化了。</p><p translation-origin=\"off\"><code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> queries are resolved at a different time from <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> queries, and <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> queries are resolved at a different time from <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> queries.\nIf a user turns a <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> query into a <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> query, their code can break suddenly because the timing has shifted.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">一旦往模板中添加了 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>，依赖于查询结果的代码就会突然停止工作。</p><p translation-origin=\"off\">Code depending on a query result can suddenly stop working as soon as an <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> or an <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> is added to a template.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">  当每次使用该组件时，针对同一个组件的 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 查询却会在生命周期的不同时机进行解析。这导致了一些错误的行为，即：带 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 的组件会以一种对组件作者来说很隐晦的、微妙的方式被破坏。</p><p translation-origin=\"off\">A <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> query for the same component will resolve at different times in the lifecycle for each usage of the component.\nThis leads to buggy behavior where using a component with <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> is broken in subtle ways that aren't obvious to the component author.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">在版本 9 中，我们准备简化这种行为：默认情况下，每当运行变更检测之后，都会解析所有查询。\n模板中查询的位置不会再影响查询结果何时可用，也不会突然破坏你的代码，其默认行为总是一样的。这样，这种逻辑对于用户来说就更加一致、更加可预测。</p><p translation-origin=\"off\">In version 9, we plan to simplify the behavior so all queries resolve after change detection runs by default.\nThe location of query matches in the template cannot affect when the query result will become available and suddenly break your code, and the default behavior is always the same.\nThis makes the logic more consistent and predictable for users.</p>\n\n<p translation-result=\"on\">也就是说，如果一个应用程序确实需要更早拿到查询结果（例如，在创建嵌入式视图时需要这种查询结果），就可以添加 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}</code> 标志来明确要求静态解析。有了这个标志，用户就可以表明他们只关心那些静态可用的结果，并且在 <code>ngOnInit</code> 之前就会填上查询结果。</p><p translation-origin=\"off\">That said, if an application does need query results earlier (for example, the query result is needed to create an embedded view), it's possible to add the <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}</code> flag to explicitly ask for static resolution.\nWith this flag, users can indicate that they only care about results that are statically available and the query results will be populated before <code>ngOnInit</code>.</p>\n\n<a id=\"view-children-and-content-children\"></a>\n<h3 id=\"does-this-change-affect-viewchildren-or-contentchildren-queries\" translation-result=\"on\">这项变化是否会影响 <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 或 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查询？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#does-this-change-affect-viewchildren-or-contentchildren-queries\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"does-this-change-affect-viewchildren-or-contentchildren-queries\">Does this change affect <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> or <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> queries?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#does-this-change-affect-viewchildren-or-contentchildren-queries\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">不，这项变化只会影响 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 和 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 查询。默认情况下，<code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 和 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查询已经是“动态”的，并且不支持静态解析。</p><p translation-origin=\"off\">No, this change only affects <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> and <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> queries specifically.\n<code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> and <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> queries are already \"dynamic\" by default and don't support static resolution.</p>\n\n<a id=\"why-specify-static-false\"></a>\n<h3 id=\"why-do-i-have-to-specify-static-false-isnt-that-the-default\" translation-result=\"on\">为什么我还要指定 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code>？它不是默认值吗？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#why-do-i-have-to-specify-static-false-isnt-that-the-default\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"why-do-i-have-to-specify-static-false-isnt-that-the-default\">​Why do I have to specify <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code>? Isn't that the default?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#why-do-i-have-to-specify-static-false-isnt-that-the-default\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">本次迁移的目的是把现在的版本 9 之前的应用转换为与版本 9 兼容的查询模式。然而，大多数应用都会用到库，而其中某些库可能还无法升级到版本 8（因而可能没有指定合适的标志值）。由于应用程序编译时会用到当前的 Angular 版本，所以如果我们修改了默认值，库里组件的查询行为就会变成版本 8 的这个默认值，这可能导致重大变更。而现在这种方式，应用程序的依赖项在转换过程中的行为就和之前的版本是一样的。</p><p translation-origin=\"off\">The goal of this migration is to transition apps that aren't yet on version 9 to a query pattern that is compatible with version 9.\nHowever, most applications use libraries, and it's likely that some of these libraries may not be upgraded to version 8 yet (and thus might not have the proper flags).\nSince the application's version of Angular will be used for compilation, if we change the default, the behavior of queries in the library's components will change to the version 8 default and possibly break.\nThis way, an application's dependencies will behave the same way during the transition as they did in the previous version.</p>\n\n<p translation-result=\"on\">在 Angular 9 及更高版本中，任意删除 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code> 标志都是安全的，届时，我们会在原理图中为你完成这个清理工作。</p><p translation-origin=\"off\">In Angular version 9 and later, it will be safe to remove any <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code> flags and we will do this cleanup for you in a schematic.</p>\n\n<a id=\"libraries\"></a>\n<h3 id=\"can-i-keep-on-using-angular-libraries-that-havent-yet-updated-to-version-8-yet\" translation-result=\"on\">我还可以继续使用尚未更新到版本 8 的 Angular 库吗？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#can-i-keep-on-using-angular-libraries-that-havent-yet-updated-to-version-8-yet\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"can-i-keep-on-using-angular-libraries-that-havent-yet-updated-to-version-8-yet\">Can I keep on using Angular libraries that haven’t yet updated to version 8 yet?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#can-i-keep-on-using-angular-libraries-that-havent-yet-updated-to-version-8-yet\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">绝对没问题！\n因为我们没有改变版本 8 中的默认查询行为（比如编译器在没有设置任何标志的情况下仍然会自己选择一个合适的时机），所以当你的应用运行时，如果你的库没有更新到版本 8，该库的运行方式就和版本 7 中是一样的。这样就可以保证你的应用在版本 8 中仍然可以工作，不过这些库的开发者就需要花费更长的时间来修改代码了。</p><p translation-origin=\"off\">Yes, absolutely!\nBecause we have not changed the default query behavior in version 8 (i.e. the compiler still chooses a timing if no flag is set), when your application runs with a library that has not updated to version 8, the library will run the same way it did in version 7.\nThis guarantees your app will work in version 8 even if libraries take longer to update their code.</p>\n\n<a id=\"update-library-to-use-static-flag\"></a>\n<h3 id=\"can-i-update-my-library-to-version-8-by-adding-the-static-flag-to-view-queries-while-still-being-compatible-with-angular-version-7-apps\">Can I update my library to version 8 by adding the <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> flag to view queries, while still being compatible with Angular version 7 apps?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#can-i-update-my-library-to-version-8-by-adding-the-static-flag-to-view-queries-while-still-being-compatible-with-angular-version-7-apps\"><i class=\"material-icons\">link</i></a></h3>\n<p>Yes, the Angular team's recommendation for libraries is to update to version 8 and add the <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> flag. Angular version 7 apps will continue to work with libraries that have this flag.</p>\n<p>However, if you update your library to Angular version 8 and want to take advantage of the new version 8 APIs, or you want more recent dependencies (such as Typescript or RxJS) your library will become incompatible with Angular version 7 apps. If your goal is to make your library compatible with Angular versions 7 and 8, you should not update your lib at all—except for <code>peerDependencies</code> in <code>package.json</code>.</p>\n<p>In general, the most efficient plan is for libraries to adopt a 6 month major version schedule and bump the major version after each Angular update. That way, libraries stay in the same release cadence as Angular.</p>\n\n</div>\n\n<!-- links to this doc:\n - guide/deprecations\n - guide/migration-dynamic-flag\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/common/NgForOf\n - api/common/NgIf\n - api/core/ContentChild\n - api/core/ContentChildren\n - api/core/ElementRef\n - api/core/Input\n - api/core/TemplateRef\n - api/core/ViewChild\n - api/core/ViewChildren\n - api/upgrade/static\n - guide/static-query-migration#can-i-keep-on-using-angular-libraries-that-havent-yet-updated-to-version-8-yet\n - guide/static-query-migration#can-i-update-my-library-to-version-8-by-adding-the-static-flag-to-view-queries-while-still-being-compatible-with-angular-version-7-apps\n - guide/static-query-migration#does-this-change-affect-viewchildren-or-contentchildren-queries\n - guide/static-query-migration#faq\n - guide/static-query-migration#how-do-i-choose\n - guide/static-query-migration#how-do-i-choose-which-static-flag-value-to-use-true-or-false\n - guide/static-query-migration#is-there-a-case-where-i-should-use-static-true\n - guide/static-query-migration#should-i-use-static-true\n - guide/static-query-migration#static-query-migration-guide\n - guide/static-query-migration#what-does-this-flag-mean\n - guide/static-query-migration#what-does-this-flag-mean-and-why-is-it-necessary\n - guide/static-query-migration#what-should-i-do-if-i-see-a--todo-add-static-flag--comment-printed-by-the-schematic\n - guide/static-query-migration#why-do-i-have-to-specify-static-false-isnt-that-the-default\n - guide/static-query-migration#静态查询（static-query）迁移指南\n - https://angular.io/api/core/ContentChild#description\n - https://angular.io/api/core/ViewChild#description\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/static-query-migration.md?message=docs%3A%20请简述你的修改...\n - https://github.com/angular/angular/issues/19872\n - https://github.com/angular/angular/issues/21800\n-->"
}