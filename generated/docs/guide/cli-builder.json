{
  "id": "guide/cli-builder",
  "title": "Angular CLI builders",
  "contents": "\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/cli-builder.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"angular-cli-builders\" translation-result=\"on\">Angular CLI 构建器（Builder）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#angular-cli-builders\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"angular-cli-builders\">Angular CLI builders<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#angular-cli-builders\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">很多 Angular CLI 命令都要在你的代码上执行一些复杂的处理，比如风格检查（lint）构建或测试。这些命令会通过一个叫做建筑师（Architect）的内部工具来运行 <em>CLI 构建器</em>，而这些构建器会运用一些第三方工具来完成目标任务。</p><p translation-origin=\"off\">A number of Angular CLI commands run a complex process on your code, such as linting, building, or testing.\nThe commands use an internal tool called Architect to run <em>CLI builders</em>, which apply another tool to accomplish the desired task.</p>\n\n<p translation-result=\"on\">在 Angular 的版本 8 中，CLI 构建器的 API 是稳定的，想要通过添加或修改命令来自定义 Angular CLI 的开发人员可以使用它。例如，你可以提供一个构建器来执行全新的任务，或者更改一个现有命令所使用的第三方工具。</p><p translation-origin=\"off\">With Angular version 8, the CLI Builder API is stable and available to developers who want to customize the Angular CLI by adding or modifying commands. For example, you could supply a builder to perform an entirely new task, or to change which third-party tool is used by an existing command.</p>\n\n<p translation-result=\"on\">本文档介绍了 CLI 构建器是如何与工作区配置文件集成的，还展示了如何创建你自己的构建器。</p><p translation-origin=\"off\">This document explains how CLI builders integrate with the workspace configuration file, and shows how you can create your own builder.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">   你可以在<a href=\"https://github.com/mgechev/cli-builders-demo\">这个 GitHub 仓库</a>中的例子中找到代码。</p><p translation-origin=\"off\">   You can find the code from the examples used here in <a href=\"https://github.com/mgechev/cli-builders-demo\">this GitHub repository</a>.</p>\n\n</div>\n<h2 id=\"cli-builders\" translation-result=\"on\">CLI 构建器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#cli-builders\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"cli-builders\">CLI builders<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#cli-builders\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">内部建筑师工具会把工作委托给名叫<a href=\"guide/glossary#builder\"><em>构建器</em></a>的处理器函数。处理器函数接收两个参数：一组 <code>options</code> 输入（JSON 对象）和一个 <code>context</code>（<code>BuilderContext</code> 对象）。</p><p translation-origin=\"off\">The internal Architect tool delegates work to handler functions called <a href=\"guide/glossary#builder\"><em>builders</em></a>.\nA builder handler function receives two arguments; a set of input <code>options</code> (a JSON object), and a <code>context</code> (a <code>BuilderContext</code> object).</p>\n\n<p translation-result=\"on\">这里对关注点的分离和<a href=\"guide/glossary#schematic\">原理图</a>中是一样的，它也适用于其它要接触（touch）代码的 CLI 命令（例如 <code>ng generate</code>）。</p><p translation-origin=\"off\">The separation of concerns here is the same as with <a href=\"guide/glossary#schematic\">schematics</a>, which are used for other CLI commands that touch your code (such as <code>ng generate</code>).</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">此 <code>options</code> 对象是由本 CLI 的用户提供的，而 <code>context</code> 对象则由 CLI 构建器的 API 提供。</p><p translation-origin=\"off\">The <code>options</code> object is provided by the CLI user, while the <code>context</code> object is provided by the CLI Builder API.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">除了上下文信息之外，此 <code>context</code> 对象（它是 <code>BuilderContext</code> 的实例）还允许你访问调度方法 <code>BuilderContext.scheduleTarget()</code>。调度器会用指定的<a href=\"guide/glossary#target\">目标配置</a>来执行构建器处理函数。</p><p translation-origin=\"off\">In addition to the contextual information, the <code>context</code> object, which is an instance of the <code>BuilderContext</code>, also provides access to a scheduling method, <code>BuilderContext.scheduleTarget()</code>. The scheduler executes the builder handler function with a given <a href=\"guide/glossary#target\">target configuration</a>.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">这个构建器处理函数可以是同步的（返回一个值）或异步的（返回一个 Promise），也可以监视并返回多个值（返回一个 Observable）。最终返回的值全都是 <code>BuilderOutput</code> 类型的。该对象包含一个逻辑字段 <code>success</code> 和一个可以包含错误信息的可选字段 <code>error</code>。</p><p translation-origin=\"off\">The builder handler function can be synchronous (return a value) or asynchronous (return a Promise), or it can watch and return multiple values (return an Observable).\nThe return value or values must always be of type <code>BuilderOutput</code>.\nThis object contains a Boolean <code>success</code> field and an optional <code>error</code> field that can contain an error message.</p>\n\n<p translation-result=\"on\">Angular 提供了一些构建器，供 CLI 命令使用，如 <code>ng build</code>、<code>ng test</code> 和 <code>ng lint</code> 等。这些内置 CLI 构建器的默认目标配置可以在<a href=\"guide/workspace-config\">工作区配置文件</a> <code>angular.json</code> 的 <code>architect</code> 部分找到（并进行自定义）。可以通过创建自己的构建器来扩展和自定义 Angular，你可以使用 <a href=\"cli/run\"><code>ng run</code> CLI 命令</a>来运行你自己的构建器。</p><p translation-origin=\"off\">Angular provides some builders that are used by the CLI for commands such as <code>ng build</code>, <code>ng test</code>, and <code>ng lint</code>.\nDefault target configurations for these and other built-in CLI builders can be found (and customized) in the \"architect\" section of the <a href=\"guide/workspace-config\">workspace configuration file</a>, <code>angular.json</code>.\nYou can also extend and customize Angular by creating your own builders, which you can run using the <a href=\"cli/run\"><code>ng run</code> CLI command</a>.</p>\n\n<h3 id=\"builder-project-structure\" translation-result=\"on\">构建器的项目结构<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#builder-project-structure\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"builder-project-structure\">Builder project structure<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#builder-project-structure\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">构建器位于一个 <code>project</code> 文件夹中，该文件夹的结构类似于 Angular 工作区，包括位于顶层的全局配置文件，以及位于工作代码所在源文件夹中的更具体的配置。例如，<code>myBuilder</code> 文件夹中可能包含如下文件。</p><p translation-origin=\"off\">A builder resides in a \"project\" folder that is similar in structure to an Angular workspace, with global configuration files at the top level, and more specific configuration in a source folder with the code files that define the behavior.\nFor example, your <code>myBuilder</code> folder could contain the following files.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><p translation-result=\"on\">文件</p><p translation-origin=\"off\">FILES</p></th>\n<th align=\"left\"><p translation-result=\"on\">目的</p><p translation-origin=\"off\">PURPOSE</p></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>src/my-builder.ts</code></td>\n<td align=\"left\"><p translation-result=\"on\">这个构建器定义的主要源码。</p><p translation-origin=\"off\">Main source file for the builder definition.</p></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>src/my-builder.spec.ts</code></td>\n<td align=\"left\"><p translation-result=\"on\">测试的源码。</p><p translation-origin=\"off\">Source file for tests.</p></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>src/schema.json</code></td>\n<td align=\"left\"><p translation-result=\"on\">构建器输入选项的定义。</p><p translation-origin=\"off\">Definition of builder input options.</p></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>builders.json</code></td>\n<td align=\"left\"><p translation-result=\"on\">测试配置。</p><p translation-origin=\"off\">Builders definition.</p></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>package.json</code></td>\n<td align=\"left\"><p translation-result=\"on\">依赖包。参阅 <a href=\"https://docs.npmjs.com/files/package.json\">https://docs.npmjs.com/files/package.json</a>。</p><p translation-origin=\"off\">Dependencies. See <a href=\"https://docs.npmjs.com/files/package.json\">https://docs.npmjs.com/files/package.json</a>.</p></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>tsconfig.json</code></td>\n<td align=\"left\"><p translation-result=\"on\"><a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\">TypeScript 配置文件</a></p><p translation-origin=\"off\"><a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\">TypeScript configuration</a>.</p></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">你可以把构建器发布到 <code>npm</code>（请参阅<a href=\"guide/creating-libraries#publishing-your-library\">发布你的库</a>）。如果把它发布成了 <code>@example/my-builder</code>，就可以使用下面的命令来安装它。</p><p translation-origin=\"off\">You can publish the builder to <code>npm</code> (see <a href=\"guide/creating-libraries#publishing-your-library\">Publishing your Library</a>). If you publish it as <code>@example/my-builder</code>, you can install it using the following command.</p>\n\n<code-example language=\"sh\">\n\nnpm install @example/my-builder\n\n</code-example>\n<h2 id=\"creating-a-builder\" translation-result=\"on\">创建构建器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#creating-a-builder\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"creating-a-builder\">Creating a builder<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#creating-a-builder\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">举个例子，让我们创建一个用来执行 shell 命令的构建器。要创建构建器，请使用 CLI 构建器函数 <code>createBuilder()</code>，并返回一个 <code>Promise&#x3C;BuilderOutput></code> 对象。</p><p translation-origin=\"off\">As an example, let's create a builder that executes a shell command.\nTo create a builder, use the <code>createBuilder()</code> CLI Builder function, and return a <code>Promise&#x3C;BuilderOutput></code> object.</p>\n\n<code-example path=\"cli-builder/src/my-builder.ts\" header=\"src/my-builder.ts (builder skeleton)\" region=\"builder-skeleton\">\nimport { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';\nimport { JsonObject } from '@angular-devkit/core';\n\ninterface Options extends JsonObject {\n  command: string;\n  args: string[];\n}\n\nexport default createBuilder(commandBuilder);\n\nfunction commandBuilder(\n  options: Options,\n  context: BuilderContext,\n  ): Promise&#x3C;BuilderOutput> {\n}\n\n\n</code-example>\n<p translation-result=\"on\">现在，让我们为它添加一些逻辑。下列代码会从用户选项中检索命令和参数、生成新进程，并等待该进程完成。如果进程成功（返回代码为 0），就会解析成返回的值。</p><p translation-origin=\"off\">Now let’s add some logic to it.\nThe following code retrieves the command and arguments from the user options, spawns the new process, and waits for the process to finish.\nIf the process is successful (returns a code of 0), it resolves the return value.</p>\n\n<code-example path=\"cli-builder/src/my-builder.ts\" header=\"src/my-builder.ts (builder)\" region=\"builder\">\nimport { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';\nimport { JsonObject } from '@angular-devkit/core';\nimport * as childProcess from 'child_process';\n\ninterface Options extends JsonObject {\n  command: string;\n  args: string[];\n}\n\nexport default createBuilder(commandBuilder);\n\nfunction commandBuilder(\n  options: Options,\n  context: BuilderContext,\n  ): Promise&#x3C;BuilderOutput> {\n    const child = childProcess.spawn(options.command, options.args);\n    return new Promise(resolve => {\n      child.on('close', code => {\n        resolve({ success: code === 0 });\n      });\n    });\n}\n\n\n</code-example>\n<h3 id=\"handling-output\" translation-result=\"on\">处理输出<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#handling-output\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"handling-output\">Handling output<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#handling-output\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">默认情况下，<code>spawn()</code> 方法会把所有内容输出到进程标准输出（stdout）和标准错误（stderr）中。为了便于测试和调试，我们可以把输出转发给 CLI 构建器的 Logger。这样还能让构建器本身可以在一个单独的进程中执行，即使其标准输出和标准错误被停用了也无所谓（就像在 <a href=\"https://electronjs.org/\">Electron 应用中一样</a>）。</p><p translation-origin=\"off\">By default, the <code>spawn()</code> method outputs everything to the process standard output and error.\nTo make it easier to test and debug, we can forward the output to the CLI Builder logger instead.\nThis also allows the builder itself to be executed in a separate process, even if the standard output and error are deactivated (as in an <a href=\"https://electronjs.org/\">Electron app</a>).</p>\n\n<p translation-result=\"on\">我们可以从上下文中检索一个 Logger 实例。</p><p translation-origin=\"off\">We can retrieve a Logger instance from the context.</p>\n\n<code-example path=\"cli-builder/src/my-builder.ts\" header=\"src/my-builder.ts (handling output)\" region=\"handling-output\">\nimport { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';\nimport { JsonObject } from '@angular-devkit/core';\nimport * as childProcess from 'child_process';\n\ninterface Options extends JsonObject {\n  command: string;\n  args: string[];\n}\n\nexport default createBuilder(commandBuilder);\n\nfunction commandBuilder(\n  options: Options,\n  context: BuilderContext,\n  ): Promise&#x3C;BuilderOutput> {\n    const child = childProcess.spawn(options.command, options.args);\n\n    child.stdout.on('data', data => {\n      context.logger.info(data.toString());\n    });\n    child.stderr.on('data', data => {\n      context.logger.error(data.toString());\n    });\n\n    return new Promise(resolve => {\n      child.on('close', code => {\n        resolve({ success: code === 0 });\n      });\n    });\n}\n\n\n</code-example>\n<h3 id=\"progress-and-status-reporting\" translation-result=\"on\">进度和状态报告<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#progress-and-status-reporting\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"progress-and-status-reporting\">Progress and status reporting<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#progress-and-status-reporting\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">CLI 构建器 API 包含一些进度报告和状态报告工具，可以为某些函数和接口提供提示信息。</p><p translation-origin=\"off\">The CLI Builder API includes progress and status reporting tools, which can provide hints for certain functions and interfaces.</p>\n\n<p translation-result=\"on\">要报告进度，请使用 <code>BuilderContext.reportProgress()</code> 方法，它接受一个当前值（value）、一个（可选的）总值（total）和状态（status）字符串作为参数。总值可以是任意数字，例如，如果你知道有多少个文件需要处理，那么总值可能是这些文件的数量，而当前值是已处理过的数量。除非传入了新的字符串，否则这个状态字符串不会改变。</p><p translation-origin=\"off\">To report progress, use the <code>BuilderContext.reportProgress()</code> method, which takes a current value, (optional) total, and status string as arguments.\nThe total can be any number; for example, if you know how many files you have to process, the total could be the number of files, and current should be the number processed so far.\nThe status string is unmodified unless you pass in a new string value.</p>\n\n<p translation-result=\"on\">你可以看看 <code>tslint</code> 构建器如何报告进度的<a href=\"https://github.com/angular/angular-cli/blob/ba21c855c0c8b778005df01d4851b5a2176edc6f/packages/angular_devkit/build_angular/src/tslint/index.ts#L107\">例子</a>。</p><p translation-origin=\"off\">You can see an <a href=\"https://github.com/angular/angular-cli/blob/ba21c855c0c8b778005df01d4851b5a2176edc6f/packages/angular_devkit/build_angular/src/tslint/index.ts#L107\">example</a> of how the <code>tslint</code> builder reports progress.</p>\n\n<p translation-result=\"on\">在我们的例子中，shell 命令或者已完成或者正在执行，所以不需要进度报告，但是可以报告状态，以便调用此构建器的父构建器知道发生了什么。可以用 <code>BuilderContext.reportStatus()</code> 方法生成一个任意长度的状态字符串。（注意，无法保证长字符串会完全显示出来，可以裁剪它以适应界面显示。）传入一个空字符串可以移除状态。</p><p translation-origin=\"off\">In our example, the shell command either finishes or is still executing, so there’s no need for a progress report, but we can report status so that a parent builder that called our builder would know what’s going on.\nUse the <code>BuilderContext.reportStatus()</code> method to generate a status string of any length.\n(Note that there’s no guarantee that a long string will be shown entirely; it could be cut to fit the UI that displays it.)\nPass an empty string to remove the status.</p>\n\n<code-example path=\"cli-builder/src/my-builder.ts\" header=\"src/my-builder.ts (progress reporting)\" region=\"progress-reporting\">\nimport { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';\nimport { JsonObject } from '@angular-devkit/core';\nimport * as childProcess from 'child_process';\n\ninterface Options extends JsonObject {\n  command: string;\n  args: string[];\n}\n\nexport default createBuilder(commandBuilder);\n\nfunction commandBuilder(\n  options: Options,\n  context: BuilderContext,\n  ): Promise&#x3C;BuilderOutput> {\n    context.reportStatus(`Executing \"${options.command}\"...`);\n    const child = childProcess.spawn(options.command, options.args);\n\n    child.stdout.on('data', data => {\n      context.logger.info(data.toString());\n    });\n    child.stderr.on('data', data => {\n      context.logger.error(data.toString());\n    });\n\n    return new Promise(resolve => {\n      context.reportStatus(`Done.`);\n      child.on('close', code => {\n        resolve({ success: code === 0 });\n      });\n    });\n}\n\n\n</code-example>\n<h2 id=\"builder-input\" translation-result=\"on\">构建器的输入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#builder-input\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"builder-input\">Builder input<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#builder-input\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你可以通过 CLI 命令间接调用一个构建器，也可以直接用 Angular CLI 的 <code>ng run</code> 命令来调用它。无论哪种情况，你都必须提供所需的输入，但是可以用特定<a href=\"guide/glossary#target\"><em>目标</em></a>中预配置的值作为其默认值，然后指定一个预定义的、指定的配置进行覆盖，最后在命令行中进一步覆盖这些选项的值。</p><p translation-origin=\"off\">You can invoke a builder indirectly through a CLI command, or directly with the Angular CLI <code>ng run</code> command.\nIn either case, you must provide required inputs, but can allow other inputs to default to values that are pre-configured for a specific <a href=\"guide/glossary#target\"><em>target</em></a>, provide a pre-defined, named override configuration, and provide further override option values on the command line.</p>\n\n<h3 id=\"input-validation\" translation-result=\"on\">对输入的验证<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#input-validation\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"input-validation\">Input validation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#input-validation\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你可以在该构建器的相关 JSON 模式中定义构建器都有哪些输入。建筑师工具会把解析后的输入值收集到一个 <code>options</code> 对象中，并在将其传给构建器函数之前先根据这个模式验证它们的类型。（Schematics 库也对用户输入做了同样的验证）。</p><p translation-origin=\"off\">You define builder inputs in a JSON schema associated with that builder.\nThe Architect tool collects the resolved input values into an <code>options</code> object, and validates their types against the schema before passing them to the builder function.\n(The Schematics library does the same kind of validation of user input).</p>\n\n<p translation-result=\"on\">对于这个范例构建器，我们希望 <code>options</code> 值是带有两个键的 <code>JsonObject</code>：一个是字符串型的 <code>command</code>，一个是字符串数组型的 <code>args</code>。</p><p translation-origin=\"off\">For our example builder, we expect the <code>options</code> value to be a <code>JsonObject</code> with two keys: a <code>command</code> that is a string, and an <code>args</code> array of string values.</p>\n\n<p translation-result=\"on\">我们可以提供如下模式来对这些值的类型进行验证。</p><p translation-origin=\"off\">We can provide the following schema for type validation of these values.</p>\n\n<code-example language=\"json\" header=\"command/schema.json\">\n{\n  \"$schema\": \"http://json-schema.org/schema\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"command\": {\n      \"type\": \"string\"\n    },\n    \"args\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    }\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">这是一个非常简单的例子，但这种模式验证也可以非常强大。要了解更多信息，请参阅 <a href=\"http://json-schema.org/\">JSON 模式网站</a>。</p><p translation-origin=\"off\">This is a very simple example, but the use of a schema for validation can be very powerful.\nFor more information, see the <a href=\"http://json-schema.org/\">JSON schemas website</a>.</p>\n\n</div>\n<p translation-result=\"on\">要把构建器的实现与它的模式和名称关联起来，我们需要创建一个<em>构建器定义</em>文件，可以在 <code>package.json</code> 中指向该文件。</p><p translation-origin=\"off\">To link our builder implementation with its schema and name, we need to create a <em>builder definition</em> file, which we can point to in <code>package.json</code>.</p>\n\n<p translation-result=\"on\">创建一个名为 <code>builders.json</code> 文件，它看起来像这样。</p><p translation-origin=\"off\">Create a file named <code>builders.json</code> file that looks like this.</p>\n\n<code-example language=\"json\" header=\"builders.json\">\n\n{\n  \"builders\": {\n    \"command\": {\n      \"implementation\": \"./command\",\n      \"schema\": \"./command/schema.json\",\n      \"description\": \"Runs any command line in the operating system.\"\n    }\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">在 <code>package.json</code> 文件中，添加一个 <code>builders</code> 键，告诉建筑师工具可以在哪里找到这个构建器定义文件。</p><p translation-origin=\"off\">In the <code>package.json</code> file, add a <code>builders</code> key that tells the Architect tool where to find our builder definition file.</p>\n\n<code-example language=\"json\" header=\"package.json\">\n\n{\n  \"name\": \"@example/command-runner\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Builder for Command Runner\",\n  \"builders\": \"builders.json\",\n  \"devDependencies\": {\n    \"@angular-devkit/architect\": \"^1.0.0\"\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">现在，这个构建器的正式名字是 <code>@example/command-runner:command</code>。第一部分是包名（使用 node 方案进行解析），第二部分是构建器名称（使用 <code>builders.json</code> 文件进行解析）。</p><p translation-origin=\"off\">The official name of our builder is now <code> @example/command-runner:command</code>.\nThe first part of this is the package name (resolved using node resolution), and the second part is the builder name (resolved using the <code>builders.json</code> file).</p>\n\n<p translation-result=\"on\">使用某个 <code>options</code> 是非常简单的。在上一节，我们就曾访问过 <code>options.command</code>。</p><p translation-origin=\"off\">Using one of our <code>options</code> is very straightforward, we did this in the previous section when we accessed <code>options.command</code>.</p>\n\n<code-example path=\"cli-builder/src/my-builder.ts\" header=\"src/my-builder.ts (report status)\" region=\"report-status\">\ncontext.reportStatus(`Executing \"${options.command}\"...`);\nconst child = childProcess.spawn(options.command, options.args);\n\n</code-example>\n<h3 id=\"target-configuration\" translation-result=\"on\">目标配置<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#target-configuration\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"target-configuration\">Target configuration<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#target-configuration\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">构建器必须有一个已定义的目标，此目标会把构建器与特定的输入配置和<a href=\"guide/glossary#project\">项目</a>关联起来。</p><p translation-origin=\"off\">A builder must have a defined target that associates it with a specific input configuration and <a href=\"guide/glossary#project\">project</a>.</p>\n\n<p translation-result=\"on\">目标是在 <a href=\"guide/workspace-config\">CLI 配置文件</a> <code>angular.json</code> 中定义的。目标用于指定要使用的构建器、默认的选项配置，以及指定的备用配置。建筑师工具使用目标定义来为一次特定的执行解析输入选项。</p><p translation-origin=\"off\">Targets are defined in the <code>angular.json</code> <a href=\"guide/workspace-config\">CLI configuration file</a>.\nA target specifies the builder to use, its default options configuration, and named alternative configurations.\nThe Architect tool uses the target definition to resolve input options for a given run.</p>\n\n<p translation-result=\"on\"><code>angular.json</code> 文件中为每个项目都有一节配置，每个项目的 <code>architect</code> 部分都会为 CLI 命令（例如 <code>build</code>、<code>test</code> 和 <code>lint</code>）配置构建器目标。默认情况下，<code>build</code> 命令会运行 <code>@angular-devkit/build-angular:<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a></code> 构建器来执行 <code>build</code> 任务，并传入 <code>angular.json</code> 中为 <code>build</code> 目标指定的默认选项值。</p><p translation-origin=\"off\">The  <code>angular.json</code> file has a section for each project, and the \"architect\" section of each project configures targets for builders used by CLI commands such as 'build', 'test', and 'lint'.\nBy default, for example, the <code>build</code> command runs the builder  <code>@angular-devkit/build-angular:<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a></code> to perform the build task, and passes in default option values as specified for the <code>build</code> target in   <code>angular.json</code>.</p>\n\n<code-example language=\"json\" header=\"angular.json\">\n{\n  \"myApp\": {\n    ...\n    \"architect\": {\n      \"build\": {\n        \"builder\": \"@angular-devkit/build-angular:browser\",\n        \"options\": {\n          \"outputPath\": \"dist/myApp\",\n          \"index\": \"src/index.html\",\n          ...\n        },\n        \"configurations\": {\n          \"production\": {\n            \"fileReplacements\": [\n              {\n                \"replace\": \"src/environments/environment.ts\",\n                \"with\": \"src/environments/environment.prod.ts\"\n              }\n            ],\n            \"optimization\": true,\n            \"outputHashing\": \"all\",\n            ...\n          }\n        }\n      },\n      ...\n\n</code-example>\n<p translation-result=\"on\">该命令会给构建器传递 <code>options</code> 节中指定的一组默认选项。如果你传入了 <code>--configuration=production</code> 标志，它就会使用 <code>production</code> 备用配置中指定的值进行覆盖。你可以在命令行中单独指定其它选项进行覆盖，还可以为 <code>build</code> 目标添加更多备用配置，以定义其它环境，比如 <code>stage</code> 或 <code>qa</code>。</p><p translation-origin=\"off\">The command passes the builder the set of default options specified in the \"options\" section.\nIf you pass the <code>--configuration=production</code> flag, it uses the override values specified in the <code>production</code> alternative configuration.\nYou can specify further option overrides individually on the command line.\nYou might also add more alternative configurations to the <code>build</code> target, to define other environments such as <code>stage</code> or <code>qa</code>.</p>\n\n<h4 id=\"target-strings\" translation-result=\"on\">目标字符串<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#target-strings\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"target-strings\">Target strings<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#target-strings\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">通用的 <code>ng run</code> CLI 命令的第一个参数是形如 <em>project:target[:configuration]</em> 的目标字符串。</p><p translation-origin=\"off\">The generic <code>ng run</code> CLI command takes as its first argument a target string of the form <em>project:target[:configuration]</em>.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><em>project</em>：与此目标关联的 Angular CLI 项目的名称。</p><p translation-origin=\"off\"><em>project</em>: The name of the Angular CLI project that the target is associated with.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><em>target</em>：<code>angular.json</code> 文件 <code>architect</code> 下的指定构建器配置。</p><p translation-origin=\"off\"><em>target</em>: A named builder configuration from the <code>architect</code> section of the <code>angular.json</code> file.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><em>configuration</em>：（可选）用于覆盖指定目标的具体配置名称，如 <code>angular.json</code> 文件中的定义。</p><p translation-origin=\"off\"><em>configuration</em>: (optional) The name of a specific configuration override for the given target, as defined in the <code>angular.json</code> file.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">如果你的构建器调用另一个构建器，它可能需要读取一个传入的目标字符串。你可以使用 <code>@angular-devkit/architect</code> 中的工具函数 <code>targetFromTargetString()</code> 把这个字符串解析成一个对象。</p><p translation-origin=\"off\">If your builder calls another builder, it may need to read a passed target string.\nYou can parse this string into an object by using the <code>targetFromTargetString()</code> utility function from <code>@angular-devkit/architect</code>.</p>\n\n<h2 id=\"schedule-and-run\" translation-result=\"on\">调度并运行<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#schedule-and-run\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"schedule-and-run\">Schedule and run<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#schedule-and-run\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">建筑师会异步运行构建器。要调用某个构建器，就要在所有配置解析完成之后安排一个要运行的任务。</p><p translation-origin=\"off\">Architect runs builders asynchronously.\nTo invoke a builder, you schedule a task to be run when all configuration resolution is complete.</p>\n\n<p translation-result=\"on\">在调度器返回 <code>BuilderRun</code> 控件对象之前，不会执行该构建器函数。CLI 通常会通过调用 <code>BuilderContext.scheduleTarget()</code> 函数来调度任务，然后使用 <code>angular.json</code> 文件中的目标定义来解析输入选项。</p><p translation-origin=\"off\">The builder function is not executed until the scheduler returns a <code>BuilderRun</code> control object.\nThe CLI typically schedules tasks by calling the <code>BuilderContext.scheduleTarget()</code> function, and then resolves input options using the target definition in the <code>angular.json</code> file.</p>\n\n<p translation-result=\"on\">建筑师会接受默认的选项对象来解析指定目标的输入选项，然后覆盖所用配置中的值（如果有的话），然后再从传给 <code>BuilderContext.scheduleTarget()</code> 的覆盖对象中覆盖这些值。对于 Angular CLI，覆盖对象是从命令行参数中构建的。</p><p translation-origin=\"off\">Architect resolves input options for a given target by taking the default options object, then overwriting values from the configuration used (if any), then further overwriting values from the overrides object passed to <code>BuilderContext.scheduleTarget()</code>.\nFor the Angular CLI, the overrides object is built from command line arguments.</p>\n\n<p translation-result=\"on\">建筑师会根据构建器的模式对生成的选项值进行验证。如果输入有效，建筑师会创建上下文并执行该构建器。</p><p translation-origin=\"off\">Architect validates the resulting options values against the schema of the builder.\nIf inputs are valid, Architect creates the context and executes the builder.</p>\n\n<p translation-result=\"on\">欲知详情，请参阅<a href=\"guide/workspace-config\">工作区配置</a>。</p><p translation-origin=\"off\">For more information see <a href=\"guide/workspace-config\">Workspace Configuration</a>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">   你还可以通过调用 <code>BuilderContext.scheduleBuilder()</code> 从另一个构建器或测试中调用某个构建器。你可以直接把 <code>options</code> 对象传给该方法，并且这些选项值会根据这个构建器的模式进行验证，而无需进一步调整。</p><p translation-origin=\"off\">   You can also invoke a builder directly from another builder or test by calling <code>BuilderContext.scheduleBuilder()</code>.\nYou pass an <code>options</code> object directly to the method, and those option values are validated against the schema of the builder without further adjustment.</p>\n\n<p translation-result=\"on\">   只有 <code>BuilderContext.scheduleTarget()</code> 方法来解析这些配置和并通过 <code>angular.json</code> 文件进行覆盖。</p><p translation-origin=\"off\">   Only the  <code>BuilderContext.scheduleTarget()</code> method resolves the configuration and overrides through the <code>angular.json</code> file.</p>\n\n</div>\n<h3 id=\"default-architect-configuration\" translation-result=\"on\">默认建筑师配置<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#default-architect-configuration\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"default-architect-configuration\">Default architect configuration<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#default-architect-configuration\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">让我们创建一个简单的 <code>angular.json</code> 文件，它会把目标配置放到上下文中。</p><p translation-origin=\"off\">Let’s create a simple <code>angular.json</code> file that puts target configurations into context.</p>\n\n<p translation-result=\"on\">我们可以把这个构建器发布到 npm（请参阅<a href=\"guide/creating-libraries#publishing-your-library\">发布你的库</a>），并使用如下命令来安装它：</p><p translation-origin=\"off\">We can publish the builder to npm (see <a href=\"guide/creating-libraries#publishing-your-library\">Publishing your Library</a>), and install it using the following command:</p>\n\n<code-example language=\"sh\">\n\nnpm install @example/command-runner\n\n</code-example>\n<p translation-result=\"on\">如果我们使用 <code>ng new builder-test</code> 创建一个新项目，那么生成的 <code>angular.json</code> 文件就是这样的，它只有默认的构建器参数。</p><p translation-origin=\"off\">If we create a new project with <code>ng new builder-test</code>, the generated <code>angular.json</code> file looks something like this, with only default builder configurations.</p>\n\n<code-example language=\"json\" header=\"angular.json\">\n\n{\n  // ...\n  \"projects\": {\n    // ...\n    \"builder-test\": {\n      // ...\n      \"architect\": {\n        // ...\n        \"build\": {\n          \"builder\": \"@angular-devkit/build-angular:browser\",\n          \"options\": {\n            // ... more options...\n            \"outputPath\": \"dist/builder-test\",\n            \"index\": \"src/index.html\",\n            \"main\": \"src/main.ts\",\n            \"polyfills\": \"src/polyfills.ts\",\n            \"tsConfig\": \"src/tsconfig.app.json\"\n          },\n          \"configurations\": {\n            \"production\": {\n              // ... more options...\n              \"optimization\": true,\n              \"aot\": true,\n              \"buildOptimizer\": true\n            }\n          }\n        }\n      }\n    }\n  }\n  // ...\n}\n\n</code-example>\n<h3 id=\"adding-a-target\" translation-result=\"on\">添加一个目标<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#adding-a-target\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"adding-a-target\">Adding a target<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#adding-a-target\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">让我们添加一个新的目标来运行我们的构建器执行一个特定的命令。这个目标会告诉构建器在文件上运行 <code>touch</code>，以便更新修改过的日期。</p><p translation-origin=\"off\">Let's add a new target that will run our builder to execute a particular command.\nThis target will tell the builder to run <code>touch</code> on a file, in order to update its modified date.</p>\n\n<p translation-result=\"on\">我们需要更新 <code>angular.json</code> 文件，把这个构建器的目标添加到新项目的 <code>architect</code> 部分。</p><p translation-origin=\"off\">We need to update the <code>angular.json</code> file to add a target for this builder to the \"architect\" section of our new project.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">我们会为项目的 <code>architect</code> 对象添加一个新的目标小节。</p><p translation-origin=\"off\">We'll add a new target section to the \"architect\" object for our project.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">名为 <code>touch</code> 的目标使用了我们的构建器，它发布到了 <code>@example/command-runner</code>。（参阅<a href=\"guide/creating-libraries#publishing-your-library\">发布你的库</a> ）</p><p translation-origin=\"off\">The target named \"touch\" uses our builder, which we published to <code>@example/command-runner</code>. (See <a href=\"guide/creating-libraries#publishing-your-library\">Publishing your Library</a>)</p>\n\n</li>\n<li>\n<p translation-result=\"on\">这个配置对象为我们定义的两个输入提供了默认值：<code>command</code>（要执行的 Unix 命令）和 <code>args</code> （包含要操作的文件的数组）。</p><p translation-origin=\"off\">The options object provides default values for the two inputs that we defined; <code>command</code>, which is the Unix command to execute, and <code>args</code>, an array that contains the file to operate on.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">这些配置键都是可选的，但我们先不展开。</p><p translation-origin=\"off\">The configurations key is optional, we'll leave it out for now.</p>\n\n</li>\n</ul>\n<code-example language=\"json\" header=\"angular.json\">\n\n{\n  \"projects\": {\n    \"builder-test\": {\n      \"architect\": {\n        \"touch\": {\n          \"builder\": \"@example/command-runner:command\",\n          \"options\": {\n            \"command\": \"touch\",\n            \"args\": [\n              \"src/main.ts\"\n            ]\n          }\n        },\n        \"build\": {\n          \"builder\": \"@angular-devkit/build-angular:browser\",\n          \"options\": {\n            \"outputPath\": \"dist/builder-test\",\n            \"index\": \"src/index.html\",\n            \"main\": \"src/main.ts\",\n            \"polyfills\": \"src/polyfills.ts\",\n            \"tsConfig\": \"src/tsconfig.app.json\"\n          },\n          \"configurations\": {\n            \"production\": {\n              \"fileReplacements\": [\n                {\n                  \"replace\": \"src/environments/environment.ts\",\n                  \"with\": \"src/environments/environment.prod.ts\"\n                }\n              ],\n              \"optimization\": true,\n              \"aot\": true,\n              \"buildOptimizer\": true\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n</code-example>\n<h3 id=\"running-the-builder\" translation-result=\"on\">运行这个构建器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#running-the-builder\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"running-the-builder\">Running the builder<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#running-the-builder\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要想使用这个新目标的默认配置运行我们的构建器，请在 Linux shell 中使用以下 CLI 命令。</p><p translation-origin=\"off\">To run our builder with the new target's default configuration, use the following CLI command in a Linux shell.</p>\n\n<code-example language=\"sh\">\n\n   ng run builder-test:touch\n\n</code-example>\n<p translation-result=\"on\">这将在 <code>src/main.ts</code> 文件上运行 <code>touch</code> 命令。</p><p translation-origin=\"off\">This will run the <code>touch</code> command on the <code>src/main.ts</code> file.</p>\n\n<p translation-result=\"on\">你可以使用命令行参数来覆盖已配置的默认值。例如，要改用其它 <code>command</code> 值运行，请使用以下 CLI 命令。</p><p translation-origin=\"off\">You can use command-line arguments to override the configured defaults.\nFor example, to run with a different <code>command</code> value, use the following CLI command.</p>\n\n<code-example language=\"sh\">\n\nng run builder-test:touch --command=ls\n\n</code-example>\n<p translation-result=\"on\">这将调用 <code>ls</code> 命令而不是 <code>touch</code> 命令。因为我们没有覆盖 <em>args</em> 选项，所以它会列出 <code>src/main.ts</code> 文件的信息（提供给该目标的默认值）。</p><p translation-origin=\"off\">This will call the <code>ls</code> command instead of the <code>touch</code> command.\nBecause we did not override the <em>args</em> option, it will list information about the <code>src/main.ts</code> file (the default value provided for the target).</p>\n\n<h2 id=\"testing-a-builder\" translation-result=\"on\">测试一个构建器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#testing-a-builder\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"testing-a-builder\">Testing a builder<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#testing-a-builder\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">对构建器进行集成测试，以便你可以使用建筑师的调度器来创建一个上下文，就像这个<a href=\"https://github.com/mgechev/cli-builders-demo\">例子</a>中一样。</p><p translation-origin=\"off\">Use integration testing for your builder, so that you can use the Architect scheduler to create a context, as in this <a href=\"https://github.com/mgechev/cli-builders-demo\">example</a>.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">在构建器的源码目录下，我们创建了一个新的测试文件 <code>index.spec.ts</code>。该代码创建了 <code>JsonSchemaRegistry</code>（用于模式验证）、<code>TestingArchitectHost</code>（对 <code>ArchitectHost</code> 的内存实现）和 <code>Architect</code> 的新实例。</p><p translation-origin=\"off\">In the builder source directory, we have created a new test file <code>my-builder.spec.ts</code>. The code creates new instances of <code>JsonSchemaRegistry</code> (for schema validation), <code>TestingArchitectHost</code> (an in-memory implementation of <code>ArchitectHost</code>), and <code>Architect</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">我们紧挨着这个构建器的 <a href=\"https://github.com/mgechev/cli-builders-demo/blob/master/command-builder/builders.json\"><code>package.json</code></a> 文件添加了一个 <code>builders.json</code> 文件，并修改了 <code>package.json</code> 文件以指向它。</p><p translation-origin=\"off\">We've added a <code>builders.json</code> file next to the builder's <a href=\"https://github.com/mgechev/cli-builders-demo/blob/master/command-builder/builders.json\"><code>package.json</code> file</a>, and modified the package file to point to it.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">下面是运行该命令构建器的测试范例。该测试使用该构建器来运行 <code>node --print 'foo'</code> 命令，然后验证 <code>logger</code> 中是否包含一条 <code>foo</code> 记录。</p><p translation-origin=\"off\">Here’s an example of a test that runs the command builder.\nThe test uses the builder to run the <code>node --print 'foo'</code> command, then validates that the <code>logger</code> contains an entry for <code>foo</code>.</p>\n\n<code-example path=\"cli-builder/src/my-builder.spec.ts\" header=\"src/my-builder.spec.ts\">\nimport { Architect } from '@angular-devkit/architect';\nimport { TestingArchitectHost } from '@angular-devkit/architect/testing';\nimport { logging, schema } from '@angular-devkit/core';\n\ndescribe('Command Runner Builder', () => {\n  let architect: Architect;\n  let architectHost: TestingArchitectHost;\n\n  beforeEach(async () => {\n    const registry = new schema.CoreSchemaRegistry();\n    registry.addPostTransform(schema.transforms.addUndefinedDefaults);\n\n    // TestingArchitectHost() takes workspace and current directories.\n    // Since we don't use those, both are the same in this case.\n    architectHost = new TestingArchitectHost(__dirname, __dirname);\n    architect = new Architect(architectHost, registry);\n\n    // This will either take a Node package name, or a path to the directory\n    // for the package.json file.\n    await architectHost.addBuilderFromPackage('..');\n  });\n\n  it('can run node', async () => {\n    // Create a logger that keeps an array of all messages that were logged.\n    const logger = new logging.Logger('');\n    const logs = [];\n    logger.subscribe(ev => logs.push(ev.message));\n\n    // A \"run\" can have <a href=\"api/forms/SelectMultipleControlValueAccessor\" class=\"code-anchor\">multiple</a> outputs, and contains progress information.\n    const run = await architect.scheduleBuilder('@example/command-runner:command', {\n      command: 'node',\n      args: ['--print', '\\'foo\\''],\n    }, { logger });  // We pass the logger for checking later.\n\n    // The \"result\" member (of type BuilderOutput) is the next output.\n    const output = await run.result;\n\n    // Stop the builder from running. This stops Architect from keeping\n    // the builder-associated states in memory, since builders keep waiting\n    // to be scheduled.\n    await run.stop();\n\n    // Expect that foo was logged\n    expect(logs).toContain('foo');\n  });\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">   在你的仓库中运行这个测试时，需要使用 <a href=\"https://github.com/TypeStrong/ts-node\"><code>ts-node</code></a> 包。你可以把 <code>index.spec.ts</code> 重命名为 <code>index.spec.js</code> 来回避它。</p><p translation-origin=\"off\">   When running this test in your repo, you need the <a href=\"https://github.com/TypeStrong/ts-node\"><code>ts-node</code></a> package. You can avoid this by renaming <code>my-builder.spec.ts</code> to <code>my-builder.spec.js</code>.</p>\n\n</div>\n<h3 id=\"watch-mode\" translation-result=\"on\">监视（watch）模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#watch-mode\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"watch-mode\">Watch mode<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#watch-mode\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">建筑师希望构建器运行一次（默认情况下）并返回。这种行为与那些需要监视文件更改的构建器（例如 Webpack）并不完全兼容。建筑师可以支持监视模式，但要注意一些问题。</p><p translation-origin=\"off\">Architect expects builders to run once (by default) and return.\nThis behavior is not entirely compatible with a builder that watches for changes (like Webpack, for example).\nArchitect can support watch mode, but there are some things to look out for.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">要在监视模式下使用，构建器处理函数应返回一个 Observable。建筑师会订阅这个 Observable，直到这个 Observable 完成（complete）为止。此外，如果使用相同的参数再次调度这个构建器，建筑师还能复用这个 Observable。</p><p translation-origin=\"off\">To be used with watch mode, a builder handler function should return an Observable. Architect subscribes to the Observable until it completes and might reuse it if the builder is scheduled again with the same arguments.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">这个构建器应该总是在每次执行后发出一个 <code>BuilderOutput</code> 对象。一旦它被执行，就会进入一个由外部事件触发的监视模式。如果一个事件导致它重启，那么此构建器应该执行 <code>BuilderContext.reportRunning()</code> 函数来告诉建筑师再次运行它。如果调度器还计划了另一次运行，就会阻止建筑师停掉这个构建器。</p><p translation-origin=\"off\">The builder should always emit a <code>BuilderOutput</code> object after each execution. Once it’s been executed, it can enter a watch mode, to be triggered by an external event. If an event triggers it to restart, the builder should execute the <code>BuilderContext.reportRunning()</code> function to tell Architect that it is running again. This prevents Architect from stopping the builder if another run is scheduled.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">当你的构建器通过调用 <code>BuilderRun.stop()</code> 来退出监视模式时，建筑师会从构建器的 Observable 中取消订阅，并调用构建器的退出逻辑进行清理。（这种行为也允许停止和清理运行时间过长的构建。）</p><p translation-origin=\"off\">When your builder calls <code>BuilderRun.stop()</code> to exit watch mode, Architect unsubscribes from the builder’s Observable and calls the builder’s teardown logic to clean up.\n(This behavior also allows for long running builds to be stopped and cleaned up.)</p>\n\n<p translation-result=\"on\">一般来说，如果你的构建器正在监视一个外部事件，你应该把你的运行分成三个阶段。</p><p translation-origin=\"off\">In general, if your builder is watching an external event, you should separate your run into three phases.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\"><strong>运行</strong>，例如 webpack 编译。这会在 webpack 完成并且你的构建器发出 <code>BuilderOutput</code> 对象时结束。</p><p translation-origin=\"off\"><strong>Running</strong>\nFor example, webpack compiles. This ends when webpack finishes and your builder emits a <code>BuilderOutput</code> object.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>监视</strong>，在两次运行之间监视外部事件流。例如，webpack 会监视文件系统是否发生了任何变化。这会在 webpack 重启构建时结束，并调用 <code>BuilderContext.reportRunning()</code>。这样就会再回到第 1 步。</p><p translation-origin=\"off\"><strong>Watching</strong>\nBetween two runs, watch an external event stream. For example, webpack watches the file system for any changes. This ends when webpack restarts building, and <code>BuilderContext.reportRunning()</code> is called. This goes back to step 1.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>完成</strong>，任务完全完成（例如，webpack 应运行多次），或者构建器停止运行（使用 <code>BuilderRun.stop()</code>）。你的退出逻辑被调用了，建筑师也从你的构建器的 Observable 中取消了订阅。</p><p translation-origin=\"off\"><strong>Completion</strong>\nEither the task is fully completed (for example, webpack was supposed to run a number of times), or the builder run was stopped (using <code>BuilderRun.stop()</code>). Your teardown logic is executed, and Architect unsubscribes from your builder’s Observable.</p>\n\n</li>\n</ol>\n<h2 id=\"summary\" translation-result=\"on\">总结<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#summary\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"summary\">Summary<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#summary\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">CLI 构建器 API 提供了一种通过构建器执行自定义逻辑，以改变 Angular CLI 行为的新方式。</p><p translation-origin=\"off\">The CLI Builder API provides a new way of changing the behavior of the Angular CLI by using builders to execute custom logic.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">构建器既可以是同步的，也可以是异步的，它可以只执行一次也可以监视外部事件，还可以调度其它构建器或目标。</p><p translation-origin=\"off\">Builders can be synchronous or asynchronous, execute once or watch for external events, and can schedule other builders or targets.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">构建器在 <code>angular.json</code> 配置文件中指定了选项的默认值，它可以被目标的备用配置覆盖，还可以进一步被命令行标志所覆盖。</p><p translation-origin=\"off\">Builders have option defaults specified in the <code>angular.json</code> configuration file, which can be overwritten by an alternate configuration for the target, and further overwritten by command line flags.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">我们建议你使用集成测试来测试建筑师的构建器。你还可以使用单元测试来验证这个构建器的执行逻辑。</p><p translation-origin=\"off\">We recommend that you use integration tests to test Architect builders. You can use unit tests to validate the logic that the builder executes.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果你的构建器返回一个 Observable，你应该在那个 Observable 的退出逻辑中进行清理。</p><p translation-origin=\"off\">If your builder returns an Observable, it should clean up in the teardown logic of that Observable.</p>\n\n</li>\n</ul>\n\n  \n</div>\n\n\n<!-- links to this doc:\n - cli/deploy\n - guide/architecture-next-steps\n - guide/deployment\n - guide/workspace-config\n-->\n<!-- links from this doc:\n - api/animations/browser\n - api/forms/SelectMultipleControlValueAccessor\n - cli/run\n - guide/cli-builder#adding-a-target\n - guide/cli-builder#angular-cli-builders\n - guide/cli-builder#builder-input\n - guide/cli-builder#builder-project-structure\n - guide/cli-builder#cli-builders\n - guide/cli-builder#creating-a-builder\n - guide/cli-builder#default-architect-configuration\n - guide/cli-builder#handling-output\n - guide/cli-builder#input-validation\n - guide/cli-builder#progress-and-status-reporting\n - guide/cli-builder#running-the-builder\n - guide/cli-builder#schedule-and-run\n - guide/cli-builder#summary\n - guide/cli-builder#target-configuration\n - guide/cli-builder#target-strings\n - guide/cli-builder#testing-a-builder\n - guide/cli-builder#watch-mode\n - guide/creating-libraries#publishing-your-library\n - guide/glossary#builder\n - guide/glossary#project\n - guide/glossary#schematic\n - guide/glossary#target\n - guide/workspace-config\n - http://json-schema.org/\n - https://docs.npmjs.com/files/package.json\n - https://electronjs.org/\n - https://github.com/TypeStrong/ts-node\n - https://github.com/angular/angular-cli/blob/ba21c855c0c8b778005df01d4851b5a2176edc6f/packages/angular_devkit/build_angular/src/tslint/index.ts#L107\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/cli-builder.md?message=docs%3A%20请简述你的修改...\n - https://github.com/mgechev/cli-builders-demo\n - https://github.com/mgechev/cli-builders-demo/blob/master/command-builder/builders.json\n - https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\n-->"
}