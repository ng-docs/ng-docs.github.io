{
  "id": "guide/cli-builder",
  "title": "Angular CLI builders",
  "contents": "\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/cli-builder.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"angular-cli-builders\" translation-result=\"on\">Angular CLI 构建器（Builder）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#angular-cli-builders\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"angular-cli-builders\">Angular CLI builders<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#angular-cli-builders\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">很多 Angular CLI 命令都要在你的代码上执行一些复杂的处理，比如风格检查（lint）构建或测试。这些命令会通过一个叫做建筑师（Architect）的内部工具来运行 <em>CLI 构建器</em>，而这些构建器会运用一些第三方工具来完成目标任务。</p><p translation-origin=\"off\">A number of Angular CLI commands run a complex process on your code, such as linting, building, or testing.\nThe commands use an internal tool called Architect to run <em>CLI builders</em>, which apply another tool to accomplish the wanted task.</p>\n\n<p translation-result=\"on\">在 Angular 的版本 8 中，CLI 构建器的 API 是稳定的，想要通过添加或修改命令来自定义 Angular CLI 的开发人员可以使用它。比如，你可以提供一个构建器来执行全新的任务，或者更改一个现有命令所使用的第三方工具。</p><p translation-origin=\"off\">With Angular version 8, the CLI Builder API is stable and available to developers who want to customize the Angular CLI by adding or modifying commands.\nFor example, you could supply a builder to perform an entirely new task, or to change which third-party tool is used by an existing command.</p>\n\n<p translation-result=\"on\">本文档介绍了 CLI 构建器是如何与工作区配置文件集成的，还展示了如何创建你自己的构建器。</p><p translation-origin=\"off\">This document explains how CLI builders integrate with the workspace configuration file, and shows how you can create your own builder.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">可以在这个 <a href=\"https://github.com/mgechev/cli-builders-demo\">GitHub 仓库</a>中的例子中找到代码。</p><p translation-origin=\"off\">Find the code from the examples used here in this <a href=\"https://github.com/mgechev/cli-builders-demo\">GitHub repository</a>.</p>\n\n</div>\n<h2 id=\"cli-builders\" translation-result=\"on\">CLI 构建器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#cli-builders\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"cli-builders\">CLI builders<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#cli-builders\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">内部建筑师工具会把工作委托给名叫<a href=\"guide/glossary#builder\"><em>构建器</em></a>的处理器函数。处理器函数接收两个参数：一组 <code>options</code> 输入（JSON 对象）和一个 <code>context</code>（<code>BuilderContext</code> 对象）。</p><p translation-origin=\"off\">The internal Architect tool delegates work to handler functions called <a href=\"guide/glossary#builder\"><em>builders</em></a>.\nA builder handler function receives two arguments; a set of input <code>options</code> (a JSON object), and a <code>context</code> (a <code>BuilderContext</code> object).</p>\n\n<p translation-result=\"on\">这里对关注点的分离和<a href=\"guide/glossary#schematic\">原理图</a>中是一样的，它也适用于其它要接触（touch）代码的 CLI 命令（比如 <code>ng generate</code>）。</p><p translation-origin=\"off\">The separation of concerns here is the same as with <a href=\"guide/glossary#schematic\">schematics</a>, which are used for other CLI commands that touch your code (such as <code>ng generate</code>).</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">此 <code>options</code> 对象是由本 CLI 的用户提供的，而 <code>context</code> 对象则由 CLI 构建器的 API 提供</p><p translation-origin=\"off\">The <code>options</code> object is provided by the CLI user, while the <code>context</code> object is provided by the CLI Builder API</p>\n\n</li>\n<li>\n<p translation-result=\"on\">除了上下文信息之外，此 <code>context</code> 对象（它是 <code>BuilderContext</code> 的实例）还允许你访问调度方法 <code>context.scheduleTarget()</code>。调度器会用指定的<a href=\"guide/glossary#target\">目标配置</a>来执行构建器处理函数。</p><p translation-origin=\"off\">In addition to the contextual information, the <code>context</code> object, which is an instance of the <code>BuilderContext</code>, also provides access to a scheduling method, <code>context.scheduleTarget()</code>.\nThe scheduler executes the builder handler function with a given <a href=\"guide/glossary#target\">target configuration</a>.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">这个构建器处理函数可以是同步的（返回一个值）或异步的（返回一个 Promise），也可以监视并返回多个值（返回一个 Observable）。最终返回的值全都是 <code>BuilderOutput</code> 类型的。该对象包含一个逻辑字段 <code>success</code> 和一个可以包含错误信息的可选字段 <code>error</code>。</p><p translation-origin=\"off\">The builder handler function can be synchronous (return a value) or asynchronous (return a Promise), or it can watch and return multiple values (return an Observable).\nThe return value or values must always be of type <code>BuilderOutput</code>.\nThis object contains a Boolean <code>success</code> field and an optional <code>error</code> field that can contain an error message.</p>\n\n<p translation-result=\"on\">Angular 提供了一些构建器，供 CLI 命令使用，如 <code>ng build</code> 和 <code>ng test</code> 等。这些内置 CLI 构建器的默认目标配置可以在<a href=\"guide/workspace-config\">工作区配置文件</a> <code>angular.json</code> 的 <code>architect</code> 部分找到（并进行自定义）。可以通过创建自己的构建器来扩展和自定义 Angular，你可以使用 <a href=\"cli/run\"><code>ng run</code> CLI 命令</a>来运行你自己的构建器。</p><p translation-origin=\"off\">Angular provides some builders that are used by the CLI for commands such as <code>ng build</code> and <code>ng test</code>.\nDefault target configurations for these and other built-in CLI builders can be found (and customized) in the \"architect\" section of the <a href=\"guide/workspace-config\">workspace configuration file</a>, <code>angular.json</code>.\nAlso, extend and customize Angular by creating your own builders, which you can run using the <a href=\"cli/run\"><code>ng run</code> CLI command</a>.</p>\n\n<h3 id=\"builder-project-structure\" translation-result=\"on\">构建器的项目结构<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#builder-project-structure\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"builder-project-structure\">Builder project structure<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#builder-project-structure\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">构建器位于一个 <code>project</code> 文件夹中，该文件夹的结构类似于 Angular 工作区，包括位于顶层的全局配置文件，以及位于工作代码所在源文件夹中的更具体的配置。比如，<code>myBuilder</code> 文件夹中可能包含如下文件。</p><p translation-origin=\"off\">A builder resides in a \"project\" folder that is similar in structure to an Angular workspace, with global configuration files at the top level, and more specific configuration in a source folder with the code files that define the behavior.\nFor example, your <code>myBuilder</code> folder could contain the following files.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><p translation-result=\"on\">文件</p><p translation-origin=\"off\">Files</p></th>\n<th align=\"left\"><p translation-result=\"on\">用途</p><p translation-origin=\"off\">Purpose</p></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>src/my-builder.ts</code></td>\n<td align=\"left\"><p translation-result=\"on\">这个构建器定义的主要源码。</p><p translation-origin=\"off\">Main source file for the builder definition.</p></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>src/my-builder.spec.ts</code></td>\n<td align=\"left\"><p translation-result=\"on\">测试的源码。</p><p translation-origin=\"off\">Source file for tests.</p></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>src/schema.json</code></td>\n<td align=\"left\"><p translation-result=\"on\">构建器输入选项的定义。</p><p translation-origin=\"off\">Definition of builder input options.</p></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>builders.json</code></td>\n<td align=\"left\"><p translation-result=\"on\">测试配置。</p><p translation-origin=\"off\">Builders definition.</p></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>package.json</code></td>\n<td align=\"left\"><p translation-result=\"on\">依赖包。参阅 <a href=\"https://docs.npmjs.com/files/package.json\">https://docs.npmjs.com/files/package.json</a>。</p><p translation-origin=\"off\">Dependencies. See <a href=\"https://docs.npmjs.com/files/package.json\">https://docs.npmjs.com/files/package.json</a>.</p></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>tsconfig.json</code></td>\n<td align=\"left\"><p translation-result=\"on\"><a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\">TypeScript 配置文件</a>。</p><p translation-origin=\"off\"><a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\">TypeScript configuration</a>.</p></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">将此构建器发布到 <code>npm</code>（参阅<a href=\"guide/creating-libraries#publishing-your-library\">发布你的库</a>）。如果你将其发布为 <code>&#x26;commat;example/my-builder</code>，请使用以下命令安装它。</p><p translation-origin=\"off\">Publish the builder to <code>npm</code> (see <a href=\"guide/creating-libraries#publishing-your-library\">Publishing your Library</a>).\nIf you publish it as <code>&#x26;commat;example/my-builder</code>, install it using the following command.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install @example/my-builder\n\n</code-example>\n<h2 id=\"creating-a-builder\" translation-result=\"on\">创建构建器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#creating-a-builder\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"creating-a-builder\">Creating a builder<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#creating-a-builder\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">举个例子，让我们创建一个用来复制文件的构建器。要创建构建器，请使用 CLI 构建器函数 <code>createBuilder()</code>，并返回一个 <code>Promise&#x3C;BuilderOutput></code> 对象。</p><p translation-origin=\"off\">As an example, create a builder that copies a file.\nTo create a builder, use the <code>createBuilder()</code> CLI Builder function, and return a <code>Promise&#x3C;BuilderOutput></code> object.</p>\n\n<code-example header=\"src/my-builder.ts (builder skeleton)\" path=\"cli-builder/src/my-builder.ts\" region=\"builder-skeleton\">\nimport { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';\nimport { JsonObject } from '@angular-devkit/core';\n\ninterface Options extends JsonObject {\n  source: string;\n  destination: string;\n}\n\nexport default createBuilder(copyFileBuilder);\n\nasync function copyFileBuilder(\n  options: Options,\n  context: BuilderContext,\n): Promise&#x3C;BuilderOutput> {\n}\n\n\n</code-example>\n<p translation-result=\"on\">现在，让我们为它添加一些逻辑。下列代码会从用户选项中获取源文件和目标文件的路径，并且把源文件复制到目标文件（使用 <a href=\"https://nodejs.org/api/fs.html#fs_fspromises_copyfile_src_dest_mode\">NodeJS 内置函数 <code>copyFile()</code> 的 Promise 版本</a>）。如果文件操作失败了，它会返回一个带有底层错误信息的 error 对象。</p><p translation-origin=\"off\">Now let's add some logic to it.\nThe following code retrieves the source and destination file paths from user options and copies the file from the source to the destination (using the <a href=\"https://nodejs.org/api/fs.html#fs_fspromises_copyfile_src_dest_mode\">Promise version of the built-in NodeJS <code>copyFile()</code> function</a>).\nIf the copy operation fails, it returns an error with a message about the underlying problem.</p>\n\n<code-example header=\"src/my-builder.ts (builder)\" path=\"cli-builder/src/my-builder.ts\" region=\"builder\">\nimport { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';\nimport { JsonObject } from '@angular-devkit/core';\nimport { promises as fs } from 'fs';\n\ninterface Options extends JsonObject {\n  source: string;\n  destination: string;\n}\n\nexport default createBuilder(copyFileBuilder);\n\nasync function copyFileBuilder(\n  options: Options,\n  context: BuilderContext,\n): Promise&#x3C;BuilderOutput> {\n  try {\n    await fs.copyFile(options.source, options.destination);\n  } catch (err) {\n    return {\n      success: false,\n      error: err.message,\n    };\n  }\n\n  return { success: true };\n}\n\n\n</code-example>\n<h3 id=\"handling-output\" translation-result=\"on\">处理输出<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#handling-output\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"handling-output\">Handling output<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#handling-output\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">默认情况下，<code>copyFile()</code> 方法不会往标准输出或标准错误中打印任何信息。如果发生了错误，可能很难理解构建器到底做了什么。可以使用 <code>Logger</code> API 来记录一些额外的信息，以提供额外的上下文。这样还能让构建器本身可以在一个单独的进程中执行，即使其标准输出和标准错误被停用了也无所谓（就像在 <a href=\"https://electronjs.org/\">Electron 应用中一样</a>）。</p><p translation-origin=\"off\">By default, <code>copyFile()</code> does not print anything to the process standard output or error.\nIf an error occurs, it might be difficult to understand exactly what the builder was trying to do when the problem occurred.\nAdd some additional context by logging additional information using the <code>Logger</code> API.\nThis also lets the builder itself be executed in a separate process, even if the standard output and error are deactivated (as in an <a href=\"https://electronjs.org\">Electron app</a>).</p>\n\n<p translation-result=\"on\">你可以从上下文中检索一个 <code>Logger</code> 实例。</p><p translation-origin=\"off\">You can retrieve a <code>Logger</code> instance from the context.</p>\n\n<code-example header=\"src/my-builder.ts (handling output)\" path=\"cli-builder/src/my-builder.ts\" region=\"handling-output\">\nimport { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';\nimport { JsonObject } from '@angular-devkit/core';\nimport { promises as fs } from 'fs';\n\ninterface Options extends JsonObject {\n  source: string;\n  destination: string;\n}\n\nexport default createBuilder(copyFileBuilder);\n\nasync function copyFileBuilder(\n  options: Options,\n  context: BuilderContext,\n): Promise&#x3C;BuilderOutput> {\n  try {\n    await fs.copyFile(options.source, options.destination);\n  } catch (err) {\n    context.logger.error('Failed to copy file.');\n    return {\n      success: false,\n      error: err.message,\n    };\n  }\n\n  return { success: true };\n}\n\n\n</code-example>\n<h3 id=\"progress-and-status-reporting\" translation-result=\"on\">进度和状态报告<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#progress-and-status-reporting\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"progress-and-status-reporting\">Progress and status reporting<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#progress-and-status-reporting\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">CLI 构建器 API 包含一些进度报告和状态报告工具，可以为某些函数和接口提供提示信息。</p><p translation-origin=\"off\">The CLI Builder API includes progress and status reporting tools, which can provide hints for certain functions and interfaces.</p>\n\n<p translation-result=\"on\">要报告进度，请使用 <code>context.reportProgress()</code> 方法，它接受一个当前值（value）、一个（可选的）总值（total）和状态（status）字符串作为参数。总值可以是任意数字，比如，如果你知道有多少个文件需要处理，那么总值可能是这些文件的数量，而当前值是已处理过的数量。除非传入了新的字符串，否则这个状态字符串不会改变。</p><p translation-origin=\"off\">To report progress, use the <code>context.reportProgress()</code> method, which takes a current value, (optional) total, and status string as arguments.\nThe total can be any number; for example, if you know how many files you have to process, the total could be the number of files, and current should be the number processed so far.\nThe status string is unmodified unless you pass in a new string value.</p>\n\n<p translation-result=\"on\">你可以看看 <code>tslint</code> 构建器如何报告进度的<a href=\"https://github.com/angular/angular-cli/blob/ba21c855c0c8b778005df01d4851b5a2176edc6f/packages/angular_devkit/build_angular/src/tslint/index.ts#L107\">例子</a>。</p><p translation-origin=\"off\">You can see an <a href=\"https://github.com/angular/angular-cli/blob/ba21c855c0c8b778005df01d4851b5a2176edc6f/packages/angular_devkit/build_angular/src/tslint/index.ts#L107\">example</a> of how the <code>tslint</code> builder reports progress.</p>\n\n<p translation-result=\"on\">在我们的例子中，这种复制操作或者已完成或者正在执行，所以不需要进度报告，但是可以报告状态，以便调用此构建器的父构建器知道发生了什么。可以用 <code>context.reportStatus()</code> 方法生成一个任意长度的状态字符串。</p><p translation-origin=\"off\">In our example, the copy operation either finishes or is still executing, so there's no need for a progress report, but you can report status so that a parent builder that called our builder would know what's going on.\nUse the <code>context.reportStatus()</code> method to generate a status string of any length.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n无法保证长字符串会完全显示出来，可以裁剪它以适应界面显示。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nThere's no guarantee that a long string will be shown entirely; it could be cut to fit the UI that displays it.</p>\n\n</div>\n<p translation-result=\"on\">传入一个空字符串可以移除状态。</p><p translation-origin=\"off\">Pass an empty string to remove the status.</p>\n\n<code-example header=\"src/my-builder.ts (progress reporting)\" path=\"cli-builder/src/my-builder.ts\" region=\"progress-reporting\">\nimport { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';\nimport { JsonObject } from '@angular-devkit/core';\nimport { promises as fs } from 'fs';\n\ninterface Options extends JsonObject {\n  source: string;\n  destination: string;\n}\n\nexport default createBuilder(copyFileBuilder);\n\nasync function copyFileBuilder(\n  options: Options,\n  context: BuilderContext,\n): Promise&#x3C;BuilderOutput> {\n  context.reportStatus(`Copying ${options.source} to ${options.destination}.`);\n  try {\n    await fs.copyFile(options.source, options.destination);\n  } catch (err) {\n    context.logger.error('Failed to copy file.');\n    return {\n      success: false,\n      error: err.message,\n    };\n  }\n\n  context.reportStatus('Done.');\n  return { success: true };\n}\n\n\n</code-example>\n<h2 id=\"builder-input\" translation-result=\"on\">构建器的输入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#builder-input\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"builder-input\">Builder input<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#builder-input\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你可以通过 CLI 命令间接调用一个构建器，也可以直接用 Angular CLI 的 <code>ng run</code> 命令来调用它。无论哪种情况，你都必须提供所需的输入，但是可以用特定<a href=\"guide/glossary#target\"><em>目标</em></a>中预配置的值作为其默认值，然后指定一个预定义的、指定的配置进行覆盖，最后在命令行中进一步覆盖这些选项的值。</p><p translation-origin=\"off\">You can invoke a builder indirectly through a CLI command, or directly with the Angular CLI <code>ng run</code> command.\nIn either case, you must provide required inputs, but can let other inputs default to values that are pre-configured for a specific <a href=\"guide/glossary#target\"><em>target</em></a>, provide a pre-defined, named override configuration, and provide further override option values on the command line.</p>\n\n<h3 id=\"input-validation\" translation-result=\"on\">对输入的验证<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#input-validation\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"input-validation\">Input validation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#input-validation\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你可以在该构建器的相关 JSON 模式中定义构建器都有哪些输入。建筑师工具会把解析后的输入值收集到一个 <code>options</code> 对象中，并在将其传给构建器函数之前先根据这个模式验证它们的类型。（Schematics 库也对用户输入做了同样的验证）。</p><p translation-origin=\"off\">You define builder inputs in a JSON schema associated with that builder.\nThe Architect tool collects the resolved input values into an <code>options</code> object, and validates their types against the schema before passing them to the builder function.\n(The Schematics library does the same kind of validation of user input.)</p>\n\n<p translation-result=\"on\">对于这个范例构建器，你希望 <code>options</code> 的值是带有两个键的 <code>JsonObject</code>：一个是 <code>source</code>，一个是 <code>destination</code>，它们都是字符串。</p><p translation-origin=\"off\">For our example builder, you expect the <code>options</code> value to be a <code>JsonObject</code> with two keys:\nA <code>source</code> and a <code>destination</code>, each of which are a string.</p>\n\n<p translation-result=\"on\">你可以提供如下模式来对这些值的类型进行验证。</p><p translation-origin=\"off\">You can provide the following schema for type validation of these values.</p>\n\n<code-example header=\"src/schema.json\" format=\"json\" language=\"json\">\n\n{\n  \"$schema\": \"http://json-schema.org/schema\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"source\": {\n      \"type\": \"string\"\n    },\n    \"destination\": {\n      \"type\": \"string\"\n    }\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">这是一个非常简单的例子，但这种模式验证也可以非常强大。欲知详情，参阅 <a href=\"http://json-schema.org\">JSON 模式网站</a>。</p><p translation-origin=\"off\">This is a very simple example, but the use of a schema for validation can be very powerful.\nFor more information, see the <a href=\"http://json-schema.org\">JSON schemas website</a>.</p>\n\n</div>\n<p translation-result=\"on\">要把构建器的实现与它的模式和名称关联起来，你需要创建一个<em>构建器定义</em>文件，可以在 <code>package.json</code> 中指向该文件。</p><p translation-origin=\"off\">To link our builder implementation with its schema and name, you need to create a <em>builder definition</em> file, which you can point to in <code>package.json</code>.</p>\n\n<p translation-result=\"on\">创建一个名为 <code>builders.json</code> 文件，它看起来像这样。</p><p translation-origin=\"off\">Create a file named <code>builders.json</code> that looks like this:</p>\n\n<code-example header=\"builders.json\" format=\"json\" language=\"json\">\n\n{\n  \"builders\": {\n    \"copy\": {\n      \"implementation\": \"./dist/my-builder.js\",\n      \"schema\": \"./src/schema.json\",\n      \"description\": \"Copies a file.\"\n    }\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">在 <code>package.json</code> 文件中，添加一个 <code>builders</code> 键，告诉建筑师工具可以在哪里找到这个构建器定义文件。</p><p translation-origin=\"off\">In the <code>package.json</code> file, add a <code>builders</code> key that tells the Architect tool where to find our builder definition file.</p>\n\n<code-example header=\"package.json\" format=\"json\" language=\"json\">\n\n{\n  \"name\": \"@example/copy-file\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Builder for copying files\",\n  \"builders\": \"builders.json\",\n  \"dependencies\": {\n    \"@angular-devkit/architect\": \"~0.1200.0\",\n    \"@angular-devkit/core\": \"^12.0.0\"\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">现在，这个构建器的正式名字是 <code>@example/copy-file:copy</code>。第一部分是包名（使用 node 方案进行解析），第二部分是构建器名称（使用 <code>builders.json</code> 文件进行解析）。</p><p translation-origin=\"off\">The official name of our builder is now <code>@example/copy-file:copy</code>.\nThe first part of this is the package name (resolved using node resolution), and the second part is the builder name (resolved using the <code>builders.json</code> file).</p>\n\n<p translation-result=\"on\">使用某个 <code>options</code> 是非常简单的。在上一节，你就曾用过 <code>options.source</code> 和 <code>options.destination</code>。</p><p translation-origin=\"off\">Using one of our <code>options</code> is very straightforward.\nYou did this in the previous section when you accessed <code>options.source</code> and <code>options.destination</code>.</p>\n\n<code-example header=\"src/my-builder.ts (report status)\" path=\"cli-builder/src/my-builder.ts\" region=\"report-status\">\ncontext.reportStatus(`Copying ${options.source} to ${options.destination}.`);\ntry {\n  await fs.copyFile(options.source, options.destination);\n} catch (err) {\n  context.logger.error('Failed to copy file.');\n  return {\n    success: false,\n    error: err.message,\n  };\n}\n\ncontext.reportStatus('Done.');\nreturn { success: true };\n\n</code-example>\n<h3 id=\"target-configuration\" translation-result=\"on\">目标配置<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#target-configuration\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"target-configuration\">Target configuration<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#target-configuration\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">构建器必须有一个已定义的目标，此目标会把构建器与特定的输入配置和<a href=\"guide/glossary#project\">项目</a>关联起来。</p><p translation-origin=\"off\">A builder must have a defined target that associates it with a specific input configuration and <a href=\"guide/glossary#project\">project</a>.</p>\n\n<p translation-result=\"on\">目标是在 <a href=\"guide/workspace-config\">CLI 配置文件</a> <code>angular.json</code> 中定义的。目标用于指定要使用的构建器、默认的选项配置，以及指定的备用配置。建筑师工具使用目标定义来为一次特定的执行解析输入选项。</p><p translation-origin=\"off\">Targets are defined in the <code>angular.json</code> <a href=\"guide/workspace-config\">CLI configuration file</a>.\nA target specifies the builder to use, its default options configuration, and named alternative configurations.\nThe Architect tool uses the target definition to resolve input options for a given run.</p>\n\n<p translation-result=\"on\"><code>angular.json</code> 文件中为每个项目都有一节配置，每个项目的 <code>architect</code> 部分都会为 CLI 命令（比如 <code>build</code>、<code>test</code> 和 <code>lint</code>）配置构建器目标。默认情况下，<code>build</code> 命令会运行 <code>@angular-devkit/build-angular:<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a></code> 构建器来执行 <code>build</code> 任务，并传入 <code>angular.json</code> 中为 <code>build</code> 目标指定的默认选项值。</p><p translation-origin=\"off\">The <code>angular.json</code> file has a section for each project, and the \"architect\" section of each project configures targets for builders used by CLI commands such as 'build', 'test', and 'lint'.\nBy default, for example, the <code>build</code> command runs the builder <code>@angular-devkit/build-angular:<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a></code> to perform the build task, and passes in default option values as specified for the <code>build</code> target in <code>angular.json</code>.</p>\n\n<code-example format=\"json\" header=\"angular.json\" language=\"json\">\n{\n  \"myApp\": {\n    …\n    \"architect\": {\n      \"build\": {\n        \"builder\": \"@angular-devkit/build-angular:browser\",\n        \"options\": {\n          \"outputPath\": \"dist/myApp\",\n          \"index\": \"src/index.html\",\n          …\n        },\n        \"configurations\": {\n          \"production\": {\n            \"fileReplacements\": [\n              {\n                \"replace\": \"src/environments/environment.ts\",\n                \"with\": \"src/environments/environment.prod.ts\"\n              }\n            ],\n            \"optimization\": true,\n            \"outputHashing\": \"all\",\n            …\n          }\n        }\n      },\n      …\n\n</code-example>\n<p translation-result=\"on\">该命令会给构建器传递 <code>options</code> 节中指定的一组默认选项。如果你传入了 <code>--configuration=production</code> 标志，它就会使用 <code>production</code> 备用配置中指定的值进行覆盖。可以在命令行中单独指定其它选项进行覆盖，还可以为 <code>build</code> 目标添加更多备用配置，以定义其它环境，比如 <code>stage</code> 或 <code>qa</code>。</p><p translation-origin=\"off\">The command passes the builder the set of default options specified in the \"options\" section.\nIf you pass the <code>--configuration=production</code> flag, it uses the override values specified in the <code>production</code> alternative configuration.\nSpecify further option overrides individually on the command line.\nYou might also add more alternative configurations to the <code>build</code> target, to define other environments such as <code>stage</code> or <code>qa</code>.</p>\n\n<h4 id=\"target-strings\" translation-result=\"on\">目标字符串<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#target-strings\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"target-strings\">Target strings<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#target-strings\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">通用的 <code>ng run</code> CLI 命令将以下格式的目标字符串作为其第一个参数。</p><p translation-origin=\"off\">The generic <code>ng run</code> CLI command takes as its first argument a target string of the following form.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nproject:target[:configuration]\n\n</code-example>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\"><p translation-result=\"on\">详情</p><p translation-origin=\"off\">Details</p></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><p translation-result=\"on\">项目（project）</p><p translation-origin=\"off\">project</p></td>\n<td align=\"left\"><p translation-result=\"on\">与此目标关联的 Angular CLI 项目的名称。</p><p translation-origin=\"off\">The name of the Angular CLI project that the target is associated with.</p></td>\n</tr>\n\n<tr>\n<td align=\"left\"><p translation-result=\"on\">目标</p><p translation-origin=\"off\">target</p></td>\n<td align=\"left\"><p translation-result=\"on\"><code>angular.json</code> 文件 <code>architect</code> 下的指定构建器配置。</p><p translation-origin=\"off\">A named builder configuration from the <code>architect</code> section of the <code>angular.json</code> file.</p></td>\n</tr>\n\n<tr>\n<td align=\"left\"><p translation-result=\"on\">配置（configuration）</p><p translation-origin=\"off\">configuration</p></td>\n<td align=\"left\"><p translation-result=\"on\">（可选）用于覆盖指定目标的具体配置名称，如 <code>angular.json</code> 文件中的定义。</p><p translation-origin=\"off\">(optional) The name of a specific configuration override for the given target, as defined in the <code>angular.json</code> file.</p></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">如果你的构建器调用另一个构建器，它可能需要读取一个传入的目标字符串。可以使用 <code>@angular-devkit/architect</code> 中的工具函数 <code>targetFromTargetString()</code> 把这个字符串解析成一个对象。</p><p translation-origin=\"off\">If your builder calls another builder, it might need to read a passed target string.\nParse this string into an object by using the <code>targetFromTargetString()</code> utility function from <code>@angular-devkit/architect</code>.</p>\n\n<h2 id=\"schedule-and-run\" translation-result=\"on\">调度并运行<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#schedule-and-run\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"schedule-and-run\">Schedule and run<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#schedule-and-run\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">建筑师会异步运行构建器。要调用某个构建器，就要在所有配置解析完成之后安排一个要运行的任务。</p><p translation-origin=\"off\">Architect runs builders asynchronously.\nTo invoke a builder, you schedule a task to be run when all configuration resolution is complete.</p>\n\n<p translation-result=\"on\">在调度器返回 <code>BuilderRun</code> 控件对象之前，不会执行该构建器函数。CLI 通常会通过调用 <code>context.scheduleTarget()</code> 函数来调度任务，然后使用 <code>angular.json</code> 文件中的目标定义来解析输入选项。</p><p translation-origin=\"off\">The builder function is not executed until the scheduler returns a <code>BuilderRun</code> control object.\nThe CLI typically schedules tasks by calling the <code>context.scheduleTarget()</code> function, and then resolves input options using the target definition in the <code>angular.json</code> file.</p>\n\n<p translation-result=\"on\">建筑师会接受默认的选项对象来解析指定目标的输入选项，然后覆盖所用配置中的值（如果有的话），然后再从传给 <code>context.scheduleTarget()</code> 的覆盖对象中覆盖这些值。对于 Angular CLI，覆盖对象是从命令行参数中构建的。</p><p translation-origin=\"off\">Architect resolves input options for a given target by taking the default options object, then overwriting values from the configuration used (if any), then further overwriting values from the overrides object passed to <code>context.scheduleTarget()</code>.\nFor the Angular CLI, the overrides object is built from command line arguments.</p>\n\n<p translation-result=\"on\">建筑师会根据构建器的模式对生成的选项值进行验证。如果输入有效，建筑师会创建上下文并执行该构建器。</p><p translation-origin=\"off\">Architect validates the resulting options values against the schema of the builder.\nIf inputs are valid, Architect creates the context and executes the builder.</p>\n\n<p translation-result=\"on\">欲知详情，参阅<a href=\"guide/workspace-config\">工作区配置</a>。</p><p translation-origin=\"off\">For more information see <a href=\"guide/workspace-config\">Workspace Configuration</a>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">你还可以通过调用 <code>context.scheduleBuilder()</code> 从另一个构建器或测试中调用某个构建器。你可以直接把 <code>options</code> 对象传给该方法，并且这些选项值会根据这个构建器的模式进行验证，而无需进一步调整。</p><p translation-origin=\"off\">You can also invoke a builder directly from another builder or test by calling <code>context.scheduleBuilder()</code>.\nYou pass an <code>options</code> object directly to the method, and those option values are validated against the schema of the builder without further adjustment.</p>\n\n<p translation-result=\"on\">只有 <code>context.scheduleTarget()</code> 方法来解析这些配置和并通过 <code>angular.json</code> 文件进行覆盖。</p><p translation-origin=\"off\">Only the  <code>context.scheduleTarget()</code> method resolves the configuration and overrides through the <code>angular.json</code> file.</p>\n\n</div>\n<h3 id=\"default-architect-configuration\" translation-result=\"on\">默认建筑师配置<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#default-architect-configuration\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"default-architect-configuration\">Default architect configuration<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#default-architect-configuration\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">让我们创建一个简单的 <code>angular.json</code> 文件，它会把目标配置放到上下文中。</p><p translation-origin=\"off\">Let's create a simple <code>angular.json</code> file that puts target configurations into context.</p>\n\n<p translation-result=\"on\">你可以把这个构建器发布到 npm（参阅<a href=\"guide/creating-libraries#publishing-your-library\">发布你的库</a>），并使用如下命令来安装它：</p><p translation-origin=\"off\">You can publish the builder to npm (see <a href=\"guide/creating-libraries#publishing-your-library\">Publishing your Library</a>), and install it using the following command:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install @example/copy-file\n\n</code-example>\n<p translation-result=\"on\">如果用 <code>ng new builder-test</code> 创建一个新项目，那么生成的 <code>angular.json</code> 文件就是这样的，它只有默认的构建器参数。</p><p translation-origin=\"off\">If you create a new project with <code>ng new builder-test</code>, the generated <code>angular.json</code> file looks something like this, with only default builder configurations.</p>\n\n<code-example format=\"json\" header=\"angular.json\" language=\"json\">\n\n{\n  // …\n  \"projects\": {\n    // …\n    \"builder-test\": {\n      // …\n      \"architect\": {\n        // …\n        \"build\": {\n          \"builder\": \"@angular-devkit/build-angular:browser\",\n          \"options\": {\n            // … more options…\n            \"outputPath\": \"dist/builder-test\",\n            \"index\": \"src/index.html\",\n            \"main\": \"src/main.ts\",\n            \"polyfills\": \"src/polyfills.ts\",\n            \"tsConfig\": \"src/tsconfig.app.json\"\n          },\n          \"configurations\": {\n            \"production\": {\n              // … more options…\n              \"optimization\": true,\n              \"aot\": true,\n              \"buildOptimizer\": true\n            }\n          }\n        }\n      }\n    }\n  }\n  // …\n}\n\n</code-example>\n<h3 id=\"adding-a-target\" translation-result=\"on\">添加一个目标<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#adding-a-target\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"adding-a-target\">Adding a target<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#adding-a-target\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">添加一个新的目标，来运行我们的构建器以复制文件。该目标告诉构建器，复制 <code>package.json</code> 文件。</p><p translation-origin=\"off\">Add a new target that will run our builder to copy a file.\nThis target tells the builder to copy the <code>package.json</code> file.</p>\n\n<p translation-result=\"on\">你需要更新 <code>angular.json</code> 文件，把这个构建器的目标添加到新项目的 <code>architect</code> 部分。</p><p translation-origin=\"off\">You need to update the <code>angular.json</code> file to add a target for this builder to the \"architect\" section of our new project.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">我们会为项目的 <code>architect</code> 对象添加一个新的目标小节</p><p translation-origin=\"off\">We'll add a new target section to the \"architect\" object for our project</p>\n\n</li>\n<li>\n<p translation-result=\"on\">名为 <code>copy-package</code> 的目标使用了我们的构建器，它发布到了 <code>@example/copy-file</code>。（参阅<a href=\"guide/creating-libraries#publishing-your-library\">发布你的库</a>）</p><p translation-origin=\"off\">The target named \"copy-package\" uses our builder, which you published to <code>@example/copy-file</code>.\n(See <a href=\"guide/creating-libraries#publishing-your-library\">Publishing your Library</a>.)</p>\n\n</li>\n<li>\n<p translation-result=\"on\">这个配置对象为我们定义的两个输入提供了默认值：<code>source</code>（你要复制的现有文件）和 <code>destination</code>（你要复制到的路径）</p><p translation-origin=\"off\">The options object provides default values for the two inputs that you defined; <code>source</code>, which is the existing file you are copying, and <code>destination</code>, the path you want to copy to</p>\n\n</li>\n<li>\n<p translation-result=\"on\">这些配置键都是可选的，但我们先不展开</p><p translation-origin=\"off\">The <code>configurations</code> key is optional, we'll leave it out for now</p>\n\n</li>\n</ul>\n<code-example format=\"json\" header=\"angular.json\" language=\"json\">\n\n{\n  \"projects\": {\n    \"builder-test\": {\n      \"architect\": {\n        \"copy-package\": {\n          \"builder\": \"@example/copy-file:copy\",\n          \"options\": {\n            \"source\": \"package.json\",\n            \"destination\": \"package-copy.json\"\n          }\n        },\n        \"build\": {\n          \"builder\": \"@angular-devkit/build-angular:browser\",\n          \"options\": {\n            \"outputPath\": \"dist/builder-test\",\n            \"index\": \"src/index.html\",\n            \"main\": \"src/main.ts\",\n            \"polyfills\": \"src/polyfills.ts\",\n            \"tsConfig\": \"src/tsconfig.app.json\"\n          },\n          \"configurations\": {\n            \"production\": {\n              \"fileReplacements\": [\n                {\n                  \"replace\": \"src/environments/environment.ts\",\n                  \"with\": \"src/environments/environment.prod.ts\"\n                }\n              ],\n              \"optimization\": true,\n              \"aot\": true,\n              \"buildOptimizer\": true\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n</code-example>\n<h3 id=\"running-the-builder\" translation-result=\"on\">运行这个构建器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#running-the-builder\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"running-the-builder\">Running the builder<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#running-the-builder\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要想使用这个新目标的默认配置运行我们的构建器，请使用以下 CLI 命令。</p><p translation-origin=\"off\">To run our builder with the new target's default configuration, use the following CLI command.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng run builder-test:copy-package\n\n</code-example>\n<p translation-result=\"on\">这将把 <code>package.json</code> 文件复制成 <code>package-copy.json</code>。</p><p translation-origin=\"off\">This copies the <code>package.json</code> file to <code>package-copy.json</code>.</p>\n\n<p translation-result=\"on\">你可以使用命令行参数来覆盖已配置的默认值。比如，要改用其它 <code>destination</code> 值运行，请使用以下 CLI 命令。</p><p translation-origin=\"off\">Use command-line arguments to override the configured defaults.\nFor example, to run with a different <code>destination</code> value, use the following CLI command.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng run builder-test:copy-package --destination=package-other.json\n\n</code-example>\n<p translation-result=\"on\">这将把此文件复制为 <code>package-other.json</code> 而不再是 <code>package-copy.json</code>。因为我们没有覆盖 <em>source</em> 选项，所以它仍然会从 <code>package.json</code> 文件复制（提供给该目标的默认值）。</p><p translation-origin=\"off\">This copies the file to <code>package-other.json</code> instead of <code>package-copy.json</code>.\nBecause you did not override the <em>source</em> option, it will copy from the <code>package.json</code> file (the default value provided for the target).</p>\n\n<h2 id=\"testing-a-builder\" translation-result=\"on\">测试一个构建器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#testing-a-builder\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"testing-a-builder\">Testing a builder<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#testing-a-builder\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">对构建器进行集成测试，以便你可以使用建筑师的调度器来创建一个上下文，就像这个<a href=\"https://github.com/mgechev/cli-builders-demo\">例子</a>中一样。</p><p translation-origin=\"off\">Use integration testing for your builder, so that you can use the Architect scheduler to create a context, as in this <a href=\"https://github.com/mgechev/cli-builders-demo\">example</a>.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">在构建器的源码目录下，你创建了一个新的测试文件 <code>my-builder.spec.ts</code>。该代码创建了 <code>JsonSchemaRegistry</code>（用于模式验证）、<code>TestingArchitectHost</code>（对 <code>ArchitectHost</code> 的内存实现）和 <code>Architect</code> 的新实例。</p><p translation-origin=\"off\">In the builder source directory, you have created a new test file <code>my-builder.spec.ts</code>.\nThe code creates new instances of <code>JsonSchemaRegistry</code> (for schema validation), <code>TestingArchitectHost</code> (an in-memory implementation of <code>ArchitectHost</code>), and <code>Architect</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">我们紧挨着这个构建器的 <code>package.json</code> 文件添加了一个 <code>builders.json</code> 文件，并修改了 <code>package.json</code> 文件以指向它。</p><p translation-origin=\"off\">We've added a <code>builders.json</code> file next to the builder's <code>package.json</code> file, and modified the package file to point to it.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">下面是运行此复制文件构建器的测试范例。该测试使用该构建器来复制 <code>package.json</code> 文件，并验证复制后的文件内容与源文件相同。</p><p translation-origin=\"off\">Here's an example of a test that runs the copy file builder.\nThe test uses the builder to copy the <code>package.json</code> file and validates that the copied file's contents are the same as the source.</p>\n\n<code-example header=\"src/my-builder.spec.ts\" path=\"cli-builder/src/my-builder.spec.ts\">\nimport { Architect } from '@angular-devkit/architect';\nimport { TestingArchitectHost } from '@angular-devkit/architect/testing';\nimport { schema } from '@angular-devkit/core';\nimport { promises as fs } from 'fs';\n\ndescribe('Copy File Builder', () => {\n  let architect: Architect;\n  let architectHost: TestingArchitectHost;\n\n  beforeEach(async () => {\n    const registry = new schema.CoreSchemaRegistry();\n    registry.addPostTransform(schema.transforms.addUndefinedDefaults);\n\n    // TestingArchitectHost() takes workspace and current directories.\n    // Since we don't use those, both are the same in this case.\n    architectHost = new TestingArchitectHost(__dirname, __dirname);\n    architect = new Architect(architectHost, registry);\n\n    // This will either take a Node package name, or a path to the directory\n    // for the package.json file.\n    await architectHost.addBuilderFromPackage('..');\n  });\n\n  it('can copy files', async () => {\n    // A \"run\" can have <a href=\"api/forms/SelectMultipleControlValueAccessor\" class=\"code-anchor\">multiple</a> outputs, and contains progress information.\n    const run = await architect.scheduleBuilder('@example/copy-file:copy', {\n      source: 'package.json',\n      destination: 'package-copy.json',\n    });\n\n    // The \"result\" member (of type BuilderOutput) is the next output.\n    const output = await run.result;\n\n    // Stop the builder from running. This stops Architect from keeping\n    // the builder-associated states in memory, since builders keep waiting\n    // to be scheduled.\n    await run.stop();\n\n    // Expect that the copied file is the same as its source.\n    const sourceContent = await fs.readFile('package.json', 'utf8');\n    const destinationContent = await fs.readFile('package-copy.json', 'utf8');\n    expect(destinationContent).toBe(sourceContent);\n  });\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">在你的仓库中运行这个测试时，需要使用 <a href=\"https://github.com/TypeStrong/ts-node\"><code>ts-node</code></a> 包。你可以把 <code>index.spec.ts</code> 重命名为 <code>index.spec.js</code> 来回避它。</p><p translation-origin=\"off\">When running this test in your repo, you need the <a href=\"https://github.com/TypeStrong/ts-node\"><code>ts-node</code></a> package.\nYou can avoid this by renaming <code>my-builder.spec.ts</code> to <code>my-builder.spec.js</code>.</p>\n\n</div>\n<h3 id=\"watch-mode\" translation-result=\"on\">监视（watch）模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#watch-mode\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"watch-mode\">Watch mode<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#watch-mode\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">建筑师希望构建器运行一次（默认情况下）并返回。这种行为与那些需要监视文件更改的构建器（比如 Webpack）并不完全兼容。建筑师可以支持监视模式，但要注意一些问题。</p><p translation-origin=\"off\">Architect expects builders to run once (by default) and return.\nThis behavior is not entirely compatible with a builder that watches for changes (like Webpack, for example).\nArchitect can support watch mode, but there are some things to look out for.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">要在监视模式下使用，构建器处理函数应返回一个 Observable。建筑师会订阅这个 Observable，直到这个 Observable 完成（complete）为止。此外，如果使用相同的参数再次调度这个构建器，建筑师还能复用这个 Observable。</p><p translation-origin=\"off\">To be used with watch mode, a builder handler function should return an Observable.\nArchitect subscribes to the Observable until it completes and might reuse it if the builder is scheduled again with the same arguments.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">这个构建器应该总是在每次执行后发出一个 <code>BuilderOutput</code> 对象。一旦它被执行，就会进入一个由外部事件触发的监视模式。如果一个事件导致它重启，那么此构建器应该执行 <code>context.reportRunning()</code> 函数来告诉建筑师再次运行它。如果调度器还计划了另一次运行，就会阻止建筑师停掉这个构建器。</p><p translation-origin=\"off\">The builder should always emit a <code>BuilderOutput</code> object after each execution.\nOnce it's been executed, it can enter a watch mode, to be triggered by an external event.\nIf an event triggers it to restart, the builder should execute the <code>context.reportRunning()</code> function to tell Architect that it is running again.\nThis prevents Architect from stopping the builder if another run is scheduled.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">当你的构建器通过调用 <code>BuilderRun.stop()</code> 来退出监视模式时，建筑师会从构建器的 Observable 中取消订阅，并调用构建器的退出逻辑进行清理。（这种行为也允许停止和清理运行时间过长的构建。）</p><p translation-origin=\"off\">When your builder calls <code>BuilderRun.stop()</code> to exit watch mode, Architect unsubscribes from the builder's Observable and calls the builder's teardown logic to clean up.\n(This behavior also allows for long running builds to be stopped and cleaned up.)</p>\n\n<p translation-result=\"on\">一般来说，如果你的构建器正在监视一个外部事件，你应该把你的运行分成三个阶段。</p><p translation-origin=\"off\">In general, if your builder is watching an external event, you should separate your run into three phases.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><p translation-result=\"on\">阶段</p><p translation-origin=\"off\">Phases</p></th>\n<th align=\"left\"><p translation-result=\"on\">详情</p><p translation-origin=\"off\">Details</p></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><p translation-result=\"on\">运行</p><p translation-origin=\"off\">Running</p></td>\n<td align=\"left\"><p translation-result=\"on\">比如 webpack 编译。这会在 webpack 完成并且你的构建器发出 <code>BuilderOutput</code> 对象时结束。</p><p translation-origin=\"off\">For example, webpack compiles. This ends when webpack finishes and your builder emits a <code>BuilderOutput</code> object.</p></td>\n</tr>\n\n<tr>\n<td align=\"left\"><p translation-result=\"on\">监视</p><p translation-origin=\"off\">Watching</p></td>\n<td align=\"left\"><p translation-result=\"on\">在两次运行之间监视外部事件流。比如，webpack 会监视文件系统是否发生了任何变化。这会在 webpack 重启构建时结束，并调用 <code>context.reportRunning()</code>。这样就会再回到第 1 步。</p><p translation-origin=\"off\">Between two runs, watch an external event stream. For example, webpack watches the file system for any changes. This ends when webpack restarts building, and <code>context.reportRunning()</code> is called. This goes back to step 1.</p></td>\n</tr>\n\n<tr>\n<td align=\"left\"><p translation-result=\"on\">完成</p><p translation-origin=\"off\">Completion</p></td>\n<td align=\"left\"><p translation-result=\"on\">任务完全完成（比如，webpack 应运行多次），或者构建器停止运行（使用 <code>BuilderRun.stop()</code>）。你的退出逻辑被调用了，建筑师也从你的构建器的 Observable 中取消了订阅。</p><p translation-origin=\"off\">Either the task is fully completed (for example, webpack was supposed to run a number of times), or the builder run was stopped (using <code>BuilderRun.stop()</code>). Your teardown logic is executed, and Architect unsubscribes from your builder's Observable.</p></td>\n</tr>\n\n</tbody>\n</table>\n<h2 id=\"summary\" translation-result=\"on\">总结<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#summary\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"summary\">Summary<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#summary\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">CLI 构建器 API 提供了一种通过构建器执行自定义逻辑，以改变 Angular CLI 行为的新方式。</p><p translation-origin=\"off\">The CLI Builder API provides a new way of changing the behavior of the Angular CLI by using builders to execute custom logic.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">构建器既可以是同步的，也可以是异步的，它可以只执行一次也可以监视外部事件，还可以调度其它构建器或目标</p><p translation-origin=\"off\">Builders can be synchronous or asynchronous, execute once or watch for external events, and can schedule other builders or targets</p>\n\n</li>\n<li>\n<p translation-result=\"on\">构建器在 <code>angular.json</code> 配置文件中指定了选项的默认值，它可以被目标的备用配置覆盖，还可以进一步被命令行标志所覆盖</p><p translation-origin=\"off\">Builders have option defaults specified in the <code>angular.json</code> configuration file, which can be overwritten by an alternate configuration for the target, and further overwritten by command line flags</p>\n\n</li>\n<li>\n<p translation-result=\"on\">建议你使用集成测试来测试建筑师的构建器。还可以用单元测试来验证这个构建器的执行逻辑。</p><p translation-origin=\"off\">We recommend that you use integration tests to test Architect builders.\nUse unit tests to validate the logic that the builder executes.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果你的构建器返回一个 Observable，你应该在那个 Observable 的退出逻辑中进行清理</p><p translation-origin=\"off\">If your builder returns an Observable, it should clean up in the teardown logic of that Observable</p>\n\n</li>\n</ul>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间： 2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - cli/deploy\n - cli/lint\n - guide/architecture-next-steps\n - guide/deployment\n - guide/workspace-config\n-->\n<!-- links from this doc:\n - api/animations/browser\n - api/forms/SelectMultipleControlValueAccessor\n - cli/run\n - guide/cli-builder#adding-a-target\n - guide/cli-builder#angular-cli-builders\n - guide/cli-builder#builder-input\n - guide/cli-builder#builder-project-structure\n - guide/cli-builder#cli-builders\n - guide/cli-builder#creating-a-builder\n - guide/cli-builder#default-architect-configuration\n - guide/cli-builder#handling-output\n - guide/cli-builder#input-validation\n - guide/cli-builder#progress-and-status-reporting\n - guide/cli-builder#running-the-builder\n - guide/cli-builder#schedule-and-run\n - guide/cli-builder#summary\n - guide/cli-builder#target-configuration\n - guide/cli-builder#target-strings\n - guide/cli-builder#testing-a-builder\n - guide/cli-builder#watch-mode\n - guide/creating-libraries#publishing-your-library\n - guide/glossary#builder\n - guide/glossary#project\n - guide/glossary#schematic\n - guide/glossary#target\n - guide/workspace-config\n - http://json-schema.org\n - https://docs.npmjs.com/files/package.json\n - https://electronjs.org\n - https://electronjs.org/\n - https://github.com/TypeStrong/ts-node\n - https://github.com/angular/angular-cli/blob/ba21c855c0c8b778005df01d4851b5a2176edc6f/packages/angular_devkit/build_angular/src/tslint/index.ts#L107\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/cli-builder.md?message=docs%3A%20请简述你的修改...\n - https://github.com/mgechev/cli-builders-demo\n - https://nodejs.org/api/fs.html#fs_fspromises_copyfile_src_dest_mode\n - https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\n-->"
}