{"id":"guide/providers","title":"在模块中提供依赖","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/angular/angular-cn/edit/cn/aio/content/guide/providers.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"providing-dependencies-in-modules\" translation-result=\"on\">在模块中提供依赖<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#providing-dependencies-in-modules\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Providing dependencies in modules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#providing-dependencies-in-modules\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">提供者就是一本说明书，用来指导<a href=\"guide/dependency-injection\">依赖注入</a>系统该如何获取某个依赖的值。大多数情况下，这些依赖就是你要创建和提供的那些服务。</p><p translation-origin=\"off\">A provider is an instruction to the <a href=\"guide/dependency-injection\">Dependency Injection</a> system on how to obtain a value for a dependency.\nMost of the time, these dependencies are services that you create and provide.</p>\n\n<p translation-result=\"on\">要想查看本页提到的这个带有特性模块的范例应用，参阅 <live-example></live-example>。</p><p translation-origin=\"off\">For the final sample application using the provider that this page describes, see the <live-example></live-example>.</p>\n\n<h2 id=\"providing-a-service\" translation-result=\"on\">提供服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#providing-a-service\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Providing a service<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#providing-a-service\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">如果你是用 <a href=\"cli\">Angular CLI</a> 创建的应用，那么可以使用下列 CLI 的 <a href=\"cli/generate\"><code>ng generate</code></a> 命令在项目根目录下创建一个服务。把其中的 <code>User</code> 替换成你的服务名。</p><p translation-origin=\"off\">If you already have an application that was created with the <a href=\"cli\">Angular CLI</a>, you can create a service using the <a href=\"cli/generate\"><code>ng generate</code></a> CLI command in the root project directory.\nReplace <em>User</em> with the name of your service.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate service User\n\n</code-example>\n<p translation-result=\"on\">该命令会创建下列 <code>UserService</code> 骨架：</p><p translation-origin=\"off\">This command creates the following <code>UserService</code> skeleton:</p>\n\n<code-example header=\"src/app/user.service.ts\" path=\"providers/src/app/user.service.0.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class UserService {\n}\n\n\n</code-example>\n<p translation-result=\"on\">现在，你就可以在应用中到处注入 <code>UserService</code> 了。</p><p translation-origin=\"off\">You can now inject <code>UserService</code> anywhere in your application.</p>\n\n<p translation-result=\"on\">该服务本身是 CLI 创建的一个类，并且加上了 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 装饰器。默认情况下，该装饰器是用 <code>providedIn</code> 属性进行配置的，它会为该服务创建一个提供者。在这个例子中，<code>providedIn: 'root'</code> 指定 Angular 应该在根注入器中提供该服务。</p><p translation-origin=\"off\">The service itself is a class that the CLI generated and that's decorated with <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code>.\nBy default, this decorator has a <code>providedIn</code> property, which creates a provider for the service.\nIn this case, <code>providedIn: 'root'</code> specifies that Angular should provide the service in the root injector.</p>\n\n<h2 id=\"provider-scope\" translation-result=\"on\">提供者的作用域<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#provider-scope\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Provider scope<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#provider-scope\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">当你把服务提供者添加到应用的根注入器中时，它就在整个应用程序中可用了。另外，这些服务提供者也同样对整个应用中的类是可用的 —— 只要它们有供查找用的服务令牌。</p><p translation-origin=\"off\">When you add a service provider to the root application injector, it's available throughout the application.\nAdditionally, these providers are also available to all the classes in the application as long they have the lookup token.</p>\n\n<p translation-result=\"on\">你应该始终在根注入器中提供这些服务 —— 除非你希望该服务只有在消费方要导入特定的 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 时才生效。</p><p translation-origin=\"off\">You should always provide your service in the root injector unless there is a case where you want the service to be available only if the consumer imports a particular <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>.</p>\n\n<h2 id=\"providedin-and-ngmodules\" translation-result=\"on\"><code>providedIn</code> 与 NgModule<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#providedin-and-ngmodules\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\"><code>providedIn</code> and NgModules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#providedin-and-ngmodules\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">也可以规定某个服务只有在特定的 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中提供。比如，如果你希望只有当消费方导入了你创建的 <code>UserModule</code> 时才让 <code>UserService</code> 在应用中生效，那就可以指定该服务要在该模块中提供：</p><p translation-origin=\"off\">It's also possible to specify that a service should be provided in a particular <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>.\nFor example, if you don't want <code>UserService</code> to be available to applications unless they import a <code>UserModule</code> you've created, you can specify that the service should be provided in the module:</p>\n\n<code-example header=\"src/app/user.service.ts\" path=\"providers/src/app/user.service.1.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { UserModule } from './user.module';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: UserModule,\n})\nexport class UserService {\n}\n\n\n</code-example>\n<p translation-result=\"on\">上面的例子展示的就是在模块中提供服务的首选方式。之所以推荐该方式，是因为当没有人注入它时，该服务就可以被摇树优化掉。如果没办法指定哪个模块该提供这个服务，你也可以在那个模块中为该服务声明一个提供者：</p><p translation-origin=\"off\">The example above shows the preferred way to provide a service in a module.\nThis method is preferred because it enables tree-shaking of the service if nothing injects it.\nIf it's not possible to specify in the service which module should provide it, you can also declare a provider for the service within the module:</p>\n\n<code-example header=\"src/app/user.module.ts\" path=\"providers/src/app/user.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\n\nimport { UserService } from './user.service';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [UserService],\n})\nexport class UserModule {\n}\n\n\n</code-example>\n<h2 id=\"limiting-provider-scope-by-lazy-loading-modules\" translation-result=\"on\">使用惰性加载模块限制提供者的作用域<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#limiting-provider-scope-by-lazy-loading-modules\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Limiting provider scope by lazy loading modules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#limiting-provider-scope-by-lazy-loading-modules\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在 CLI 生成的基本应用中，模块是急性加载的，这意味着它们都是由本应用启动的，Angular 会使用一个依赖注入体系来让一切服务都在模块间有效。对于急性加载式应用，应用中的根注入器会让所有服务提供者都对整个应用有效。</p><p translation-origin=\"off\">In the basic CLI-generated app, modules are eagerly loaded which means that they are all loaded when the application launches.\nAngular uses an injector system to make things available between modules.\nIn an eagerly loaded app, the root application injector makes all of the providers in all of the modules available throughout the application.</p>\n\n<p translation-result=\"on\">当使用惰性加载时，这种行为需要进行改变。惰性加载就是只有当需要时才加载模块，比如路由中。它们没办法像急性加载模块那样进行加载。这意味着，在它们的 <code>providers</code> 数组中列出的服务都是不可用的，因为根注入器并不知道这些模块。</p><p translation-origin=\"off\">This behavior necessarily changes when you use lazy loading.\nLazy loading is when you load modules only when you need them; for example, when routing.\nThey aren't loaded right away like with eagerly loaded modules.\nThis means that any services listed in their provider arrays aren't available because the root injector doesn't know about these modules.</p>\n\n<!--todo: KW--Make diagram here -->\n<!--todo: KW--per Misko: not clear if the lazy modules are siblings or grand-children. They are both depending on router structure. -->\n<p translation-result=\"on\">当 Angular 的路由器惰性加载一个模块时，它会创建一个新的注入器。这个注入器是应用的根注入器的一个子注入器。想象一棵注入器树，它有唯一的根注入器，而每一个惰性加载模块都有一个自己的子注入器。这个子注入器会操纵所有特定于此模块的提供者，如果有的话。可以遵循这份<a href=\"guide/hierarchical-dependency-injection#resolution-rules\">多级依赖注入规则</a>来了解每个提供者的解析过程。</p><p translation-origin=\"off\">When the Angular router lazy-loads a module, it creates a new injector.\nThis injector is a child of the root application injector.\nImagine a tree of injectors; there is a single root injector and then a child injector for each lazy loaded module.\nThis child injector gets populated with all the module-specific providers, if any.\nLook up resolution for every provider follows the <a href=\"guide/hierarchical-dependency-injection#resolution-rules\">rules of dependency injection hierarchy</a>. </p>\n\n<p translation-result=\"on\">任何在惰性加载模块的上下文中创建的组件（比如路由导航），都会获取由子注入器提供的服务的局部实例，而不是应用的根注入器中的实例。而外部模块中的组件，仍然会收到来自于应用的根注入器创建的实例。</p><p translation-origin=\"off\">Any component created within a lazy loaded module's context, such as by router navigation, gets its own local instance of child provided services, not the instance in the root application injector.\nComponents in external modules continue to receive the instances created for the application root injector.</p>\n\n<p translation-result=\"on\">虽然你可以使用惰性加载模块来提供实例，但不是所有的服务都能惰性加载。比如，像路由之类的模块只能在根模块中使用。路由器需要使用浏览器中的全局对象 <code>location</code> 进行工作。</p><p translation-origin=\"off\">Though you can provide services by lazy loading modules, not all services can be lazy loaded.\nFor instance, some modules only work in the root module, such as the Router.\nThe Router works with the global location object in the browser.</p>\n\n<p translation-result=\"on\">从 Angular 9 开始，你可以在每个惰性加载模块中提供服务的新实例。下列代码把此功能添加到 <code>UserService</code> 中。</p><p translation-origin=\"off\">As of Angular version 9, you can provide a new instance of a service with each lazy loaded module.\nThe following code adds this functionality to <code>UserService</code>.</p>\n\n<code-example header=\"src/app/user.service.ts\" path=\"providers/src/app/user.service.2.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'any',\n})\nexport class UserService {\n}\n\n\n</code-example>\n<p translation-result=\"on\">通过使用 <code>providedIn: 'any'</code>，所有急性加载的模块都会共享同一个服务单例，不过，惰性加载模块各自有它们自己独有的单例。如下所示。</p><p translation-origin=\"off\">With <code>providedIn: 'any'</code>, all eagerly loaded modules share a singleton instance; however, lazy loaded modules each get their own unique instance, as shown in the following diagram.</p>\n\n<div class=\"lightbox\">\n<img alt=\"any-provider-scope\" class=\"left\" src=\"generated/images/guide/providers/any-provider.svg\" width=\"607\" height=\"389\">\n</div>\n<h2 id=\"limiting-provider-scope-with-components\" translation-result=\"on\">使用组件限定服务提供者的作用域<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#limiting-provider-scope-with-components\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Limiting provider scope with components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#limiting-provider-scope-with-components\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">另一种限定提供者作用域的方式是把要限定的服务添加到组件的 <code>providers</code> 数组中。组件中的提供者和 NgModule 中的提供者是彼此独立的。当你要急性加载一个自带了全部所需服务的模块时，这种方式是有帮助的。在组件中提供服务，会限定该服务只能在该组件及其子组件中有效，而同一模块中的其它组件不能访问它。</p><p translation-origin=\"off\">Another way to limit provider scope is by adding the service you want to limit to the component's <code>providers</code> array.\nComponent providers and NgModule providers are independent of each other.\nThis method is helpful when you want to eagerly load a module that needs a service all to itself.\nProviding a service in the component limits the service only to that component and its descendants.\nOther components in the same module can't access it.</p>\n\n<code-example header=\"src/app/app.component.ts\" path=\"providers/src/app/app.component.ts\" region=\"component-providers\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  /* . . . */\n  providers: [UserService]\n})\n\n</code-example>\n<h2 id=\"providing-services-in-modules-vs-components\" translation-result=\"on\">在模块中提供服务还是在组件中？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#providing-services-in-modules-vs-components\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Providing services in modules vs. components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#providing-services-in-modules-vs-components\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">通常，要在根模块中提供整个应用都需要的服务，在惰性加载模块中提供限定范围的服务。</p><p translation-origin=\"off\">Generally, provide services the whole application needs in the root module and scope services by providing them in lazy loaded modules.</p>\n\n<p translation-result=\"on\">路由器工作在根级，所以如果你把服务提供者放进组件（即使是 <code>AppComponent</code>）中，那些依赖于路由器的惰性加载模块，将无法看到它们。</p><p translation-origin=\"off\">The router works at the root level so if you put providers in a component, even <code>AppComponent</code>, lazy loaded modules, which rely on the router, can't see them.</p>\n\n<!-- KW--Make a diagram here -->\n<p translation-result=\"on\">当你必须把一个服务实例的作用域限定到组件及其组件树中时，可以使用组件注册一个服务提供者。比如，用户编辑组件 <code>UserEditorComponent</code>，它需要一个缓存 <code>UserService</code> 实例，那就应该把 <code>UserService</code> 注册进 <code>UserEditorComponent</code> 中。然后，每个 <code>UserEditorComponent</code> 的实例都会获取它自己的缓存服务实例。</p><p translation-origin=\"off\">Register a provider with a component when you must limit a service instance to a component and its component tree, that is, its child components.\nFor example, a user editing component, <code>UserEditorComponent</code>, that needs a private copy of a caching <code>UserService</code> should register the <code>UserService</code> with the <code>UserEditorComponent</code>.\nThen each new instance of the <code>UserEditorComponent</code> gets its own cached service instance.</p>\n\n<p><a id=\"singleton-services\"></a>\n<a id=\"component-child-injectors\"></a></p>\n<h2 id=\"injector-hierarchy-and-service-instances\" translation-result=\"on\">多级注入器和服务实例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#injector-hierarchy-and-service-instances\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Injector hierarchy and service instances<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#injector-hierarchy-and-service-instances\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">服务都是某个注入器范围内的单例，这意味着在给定的注入器中最多有一个服务实例。</p><p translation-origin=\"off\">Services are singletons within the scope of an injector, which means there is at most one instance of a service in a given injector.</p>\n\n<p translation-result=\"on\">Angular DI 具有<a href=\"guide/hierarchical-dependency-injection\">多级注入体系</a>，这意味着嵌套的注入器可以创建自己的服务实例。<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 指定的 <code>providers</code> 的组件的新实例时，它也会为该实例创建一个新的子注入器。同样，当在运行时惰性加载新的 NgModule 时，Angular 可以使用其自己的提供者为其创建注入器。</p><p translation-origin=\"off\">Angular DI has a <a href=\"guide/hierarchical-dependency-injection\">hierarchical injection system</a>, which means that nested injectors can create their own service instances.\nWhenever Angular creates a new instance of a component that has <code>providers</code> specified in <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code>, it also creates a new child injector for that instance.\nSimilarly, when a new NgModule is lazy-loaded at run time, Angular can create an injector for it with its own providers.</p>\n\n<p translation-result=\"on\">子模块注入器和组件注入器彼此独立，并为已提供的服务创建它们自己的单独实例。当 Angular 销毁 NgModule 或组件实例时，它也会销毁该注入器和该注入器的服务实例。</p><p translation-origin=\"off\">Child modules and component injectors are independent of each other, and create their own separate instances of the provided services.\nWhen Angular destroys an NgModule or component instance, it also destroys that injector and that injector's service instances.</p>\n\n<p translation-result=\"on\">欲知详情，请参见<a href=\"guide/hierarchical-dependency-injection\">分层注射器</a>。</p><p translation-origin=\"off\">For more information, see <a href=\"guide/hierarchical-dependency-injection\">Hierarchical injectors</a>.</p>\n\n<h2 id=\"more-on-ngmodules\" translation-result=\"on\">关于 NgModule 的更多知识<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#more-on-ngmodules\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">More on NgModules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#more-on-ngmodules\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你还可能对下列内容感兴趣：</p><p translation-origin=\"off\">You may also be interested in:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><a href=\"guide/singleton-services\">单例服务</a>详细解释了本页包含的那些概念</p><p translation-origin=\"off\"><a href=\"guide/singleton-services\">Singleton Services</a>, which elaborates on the concepts covered on this page</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/lazy-loading-ngmodules\">惰性加载模块</a></p><p translation-origin=\"off\"><a href=\"guide/lazy-loading-ngmodules\">Lazy Loading Modules</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/dependency-injection-providers\">依赖提供者</a></p><p translation-origin=\"off\"><a href=\"guide/dependency-injection-providers\">Dependency providers</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/ngmodule-faq\">NgModule 常见问题</a></p><p translation-origin=\"off\"><a href=\"guide/ngmodule-faq\">NgModule FAQ</a></p>\n\n</li>\n</ul>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间： 2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/bootstrapping\n - guide/entry-components\n - guide/example-apps-list\n - guide/feature-modules\n - guide/lazy-loading-ngmodules\n - guide/module-types\n - guide/ngmodule-api\n - guide/ngmodules\n - guide/sharing-ngmodules\n - tutorial/toh-pt4\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/Injectable\n - api/core/NgModule\n - cli\n - cli/generate\n - guide/dependency-injection\n - guide/dependency-injection-providers\n - guide/hierarchical-dependency-injection\n - guide/hierarchical-dependency-injection#resolution-rules\n - guide/lazy-loading-ngmodules\n - guide/ngmodule-faq\n - guide/providers#injector-hierarchy-and-service-instances\n - guide/providers#limiting-provider-scope-by-lazy-loading-modules\n - guide/providers#limiting-provider-scope-with-components\n - guide/providers#more-on-ngmodules\n - guide/providers#providedin-and-ngmodules\n - guide/providers#providedin-与-ngmodule\n - guide/providers#provider-scope\n - guide/providers#providing-a-service\n - guide/providers#providing-dependencies-in-modules\n - guide/providers#providing-services-in-modules-vs-components\n - guide/providers#使用惰性加载模块限制提供者的作用域\n - guide/providers#使用组件限定服务提供者的作用域\n - guide/providers#关于-ngmodule-的更多知识\n - guide/providers#在模块中提供依赖\n - guide/providers#在模块中提供服务还是在组件中\n - guide/providers#多级注入器和服务实例\n - guide/providers#提供服务\n - guide/providers#提供者的作用域\n - guide/singleton-services\n - https://github.com/angular/angular-cn/edit/cn/aio/content/guide/providers.md?message=docs%3A%20请简述你的修改...\n-->"}