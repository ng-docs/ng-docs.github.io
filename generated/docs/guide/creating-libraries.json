{
  "id": "guide/creating-libraries",
  "title": "Creating libraries",
  "contents": "\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/creating-libraries.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"creating-libraries\" translation-result=\"on\">创建库<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#creating-libraries\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"creating-libraries\">Creating libraries<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#creating-libraries\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">对于如何创建和发布新库，以扩展 Angular 的功能，本页面提供了一个概念性的总览</p><p translation-origin=\"off\">This page provides a conceptual overview of how you can create and publish new libraries to extend Angular functionality.</p>\n\n<p translation-result=\"on\">如果你发现自己要在多个应用中解决同样的问题（或者要把你的解决方案分享给其它开发者），你就有了一个潜在的库。\n简单的例子就是一个用来把用户带到你公司网站上的按钮，该按钮会包含在你公司构建的所有应用中。</p><p translation-origin=\"off\">If you find that you need to solve the same problem in more than one app (or want to share your solution with other developers), you have a candidate for a library.\nA simple example might be a button that sends users to your company website, that would be included in all apps that your company builds.</p>\n\n<h2 id=\"getting-started\" translation-result=\"on\">快速上手<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#getting-started\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"getting-started\">Getting started<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#getting-started\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">使用 Angular CLI，用以下命令在新的工作区中生成一个新库的骨架：</p><p translation-origin=\"off\">Use the Angular CLI to generate a new library skeleton in a new workspace with the following commands.</p>\n\n<code-example language=\"bash\">\n ng new my-workspace --create-application=false\n cd my-workspace\n ng generate library my-lib\n</code-example>\n<p translation-result=\"on\"><code>ng generate</code> 命令会在你的工作区中创建 <code>projects/my-lib</code> 文件夹，其中包含带有一个组件和一个服务的 NgModule。</p><p translation-origin=\"off\">The <code>ng generate</code> command creates the <code>projects/my-lib</code> folder in your workspace, which contains a component and a service inside an NgModule.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">     要了解关于库项目的目录结构的详细信息，参阅<a href=\"guide/file-structure\">项目文件结构</a>中的<a href=\"guide/file-structure#library-project-files\">库项目文件</a>部分。</p><p translation-origin=\"off\">     For more details on how a library project is structured, refer to the <a href=\"guide/file-structure#library-project-files\">Library project files</a> section of the <a href=\"guide/file-structure\">Project File Structure guide</a>.</p>\n\n<p translation-result=\"on\">     你可以使用单一仓库（monorepo）模式将同一个工作区用于多个项目。参阅<a href=\"guide/file-structure#multiple-projects\">建立多项目型工作区</a>。</p><p translation-origin=\"off\">     You can use the monorepo model to use the same workspace for multiple projects.\nSee <a href=\"guide/file-structure#multiple-projects\">Setting up for a multi-project workspace</a>.</p>\n\n</div>\n<p translation-result=\"on\">当你生成一个新库时，该工作区的配置文件 <code>angular.json</code> 中也增加了一个 'library' 类型的项目。</p><p translation-origin=\"off\">When you generate a new library, the workspace configuration file, <code>angular.json</code>, is updated with a project of type <code>library</code>.</p>\n\n<code-example format=\"json\">\n\"projects\": {\n  ...\n  \"my-lib\": {\n    \"root\": \"projects/my-lib\",\n    \"sourceRoot\": \"projects/my-lib/src\",\n    \"projectType\": \"library\",\n    \"prefix\": \"lib\",\n    \"architect\": {\n      \"build\": {\n        \"builder\": \"@angular-devkit/build-angular:ng-packagr\",\n        ...\n</code-example>\n<p translation-result=\"on\">你可以使用 CLI 命令来构建、测试和 lint 这个项目：</p><p translation-origin=\"off\">You can build, test, and lint the project with CLI commands:</p>\n\n<code-example language=\"bash\">\n ng build my-lib --configuration development\n ng test my-lib\n ng lint my-lib\n</code-example>\n<p translation-result=\"on\">注意，该项目配置的构建器与应用类项目的默认构建器不同。此构建器可以确保库永远使用 <a href=\"guide/aot-compiler\">AoT 编译器</a>构建。</p><p translation-origin=\"off\">Notice that the configured builder for the project is different from the default builder for app projects.\nThis builder, among other things, ensures that the library is always built with the <a href=\"guide/aot-compiler\">AOT compiler</a>.</p>\n\n<p translation-result=\"on\">要让库代码可以复用，你必须为它定义一个公共的 API。这个“用户层”定义了库中消费者的可用内容。该库的用户应该可以通过单个的导入路径来访问公共功能（如 NgModules、服务提供者和工具函数）。</p><p translation-origin=\"off\">To make library code reusable you must define a public API for it. This \"user layer\" defines what is available to consumers of your library. A user of your library should be able to access public functionality (such as NgModules, service providers and general utility functions) through a single import path.</p>\n\n<p translation-result=\"on\">库的公共 API 是在库文件夹下的 <code>public-api.ts</code> 文件中维护的。当你的库被导入应用时，从该文件导出的所有内容都会公开。请使用 NgModule 来暴露这些服务和组件。</p><p translation-origin=\"off\">The public API for your library is maintained in the <code>public-api.ts</code> file in your library folder.\nAnything exported from this file is made public when your library is imported into an application.\nUse an NgModule to expose services and components.</p>\n\n<p translation-result=\"on\">你的库里应该提供一些文档（通常是 README 文件）来指导别人安装和维护。</p><p translation-origin=\"off\">Your library should supply documentation (typically a README file) for installation and maintenance.</p>\n\n<h2 id=\"refactoring-parts-of-an-app-into-a-library\" translation-result=\"on\">把应用中的部分内容重构成一个库<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#refactoring-parts-of-an-app-into-a-library\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"refactoring-parts-of-an-app-into-a-library\">Refactoring parts of an app into a library<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#refactoring-parts-of-an-app-into-a-library\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">为了让你的解决方案可供复用，你需要对它进行调整，以免它依赖应用特有的代码。在将应用的功能迁移到库中时，需要注意以下几点。</p><p translation-origin=\"off\">To make your solution reusable, you need to adjust it so that it does not depend on app-specific code.\nHere are some things to consider in migrating application functionality to a library.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">  组件和管道之类的可声明对象应该设计成无状态的，这意味着它们不依赖或修改外部变量。如果确实依赖于状态，就需要对每种情况进行评估，以决定它是应用的状态还是库要管理的状态。</p><p translation-origin=\"off\">Declarations such as components and pipes should be designed as stateless, meaning they don’t rely on or alter external variables. If you do rely on state, you need to evaluate every case and decide whether it is application state or state that the library would manage.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">  组件内部订阅的所有可观察对象都应该在这些组件的生命周期内进行清理和释放。</p><p translation-origin=\"off\">Any observables that the components subscribe to internally should be cleaned up and disposed of during the lifecycle of those components.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">  组件对外暴露交互方式时，应该通过输入参数来提供上下文，通过输出参数来将事件传给其它组件。</p><p translation-origin=\"off\">Components should expose their interactions through inputs for providing context, and outputs for communicating events to other components.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">  检查所有内部依赖。</p><p translation-origin=\"off\">Check all internal dependencies.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">   对于在组件或服务中使用的自定义类或接口，检查它们是否依赖于其它类或接口，它们也需要一起迁移。</p><p translation-origin=\"off\">For custom classes or interfaces used in components or service, check whether they depend on additional classes or interfaces that also need to be migrated.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">   同样，如果你的库代码依赖于某个服务，则需要迁移该服务。</p><p translation-origin=\"off\">Similarly, if your library code depends on a service, that service needs to be migrated.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果你的库代码或其模板依赖于其它库（比如 Angular Material ），你就必须把它们配置为该库的依赖。</p><p translation-origin=\"off\">If your library code or its templates depend on other libraries (such as Angular Material, for instance), you must configure your library with those dependencies.</p>\n\n</li>\n</ul>\n</li>\n<li>\n<p translation-result=\"on\">考虑如何为客户端应用提供服务。</p><p translation-origin=\"off\">Consider how you provide services to client applications.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> 服务应该自己声明提供者（而不是在 NgModule 或组件中声明提供者），以便它们是<em>可摇树优化的</em> 。这样，如果服务器从未被注入到导入该库的应用中，编译器就会把该服务从该 bundle 中删除。关于这方面的更多信息，请参阅<a href=\"guide/architecture-services#providing-services\">Tree-shakable 提供者</a> 。</p><p translation-origin=\"off\">Services should declare their own providers, rather than declaring providers in the NgModule or a component. Declaring a provider makes that service <em>tree-shakable</em>. This practice allows the compiler to leave the service out of the bundle if it never gets injected into the application that imports the library. For more about this, see <a href=\"guide/architecture-services#providing-services\">Tree-shakable providers</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 如果你在多个 NgModules 注册全局服务提供者或提供者共享，使用<a href=\"guide/singleton-services\"><code>forRoot()</code> 和 <code>forChild()</code> 设计模式</a>由提供<a href=\"api/router/RouterModule\">RouterModule</a> 。</p><p translation-origin=\"off\">If you register global service providers or share providers across multiple NgModules, use the <a href=\"guide/singleton-services\"><code>forRoot()</code> and <code>forChild()</code> design patterns</a> provided by the <a href=\"api/router/RouterModule\">RouterModule</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 如果你的库中提供的可选服务可能并没有被所有的客户端应用所使用，那么就可以通过<a href=\"guide/lightweight-injection-tokens\">轻量级令牌设计模式</a>为这种情况支持正确的树状<a href=\"guide/lightweight-injection-tokens\">结构了</a> 。</p><p translation-origin=\"off\">If your library provides optional services that might not be used by all client applications, support proper tree-shaking for that case by using the <a href=\"guide/lightweight-injection-tokens\">lightweight token design pattern</a>.</p>\n\n</li>\n</ul>\n</li>\n</ul>\n<a id=\"integrating-with-the-cli\"></a>\n<a id=\"integration with the the cli\"></a>\n<h2 id=\"integrating-with-the-cli-using-code-generation-schematics\" translation-result=\"on\">使用代码生成原理图与 CLI 集成<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#integrating-with-the-cli-using-code-generation-schematics\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"integrating-with-the-cli-using-code-generation-schematics\">Integrating with the CLI using code-generation schematics<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#integrating-with-the-cli-using-code-generation-schematics\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">一个库通常都包含<em>可复用的代码</em> ，用于定义组件，服务，以及你刚才导入到项目中的其他 Angular 工件（管道，指令等等）。库被打包成一个 npm 包，用于发布和共享。这个包还可以包含一些<a href=\"guide/glossary#schematic\">原理图</a> ，它提供直接在项目中生成或转换代码的指令，就像 CLI 用 <code>ng generate component</code> 创建一个通用的新 <code>ng generate component</code> 。例如，用库打包的原理图可以为 Angular CLI 提供生成组件所需的信息，该组件用于配置和使用该库中定义的特定特性或一组特性。这方面的一个例子是 <a href=\"https://material.angular.cn/guide/schematics#navigation-schematic\">Angular Material 的导航原理图</a>，它用来配置 CDK 的 <a href=\"https://material.angular.cn/cdk/layout/overview#breakpointobserver\"><code>BreakpointObserver</code></a> 并把它与 Material 的 <a href=\"https://material.angular.cn/components/sidenav/overview\">MatSideNav</a> 和 <a href=\"https://material.angular.cn/components/toolbar/overview\">MatToolbar</a> 组件一起使用。</p><p translation-origin=\"off\">A library typically includes <em>reusable code</em> that defines components, services, and other Angular artifacts (pipes, directives, and so on) that you simply import into a project.\nA library is packaged into an npm package for publishing and sharing.\nThis package can also include <a href=\"guide/glossary#schematic\">schematics</a> that provide instructions for generating or transforming code directly in your project, in the same way that the CLI creates a generic new component with <code>ng generate component</code>.\nA schematic that is packaged with a library can, for example, provide the Angular CLI with the information it needs to generate a component that configures and uses a particular feature, or set of features, defined in that library.\nOne example of this is <a href=\"https://material.angular.io/guide/schematics#navigation-schematic\">Angular Material's navigation schematic</a> which configures the CDK's <a href=\"https://material.angular.io/cdk/layout/overview#breakpointobserver\">BreakpointObserver</a> and uses it with Material's <a href=\"https://material.angular.io/components/sidenav/overview\">MatSideNav</a> and <a href=\"https://material.angular.io/components/toolbar/overview\">MatToolbar</a> components.</p>\n\n<p translation-result=\"on\">你可以创建并包含以下几种原理图。</p><p translation-origin=\"off\">You can create and include the following kinds of schematics:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">包含一个安装原理图，以便 <code>ng add</code> 可以把你的库添加到项目中。</p><p translation-origin=\"off\">Include an installation schematic so that <code>ng add</code> can add your library to a project.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在库中包含了生成原理图，以便 <code>ng generate</code> 可以为项目中的已定义工件（组件，服务，测试等）提供支持。</p><p translation-origin=\"off\">Include generation schematics in your library so that <code>ng generate</code> can scaffold your defined artifacts (components, services, tests, and so on) in a project.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">包含一个更新的原理图，以便 <code>ng update</code> 可以更新你的库的依赖，并提供一些迁移来破坏新版本中的更改。</p><p translation-origin=\"off\">Include an update schematic so that <code>ng update</code> can update your library’s dependencies and provide migrations for breaking changes in new releases.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">你的库中所包含的内容取决于你的任务。例如，你可以定义一个原理图来创建一个预先填充了固定数据的下拉列表，以展示如何把它添加到一个应用中。如果你想要一个每次包含不同传入值的下拉列表，那么你的库可以定义一个原理图来用指定的配置创建它。然后，开发人员可以使用 <code>ng generate</code> 为自己的应用配置一个实例。</p><p translation-origin=\"off\">What you include in your library depends on your task.\nFor example, you could define a schematic to create a dropdown that is pre-populated with canned data to show how to add it to an app.\nIf you want a dropdown that would contain different passed-in values each time, your library could define a schematic to create it with a given configuration. Developers could then use <code>ng generate</code> to configure an instance for their own app.</p>\n\n<p translation-result=\"on\">假设你要读取配置文件，然后根据该配置生成表单。如果该表单需要库的用户进行额外的自定义，它可能最适合用作 schematic。但是，如果这些表单总是一样的，开发人员不需要做太多自定义工作，那么你就可以创建一个动态的组件来获取配置并生成表单。通常，自定义越复杂，schematic 方式就越有用。</p><p translation-origin=\"off\">Suppose you want to read a configuration file and then generate a form based on that configuration.\nIf that form will need additional customization by the developer who is using your library, it might work best as a schematic.\nHowever, if the form will always be the same and not need much customization by developers, then you could create a dynamic component that takes the configuration and generates the form.\nIn general, the more complex the customization, the more useful the schematic approach.</p>\n\n<p translation-result=\"on\">要了解更多信息，参阅 <a href=\"guide/schematics\">原理图概览</a> 和 <a href=\"guide/schematics-for-libraries\">供库使用的原理图</a>。</p><p translation-origin=\"off\">To learn more, see <a href=\"guide/schematics\">Schematics Overview</a> and <a href=\"guide/schematics-for-libraries\">Schematics for Libraries</a>.</p>\n\n<h2 id=\"publishing-your-library\" translation-result=\"on\">发布你的库<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#publishing-your-library\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"publishing-your-library\">Publishing your library<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#publishing-your-library\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">使用 Angular CLI 和 npm 包管理器来构建你的库并发布为 npm 包。</p><p translation-origin=\"off\">Use the Angular CLI and the npm package manager to build and publish your library as an npm package.</p>\n\n<p translation-result=\"on\">Angular CLI 使用一个名为 <a href=\"https://github.com/ng-packagr/ng-packagr/blob/master/README.md\">ng-packagr</a> 的工具从已编译的代码中创建可以发布到 npm 的软件包。<code>ng-packagr</code> 支持的发行格式的信息以及有关如何为库选择正确格式的指南，请参阅<a href=\"guide/creating-libraries#ivy-libraries\">使用 Ivy 构建库</a>。</p><p translation-origin=\"off\">Angular CLI uses a tool called <a href=\"https://github.com/ng-packagr/ng-packagr/blob/master/README.md\">ng-packagr</a> to create packages\nfrom your compiled code that can be published to npm.\nSee <a href=\"guide/creating-libraries#ivy-libraries\">Building libraries with Ivy</a> for information on the\ndistribution formats supported by <code>ng-packagr</code> and guidance on how\nto choose the right format for your library.</p>\n\n<p translation-result=\"on\">你应该总是使用 <code>production</code> 配置来构建用于分发的库。这样可以确保所生成的输出对 npm 使用了适当的优化和正确的软件包格式。</p><p translation-origin=\"off\">You should always build libraries for distribution using the <code>production</code> configuration.\nThis ensures that generated output uses the appropriate optimizations and the correct package format for npm.</p>\n\n<code-example language=\"bash\">\nng build my-lib\ncd dist/my-lib\nnpm publish\n</code-example>\n<a id=\"lib-assets\"></a>\n<h2 id=\"managing-assets-in-a-library\" translation-result=\"on\">管理库中的资产（assets）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#managing-assets-in-a-library\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"managing-assets-in-a-library\">Managing assets in a library<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#managing-assets-in-a-library\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">从 <a href=\"https://github.com/ng-packagr/ng-packagr/blob/master/README.md\">ng-packagr</a> 工具的 9.x 版本开始，你可以配置它，以便在构建过程中自动把资产复制到库的发布包里。\n如果你的库需要发布一些可选的主题文件、Sass mixins 或文档（比如变更记录），可以使用这个特性。</p><p translation-origin=\"off\">Starting with version 9.x of the <a href=\"https://github.com/ng-packagr/ng-packagr/blob/master/README.md\">ng-packagr</a> tool, you can configure the tool to automatically copy assets into your library package as part of the build process.\nYou can use this feature when your library needs to publish optional theming files, Sass mixins, or documentation (like a changelog).</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">你可以学习如何<a href=\"https://github.com/ng-packagr/ng-packagr/blob/master/docs/copy-assets.md\">把资产复制到你的发布库中</a>。</p><p translation-origin=\"off\">Learn how to <a href=\"https://github.com/ng-packagr/ng-packagr/blob/master/docs/copy-assets.md\">copy assets into your library as part of the build</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">你还可以学习如何使用本工具<a href=\"https://github.com/ng-packagr/ng-packagr/blob/master/docs/embed-assets-css.md\">把资产内联到 CSS 中</a>。</p><p translation-origin=\"off\">Learn more about how to use the tool to <a href=\"https://github.com/ng-packagr/ng-packagr/blob/master/docs/embed-assets-css.md\">embed assets in CSS</a>.</p>\n\n</li>\n</ul>\n<h2 id=\"linked-libraries\" translation-result=\"on\">链接库<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#linked-libraries\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"linked-libraries\">Linked libraries<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#linked-libraries\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在开发要发布的库时，可以使用 <a href=\"https://docs.npmjs.com/cli/link\">npm link</a> 来避免每次构建时都被迫重新安装库。</p><p translation-origin=\"off\">While working on a published library, you can use <a href=\"https://docs.npmjs.com/cli/link\">npm link</a> to avoid reinstalling the library on every build.</p>\n\n<p translation-result=\"on\">必须在每次修改时都重新构建这个库。在链接库时，确保构建步骤在监视模式下运行，并且该库的 <code>package.json</code> 配置指向了正确的入口点。例如，<code>main</code> 应该指向一个 JavaScript 文件，而不是一个 TypeScript 文件。</p><p translation-origin=\"off\">The library must be rebuilt on every change.\nWhen linking a library, make sure that the build step runs in watch mode, and that the library's <code>package.json</code> configuration points at the correct entry points.\nFor example, <code>main</code> should point at a JavaScript file, not a TypeScript file.</p>\n\n<h3 id=\"use-typescript-path-mapping-for-peer-dependencies\" translation-result=\"on\">对同级依赖使用 TypeScript 路径映射<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#use-typescript-path-mapping-for-peer-dependencies\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"use-typescript-path-mapping-for-peer-dependencies\">Use TypeScript path mapping for peer dependencies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#use-typescript-path-mapping-for-peer-dependencies\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">Angular 库应该把所有 <code>@angular/*</code> 依赖项都列为同级依赖。这确保了当各个模块请求 Angular 时，都会得到完全相同的模块。如果某个库在 <code>dependencies</code> 列出 <code>@angular/core</code> 而不是用 <code>peerDependencies</code>，它可能会得到一个不同的 Angular 模块，这会破坏你的应用。</p><p translation-origin=\"off\">Angular libraries should list all <code>@angular/*</code> dependencies as peer dependencies.\nThis ensures that when modules ask for Angular, they all get the exact same module.\nIf a library lists <code>@angular/core</code> in <code>dependencies</code> instead of <code>peerDependencies</code>, it might get a different Angular module instead, which would cause your application to break.</p>\n\n<p translation-result=\"on\">在开发库的过程中，你必须通过 <code>devDependencies</code> 安装所有的同级依赖，以确保库能够正确编译。这样，一个链接过的库就会拥有自己的一组用于构建的 Angular 库，它们位于 <code>node_modules</code> 文件夹中。但是，这会在构建或运行应用时引发问题。</p><p translation-origin=\"off\">While developing a library, you must install all peer dependencies through <code>devDependencies</code> to ensure that the library compiles properly.\nA linked library will then have its own set of Angular libraries that it uses for building, located in its <code>node_modules</code> folder.\nHowever, this can cause problems while building or running your application.</p>\n\n<p translation-result=\"on\">为了解决此问题，你可以使用 TypeScript 路径映射来告诉 TypeScript 它应该从指定的位置加载某些模块。在 TypeScript 配置文件 <code>./tsconfig.json</code> 中列出该库使用的所有同级依赖，并把它们指向应用的 <code>node_modules</code> 文件夹中的本地副本。</p><p translation-origin=\"off\">To get around this problem you can use TypeScript path mapping to tell TypeScript that it should load some modules from a specific location.\nList all the peer dependencies that your library uses in the workspace TypeScript configuration file <code>./tsconfig.json</code>, and point them at the local copy in the app's <code>node_modules</code> folder.</p>\n\n<code-example>\n{\n  \"compilerOptions\": {\n    // ...\n    // paths are relative to `baseUrl` path.\n    \"paths\": {\n      \"@angular/*\": [\n        \"./node_modules/@angular/*\"\n      ]\n    }\n  }\n}\n</code-example>\n<p translation-result=\"on\">此映射可确保你的库始终加载所需模块的本地副本。</p><p translation-origin=\"off\">This mapping ensures that your library always loads the local copies of the modules it needs.</p>\n\n<h2 id=\"using-your-own-library-in-apps\" translation-result=\"on\">在应用中使用自己的库<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#using-your-own-library-in-apps\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"using-your-own-library-in-apps\">Using your own library in apps<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#using-your-own-library-in-apps\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你不必把库发布到 npm 包管理器上就可以在自己的应用中使用它，但必须先构建它。</p><p translation-origin=\"off\">You don't have to publish your library to the npm package manager in order to use it in your own apps, but you do have to build it first.</p>\n\n<p translation-result=\"on\">要想在应用中使用你自己的库：</p><p translation-origin=\"off\">To use your own library in an app:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> 构建该库。在构建之前，无法使用库。</p><p translation-origin=\"off\">Build the library. You cannot use a library before it is built.</p>\n\n<code-example language=\"bash\">\nng build my-lib\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\"> 在你的应用中，按名字从库中导入：</p><p translation-origin=\"off\">In your apps, import from the library by name:</p>\n\n<code-example>\nimport { myExport } from 'my-lib';\n</code-example>\n</li>\n</ul>\n<h3 id=\"building-and-rebuilding-your-library\" translation-result=\"on\">构建和重建你的库<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#building-and-rebuilding-your-library\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"building-and-rebuilding-your-library\">Building and rebuilding your library<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#building-and-rebuilding-your-library\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果你没有把库发布为 npm 包，然后把它从 npm 安装到你的应用中，那么构建步骤就是必要的。例如，如果你克隆了 git 仓库并运行了 <code>npm install</code>，编辑器就会把 <code>my-lib</code> 的导入显示为缺失状态（如果你还没有构建过该库）。</p><p translation-origin=\"off\">The build step is important if you haven't published your library as an npm package and then installed the package back into your app from npm.\nFor instance, if you clone your git repository and run <code>npm install</code>, your editor will show the <code>my-lib</code> imports as missing if you haven't yet built your library.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">当你在 Angular 应用中从某个库导入一些东西时，Angular 就会寻找库名和磁盘上某个位置之间的映射关系。当你用 npm 包安装该库时，它就映射到 <code>node_modules</code> 目录下。当你自己构建库时，它就会在 <code>tsconfig</code> 路径中查找这个映射。</p><p translation-origin=\"off\">When you import something from a library in an Angular app, Angular looks for a mapping between the library name and a location on disk.\nWhen you install a library package, the mapping is in the <code>node_modules</code> folder. When you build your own library, it has to find the mapping in your <code>tsconfig</code> paths.</p>\n\n<p translation-result=\"on\">用 Angular CLI 生成库时，会自动把它的路径添加到 <code>tsconfig</code> 文件中。Angular CLI 使用 <code>tsconfig</code> 路径告诉构建系统在哪里寻找这个库。</p><p translation-origin=\"off\">Generating a library with the Angular CLI automatically adds its path to the <code>tsconfig</code> file.\nThe Angular CLI uses the <code>tsconfig</code> paths to tell the build system where to find the library.</p>\n\n</div>\n<p translation-result=\"on\">如果你发现库中的更改没有反映到应用中，那么你的应用很可能正在使用这个库的旧版本。</p><p translation-origin=\"off\">If you find that changes to your library are not reflected in your app, your app is probably using an old build of the library.</p>\n\n<p translation-result=\"on\">每当你对它进行修改时，都可以重建你的库，但这个额外的步骤需要时间。<em>增量构建</em>功能可以改善库的开发体验。每当文件发生变化时，都会执行局部构建，并修补一些文件。</p><p translation-origin=\"off\">You can rebuild your library whenever you make changes to it, but this extra step takes time.\n<em>Incremental builds</em> functionality improves the library-development experience.\nEvery time a file is changed a partial build is performed that emits the amended files.</p>\n\n<p translation-result=\"on\">增量构建可以作为开发环境中的后台进程运行。要启用这个特性，可以在构建命令中加入 <code>--watch</code> 标志：</p><p translation-origin=\"off\">Incremental builds can be run as a background process in your dev environment. To take advantage of this feature add the <code>--watch</code> flag to the build command:</p>\n\n<code-example language=\"bash\">\nng build my-lib --watch\n</code-example>\n<div class=\"alert is-important\">\n<p translation-result=\"on\">CLI 的 <code>build</code> 命令为库使用与应用不同的构建器，并调用不同的构建工具。</p><p translation-origin=\"off\">The CLI <code>build</code> command uses a different builder and invokes a different build tool for libraries than it does for applications.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">应用的构建体系（<code>@angular-devkit/build-angular</code>）基于 <code>webpack</code>，并被包含在所有新的 Angular CLI 项目中。</p><p translation-origin=\"off\">The build system for apps, <code>@angular-devkit/build-angular</code>, is based on <code>webpack</code>, and is included in all new Angular CLI projects.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">库的构建体系基于 <code>ng-packagr</code>。只有在使用 <code>ng generate library my-lib</code> 添加库时，它才会添加到依赖项中。</p><p translation-origin=\"off\">The build system for libraries is based on <code>ng-packagr</code>. It is only added to your dependencies when you add a library using <code>ng generate library my-lib</code>.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">这两种构建体系支持不同的东西，即使它们支持相同的东西，它们的执行方式也不同。\n这意味着同一套 TypeScript 源码在生成库时生成的 JavaScript 代码可能与生成应用时生成的 JavaScript 代码也不同。</p><p translation-origin=\"off\">The two build systems support different things, and even where they support the same things, they do those things differently.\nThis means that the TypeScript source can result in different JavaScript code in a built library than it would in a built application.</p>\n\n<p translation-result=\"on\">因此，依赖于库的应用应该只使用指向<em>内置库</em>的 TypeScript 路径映射。\nTypeScript 的路径映射<em>不应该</em>指向库的 <code>.ts</code> 源文件。</p><p translation-origin=\"off\">For this reason, an app that depends on a library should only use TypeScript path mappings that point to the <em>built library</em>.\nTypeScript path mappings should <em>not</em> point to the library source <code>.ts</code> files.</p>\n\n</div>\n<a id=\"ivy-libraries\"></a>\n<h2 id=\"building-libraries-with-ivy\" translation-result=\"on\">使用 Ivy 构建库<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#building-libraries-with-ivy\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"building-libraries-with-ivy\">Building libraries with Ivy<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#building-libraries-with-ivy\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">发布库时可以使用三种分发格式：</p><p translation-origin=\"off\">There are three distribution formats that you can use when publishing a library:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">View Engine <em>（已弃用）</em> —— 旧版格式，计划在 Angular 版本 13 中删除。仅在必须支持 View Engine 应用时才使用此格式。</p><p translation-origin=\"off\">View Engine <em>(deprecated)</em>—legacy format, slated for removal in Angular version 13.\nOnly use this format if you must support View Engine applications.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">partial-Ivy（部分 Ivy）<strong>（推荐）</strong> —— 包含可移植代码，从 v12 开始，使用任何版本的 Angular 构建的 Ivy 应用都可以使用这些可移植代码。</p><p translation-origin=\"off\">partial-Ivy <strong>(recommended)</strong>—contains portable code that can be consumed by Ivy applications built with any version of Angular from v12 onwards.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">full-Ivy（完全 Ivy）—— 包含专用的 Angular Ivy 指令，不能保证它们可在 Angular 的不同版本中使用。这种格式要求库和应用使用<em>完全相同</em>的 Angular 版本构建。这种格式对于直接从源代码构建所有库和应用代码的环境很有用。</p><p translation-origin=\"off\">full-Ivy—contains private Angular Ivy instructions, which are not guaranteed to work across different versions of Angular. This format requires that the library and application are built with the <em>exact</em> same version of Angular. This format is useful for environments where all library and application code is built directly from source.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">使用 Angular CLI 创建的新库默认为 partial-Ivy 格式。如果你正在使用 <code>ng generate library</code> 创建一个新库，则 Angular 默认使用 Ivy，而你无需采取任何其他措施。</p><p translation-origin=\"off\">New libraries created with Angular CLI default to partial-Ivy format.\nIf you are creating a new library with <code>ng generate library</code>, Angular uses Ivy by default with no further action on your part.</p>\n\n<h3 id=\"transitioning-libraries-to-partial-ivy-format\" translation-result=\"on\">将库转换为部分 Ivy 格式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#transitioning-libraries-to-partial-ivy-format\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"transitioning-libraries-to-partial-ivy-format\">Transitioning libraries to partial-Ivy format<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#transitioning-libraries-to-partial-ivy-format\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">升级到使用 Ivy 的更高版本的 Angular 时，配置为生成 View Engine 格式的现有库不会更改。</p><p translation-origin=\"off\">Existing libraries, which are configured to generate the View Engine format, do not change when upgrading to later versions of Angular that use Ivy.</p>\n\n<p translation-result=\"on\">如果打算将库发布到 npm，请通过在 <code>tsconfig.prod.json</code> 中设置 <code>\"compilationMode\": \"partial\"</code> 来编译为部分 Ivy 的代码。</p><p translation-origin=\"off\">If you intend to publish your library to npm, compile with partial-Ivy code by setting <code>\"compilationMode\": \"partial\"</code> in <code>tsconfig.prod.json</code>.</p>\n\n<p translation-result=\"on\">使用 View Engine 而不是 Ivy 的库具有 <code>tsconfig.prod.json</code> 文件，该文件包含以下内容：</p><p translation-origin=\"off\">A library that uses View Engine, rather than Ivy, has a <code>tsconfig.prod.json</code> file that contains the following:</p>\n\n<code-example>\n\n\"angularCompilerOptions\": {\n  \"enableIvy\": false\n}\n\n</code-example>\n<p translation-result=\"on\">要把这样的库转换为使用部分 Ivy 的格式，请修改 <code>tsconfig.prod.json</code> 文件，删除 <code>enableIvy</code> 选项，并添加 <code>compilationMode</code> 选项。</p><p translation-origin=\"off\">To convert such libraries to use the partial-Ivy format, change the <code>tsconfig.prod.json</code> file by removing the <code>enableIvy</code> option and adding the <code>compilationMode</code> option.</p>\n\n<p translation-result=\"on\">通过把 <code>\"enableIvy\": false</code> 替换为 <code>\"compilationMode\": \"partial\"</code> 来启用部分 Ivy 编译，如下所示：</p><p translation-origin=\"off\">Enable partial-Ivy compilation by replacing <code>\"enableIvy\": false</code> with <code>\"compilationMode\": \"partial\"</code> as follows:</p>\n\n<code-example>\n\n\"angularCompilerOptions\": {\n  \"compilationMode\": \"partial\"\n}\n\n</code-example>\n<p translation-result=\"on\">对于发布到 npm 的库，请使用 partial-Ivy 格式，因为它在 Angular 的各个补丁版本之间是稳定的。</p><p translation-origin=\"off\">For publishing to npm use the partial-Ivy format as it is stable between patch versions of Angular.</p>\n\n<p translation-result=\"on\">如果要发布到 npm，请避免使用完全 Ivy 的方式编译库，因为生成的 Ivy 指令不属于 Angular 公共 API 的一部分，因此在补丁版本之间可能会有所不同。</p><p translation-origin=\"off\">Avoid compiling libraries with full-Ivy code if you are publishing to npm because the generated Ivy instructions are not part of Angular's public API, and so may change between patch versions.</p>\n\n<p translation-result=\"on\">部分 Ivy 的代码与 View Engine 向后不兼容。如果在 View Engine 应用中使用该库，则必须在 <code>tsconfig.json</code> 文件中设置 <code>\"enableIvy\": false</code>。</p><p translation-origin=\"off\">Partial-Ivy code is not backward compatible with View Engine.\nIf you use the library in a View Engine application, you must compile the library into the View Engine format by setting <code>\"enableIvy\": false</code> in the <code>tsconfig.json</code> file.</p>\n\n<p translation-result=\"on\">Ivy 应用仍然可以使用 View Engine 格式，因为 Angular 兼容性编译器或 <code>ngcc</code> 可以将其转换为 Ivy。</p><p translation-origin=\"off\">Ivy applications can still consume the View Engine format because the Angular compatibility compiler, or <code>ngcc</code>, can convert it to Ivy.</p>\n\n<h2 id=\"ensuring-library-version-compatibility\" translation-result=\"on\">确保库版本兼容性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#ensuring-library-version-compatibility\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"ensuring-library-version-compatibility\">Ensuring library version compatibility<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#ensuring-library-version-compatibility\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">用于构建应用的 Angular 版本应始终与用于构建其任何依赖库的 Angular 版本相同或更大。例如，如果你有一个使用 Angular 12 版的库，则依赖于该库的应用应该使用 Angular 12 版或更高版本。Angular 不支持为该应用使用早期版本。</p><p translation-origin=\"off\">The Angular version used to build an application should always be the same or greater than the Angular versions used to build any of its dependent libraries.\nFor example, if you had a library using Angular version 12, the application that depends on that library should use Angular version 12 or later.\nAngular does not support using an earlier version for the application.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">Angular CLI 使用 Ivy 来构建应用，并且不再使用 View Engine。使用 View Engine 构建的库或应用不能使用部分 Ivy 格式的库。</p><p translation-origin=\"off\">The Angular CLI uses Ivy to build applications and no longer uses View Engine.\nA library or an application built with View Engine cannot consume a partial-Ivy library.</p>\n\n</div>\n<p translation-result=\"on\">由于此过程发生在应用构建期间，所以它使用相同版本的 Angular 编译器，从而确保应用及其所有库都使用单一版本的 Angular。</p><p translation-origin=\"off\">Because this process happens during the application build, it uses the same version of the Angular compiler, ensuring that the application and all of its libraries use a single version of Angular.</p>\n\n<p translation-result=\"on\">如果打算将库发布到 npm，请通过在 <code>tsconfig.prod.json</code> 的 <code>\"compilationMode\": \"partial\"</code> 来使用部分 Ivy 代码进行编译。这种部分格式在不同版本的 Angular 之间是稳定的，因此可以安全地发布到 npm。</p><p translation-origin=\"off\">If you intend to publish your library to npm, compile with partial-Ivy code by setting <code>\"compilationMode\": \"partial\"</code> in <code>tsconfig.prod.json</code>.\nThis partial format is stable between different versions of Angular, so is safe to publish to npm.</p>\n\n<p translation-result=\"on\">如果要发布到 npm，请避免使用完全 Ivy 代码来编译库，因为生成的 Ivy 指令不属于 Angular 公共 API 的一部分，因此在补丁版本之间可能会有所不同。</p><p translation-origin=\"off\">Avoid compiling libraries with full-Ivy code if you are publishing to npm because the generated Ivy instructions are not part of Angular's public API, and so might change between patch versions.</p>\n\n<p translation-result=\"on\">部分 Ivy 代码与 View Engine 向后不兼容。如果在 View Engine 应用中使用该库，则必须通过在 <code>tsconfig.json</code> 文件中设置 <code>\"enableIvy\": false</code>。</p><p translation-origin=\"off\">Partial-Ivy code is not backward compatible with View Engine.\nIf you use the library in a View Engine application, you must compile the library into the View Engine format by setting <code>\"enableIvy\": false</code> in the <code>tsconfig.json</code> file.</p>\n\n<p translation-result=\"on\">Ivy 应用仍然可以使用 View Engine 格式，因为 Angular 兼容性编译器（<code>ngcc</code>）可以在 Angular CLI 中将其转换为 Ivy。</p><p translation-origin=\"off\">Ivy applications can still consume the View Engine format because the Angular compatibility compiler, or <code>ngcc</code>, can convert it to Ivy in the Angular CLI.</p>\n\n<p translation-result=\"on\">如果你以前从未在 npm 中发布过软件包，则必须创建一个用户帐户。在<a href=\"https://docs.npmjs.com/getting-started/publishing-npm-packages\">发布 npm 程序包</a>中了解更多信息。</p><p translation-origin=\"off\">If you've never published a package in npm before, you must create a user account. Read more in <a href=\"https://docs.npmjs.com/getting-started/publishing-npm-packages\">Publishing npm Packages</a>.</p>\n\n<h2 id=\"consuming-partial-ivy-code-outside-the-angular-cli\" translation-result=\"on\">在 Angular CLI 之外使用部分 Ivy 代码<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#consuming-partial-ivy-code-outside-the-angular-cli\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"consuming-partial-ivy-code-outside-the-angular-cli\">Consuming partial-Ivy code outside the Angular CLI<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#consuming-partial-ivy-code-outside-the-angular-cli\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">应用将 npm 中的许多 Angular 库安装到其 <code>node_modules</code> 目录中。但是，这些库中的代码不能与已编译的应用直接捆绑在一起，因为它尚未完全编译。要完成编译，可以使用 Angular 链接器。</p><p translation-origin=\"off\">An application installs many Angular libraries from npm into its <code>node_modules</code> directory.\nHowever, the code in these libraries cannot be bundled directly along with the built application as it is not fully compiled.\nTo finish compilation, you can use the Angular linker.</p>\n\n<p translation-result=\"on\">对于不使用 Angular CLI 的应用，链接器可作为 Babel 插件使用。<code>@angular/compiler-cli/linker/babel</code> 模块来使用 Babel 插件，以将其并入你的构建中。比如你可以将 <code>babel-loader</code> 插件注册为链接器，以将其集成到自定义 Webpack 构建中。</p><p translation-origin=\"off\">For applications that don't use the Angular CLI, the linker is available as a Babel plugin.\nYou can use the Babel plugin using the module <code>@angular/compiler-cli/linker/babel</code> to incorporate into your builds.\nFor example, you can integrate the plugin into a custom Webpack build by registering the linker as a plugin for <code>babel-loader</code>.</p>\n\n<p translation-result=\"on\">以前，如果你运行 <code>yarn install</code> 或 <code>npm install</code>，则必须重新运行 <code>ngcc</code>。现在，无论其他 npm 操作如何，链接器都只需要对库处理一次。</p><p translation-origin=\"off\">Previously, if you ran <code>yarn install</code> or <code>npm install</code> you had to re-run <code>ngcc</code>.\nNow, libraries only need to be processed by the linker a single time, regardless of other npm operations.</p>\n\n<p translation-result=\"on\">Angular 链接器的 Babel 插件支持构建缓存，这意味着链接器只需一次处理库，而与其他 npm 操作无关。</p><p translation-origin=\"off\">The Angular linker Babel plugin supports build caching, meaning that libraries only need to be processed by the linker a single time, regardless of other npm operations.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">Angular CLI 自动集成了链接器插件，因此，如果你这个库的使用方也在使用 CLI，则他们可以从 npm 安装 Ivy 原生库，而无需任何其他配置。</p><p translation-origin=\"off\">The Angular CLI integrates the linker plugin automatically, so if consumers of your library are using the CLI, they can install Ivy-native libraries from npm without any additional configuration.</p>\n\n</div>\n\n  \n</div>\n\n\n<!-- links to this doc:\n - guide/cli-builder\n - guide/file-structure\n - guide/glossary\n - guide/ivy\n - guide/libraries\n - guide/updating-to-version-12\n-->\n<!-- links from this doc:\n - api/router/RouterModule\n - guide/aot-compiler\n - guide/architecture-services#providing-services\n - guide/creating-libraries#building-and-rebuilding-your-library\n - guide/creating-libraries#building-libraries-with-ivy\n - guide/creating-libraries#consuming-partial-ivy-code-outside-the-angular-cli\n - guide/creating-libraries#creating-libraries\n - guide/creating-libraries#ensuring-library-version-compatibility\n - guide/creating-libraries#getting-started\n - guide/creating-libraries#integrating-with-the-cli-using-code-generation-schematics\n - guide/creating-libraries#ivy-libraries\n - guide/creating-libraries#linked-libraries\n - guide/creating-libraries#managing-assets-in-a-library\n - guide/creating-libraries#publishing-your-library\n - guide/creating-libraries#refactoring-parts-of-an-app-into-a-library\n - guide/creating-libraries#transitioning-libraries-to-partial-ivy-format\n - guide/creating-libraries#use-typescript-path-mapping-for-peer-dependencies\n - guide/creating-libraries#using-your-own-library-in-apps\n - guide/file-structure\n - guide/file-structure#library-project-files\n - guide/file-structure#multiple-projects\n - guide/glossary#schematic\n - guide/lightweight-injection-tokens\n - guide/schematics\n - guide/schematics-for-libraries\n - guide/singleton-services\n - https://docs.npmjs.com/cli/link\n - https://docs.npmjs.com/getting-started/publishing-npm-packages\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/creating-libraries.md?message=docs%3A%20请简述你的修改...\n - https://github.com/ng-packagr/ng-packagr/blob/master/README.md\n - https://github.com/ng-packagr/ng-packagr/blob/master/docs/copy-assets.md\n - https://github.com/ng-packagr/ng-packagr/blob/master/docs/embed-assets-css.md\n - https://material.angular.cn/cdk/layout/overview#breakpointobserver\n - https://material.angular.cn/components/sidenav/overview\n - https://material.angular.cn/components/toolbar/overview\n - https://material.angular.cn/guide/schematics#navigation-schematic\n - https://material.angular.io/cdk/layout/overview#breakpointobserver\n - https://material.angular.io/components/sidenav/overview\n - https://material.angular.io/components/toolbar/overview\n - https://material.angular.io/guide/schematics#navigation-schematic\n-->"
}