{
  "id": "guide/lightweight-injection-tokens",
  "title": "Optimizing client app size with lightweight injection tokens",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/lightweight-injection-tokens.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"optimizing-client-app-size-with-lightweight-injection-tokens\">Optimizing client app size with lightweight injection tokens<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#optimizing-client-app-size-with-lightweight-injection-tokens\"><i class=\"material-icons\">link</i></a></h1>\n<p>This page provides a conceptual overview of a dependency injection technique that is recommended for library developers.\nDesigning your library with <em>lightweight injection tokens</em> helps optimize the bundle size of client applications that use your library.</p>\n<p>You can manage the dependency structure among your components and injectable services to optimize bundle size by using <a href=\"guide/dependency-injection-providers#tree-shakable-providers\">tree-shakable providers</a>.\nThis normally ensures that if a provided component or service is never actually used by the app, the compiler can eliminate its code from the bundle.</p>\n<p>However, due to the way Angular stores injection tokens, it is possible that such an unused component or service can end up in the bundle anyway.\nThis page describes a dependency-injection design pattern that supports proper tree-shaking by using lightweight injection tokens.</p>\n<p>The lightweight injection token design pattern is especially important for library developers. It ensures that when an application uses only some of your library's capabilities, the unused code can be eliminated from the client's app bundle.</p>\n<p>When an application uses your library, there might be some services that your library supplies which the client app doesn't use.\nIn this case, the app developer should expect that service to be tree-shaken, and not contribute to the size of the compiled app.\nBecause the application developer cannot know about or remedy a tree-shaking problem in the library, it is the responsibility of the library developer to do so.\nTo prevent the retention of unused components, your library should use the lightweight injection token design pattern.</p>\n<h2 id=\"when-tokens-are-retained\">When tokens are retained<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#when-tokens-are-retained\"><i class=\"material-icons\">link</i></a></h2>\n<p>To better explain the condition under which token retention occurs, consider a library that provides a library-card component, which contains a body and can contain an optional header.</p>\n<code-example>\n&#x3C;lib-card>\n  &#x3C;lib-header>...&#x3C;/lib-header>\n&#x3C;/lib-card>\n</code-example>\n<p>In a likely implementation, the <code>&#x3C;lib-card></code> component uses <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>()</code> or <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a>()</code> to obtain <code>&#x3C;lib-header></code> and <code>&#x3C;lib-body></code>, as in the following.</p>\n<code-example>\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-header',\n  ...,\n})\nclass LibHeaderComponent {}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-card',\n  ...,\n})\nclass LibCardComponent {\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderComponent)\n  header: LibHeaderComponent|null = null;\n}\n</code-example>\n<p>Because <code>&#x3C;lib-header></code> is optional, the element can appear in the template in its minimal form,\n<code>&#x3C;lib-card>&#x3C;/lib-card></code>.\nIn this case, <code>&#x3C;lib-header></code> is not used and you would expect it to be tree-shaken, but that is not what happens.\nThis is because <code>LibCardComponent</code> actually contains two references to the <code>LibHeaderComponent</code>.</p>\n<p><code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderComponent) header: LibHeaderComponent;</code></p>\n<ul>\n<li>\n<p>One of these reference is in the <em>type position</em>-- that is, it specifies <code>LibHeaderComponent</code> as a type: <code>header: LibHeaderComponent;</code>.</p>\n</li>\n<li>\n<p>The other reference is in the <em>value position</em>-- that is, LibHeaderComponent is the value of the <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>()</code> parameter decorator: <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderComponent)</code>.</p>\n</li>\n</ul>\n<p>The compiler handles token references in these positions differently.</p>\n<ul>\n<li>\n<p>The compiler erases <em>type position</em> references after conversion from TypeScript, so they have no impact on tree-shaking.</p>\n</li>\n<li>\n<p>The compiler must retain <em>value position</em>  references at runtime, which prevents the component from being tree-shaken.</p>\n</li>\n</ul>\n<p>In the example, the compiler retains the <code>LibHeaderComponent</code> token that occurs in the value position, which prevents the referenced component from being tree-shaken, even if the application developer does not actually use <code>&#x3C;lib-header></code> anywhere.\nIf <code>LibHeaderComponent</code> is large (code, template, and styles), including it unnecessarily can significantly increase the size of the client application.</p>\n<h2 id=\"when-to-use-the-lightweight-injection-token-pattern\">When to use the lightweight injection token pattern<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#when-to-use-the-lightweight-injection-token-pattern\"><i class=\"material-icons\">link</i></a></h2>\n<p>The tree-shaking problem arises when a component is used as an injection token.\nThere are two cases when that can happen.</p>\n<ul>\n<li>The token is used in the value position of a <a href=\"guide/lifecycle-hooks#using-aftercontent-hooks\" title=\"See more about using content queries.\">content query</a>.</li>\n<li>The token is used as a type specifier for constructor injection.</li>\n</ul>\n<p>In the following example, both uses of the <code>OtherComponent</code> token cause retention of <code>OtherComponent</code> (that is, prevent it from being tree-shaken when it is not used).</p>\n<code-example>\nclass MyComponent {\n  constructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() other: OtherComponent) {}\n\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(OtherComponent)\n  other: OtherComponent|null;\n}\n</code-example>\n<p>Although tokens used only as type specifiers are removed when converted to JavaScript, all tokens used for dependency injection are needed at runtime.\nThese effectively change <code>constructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() other: OtherComponent)</code> to <code>constructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(OtherComponent) other)</code>. The token is now in a value position, and causes the tree shaker to retain the reference.</p>\n<div class=\"alert is helpful\">\n<p>For all services, a library should use <a href=\"guide/dependency-injection-providers#tree-shakable-providers\">tree-shakable providers</a>, providing dependencies at the root level rather than in component constructors.</p>\n</div>\n<h2 id=\"using-lightweight-injection-tokens\">Using lightweight injection tokens<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#using-lightweight-injection-tokens\"><i class=\"material-icons\">link</i></a></h2>\n<p>The lightweight injection token design pattern consists of using a small abstract class as an injection token, and providing the actual implementation at a later stage.\nThe abstract class is retained (not tree-shaken), but it is small and has no material impact on the application size.</p>\n<p>The following example shows how this works for the <code>LibHeaderComponent</code>.</p>\n<code-example>\nabstract class LibHeaderToken {}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-header',\n  providers: [\n    {provide: LibHeaderToken, useExisting: LibHeaderComponent}\n  ]\n  ...,\n})\nclass LibHeaderComponent extends LibHeaderToken {}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-card',\n  ...,\n})\nclass LibCardComponent {\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderToken) header: LibHeaderToken|null = null;\n}\n</code-example>\n<p>In this example, the <code>LibCardComponent</code> implementation no longer refers to <code>LibHeaderComponent</code> in either the type position or the value position.\nThis allows full tree shaking of <code>LibHeaderComponent</code> to take place.\nThe <code>LibHeaderToken</code> is retained, but it is only a class declaration, with no concrete implementation. It is small and does not materially impact the application size when retained after compilation.</p>\n<p>Instead, <code>LibHeaderComponent</code> itself implements the abstract <code>LibHeaderToken</code> class. You can safely use that token as the provider in the component definition, allowing Angular to correctly inject the concrete type.</p>\n<p>To summarize, the lightweight injection token pattern consists of the following.</p>\n<ol>\n<li>A lightweight injection token that is represented as an abstract class.</li>\n<li>A component definition that implements the abstract class.</li>\n<li>Injection of the lightweight pattern, using <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>()</code> or <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a>()</code>.</li>\n<li>A provider in the implementation of the lightweight injection token which associates the lightweight injection token with the implementation.</li>\n</ol>\n<h3 id=\"use-the-lightweight-injection-token-for-api-definition\">Use the lightweight injection token for API definition<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#use-the-lightweight-injection-token-for-api-definition\"><i class=\"material-icons\">link</i></a></h3>\n<p>A component that injects a lightweight injection token might need to invoke a method in the injected class.\nBecause the token is now an abstract class, and the injectable component implements that class, you must also declare an abstract method in the abstract lightweight injection token class.\nThe implementation of the method (with all of its code overhead) resides in the injectable component that can be tree-shaken.\nThis allows the parent to communicate with the child (if it is present) in a type-safe manner.</p>\n<p>For example, the <code>LibCardComponent</code> now queries<code>LibHeaderToken</code> rather than <code>LibHeaderComponent</code>.\nThe following example shows how the pattern allows <code>LibCardComponent</code> to communicate with the <code>LibHeaderComponent</code> without actually referring to <code>LibHeaderComponent</code>.</p>\n<code-example>\nabstract class LibHeaderToken {\n  abstract doSomething(): void;\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-header',\n  providers: [\n    {provide: LibHeaderToken, useExisting: LibHeader}\n  ]\n  ...,\n})\nclass LibHeaderComponent extends LibHeaderToken {\n  doSomething(): void {\n    // Concrete implementation of `doSomething`\n  }\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-card',\n  ...,\n})\nclass LibCardComponent implement <a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a> {\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderToken)\n  header: LibHeaderToken|null = null;\n\n  ngAfterContentInit(): void {\n    this.header &#x26;&#x26; this.header.doSomething();\n  }\n}\n</code-example>\n<p>In this example the parent  queries the token to obtain the child component, and stores the resulting component reference if it is present.\nBefore calling a method in the child, the parent component checks to see if the child component is present.\nIf the child component has been tree-shaken, there is no runtime reference to it, and no call to its method.</p>\n<h3 id=\"naming-your-lightweight-injection-token\">Naming your lightweight injection token<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#naming-your-lightweight-injection-token\"><i class=\"material-icons\">link</i></a></h3>\n<p>Lightweight injection tokens are only useful with components. The Angular style guide suggests that you name components using the \"Component\" suffix. The example \"LibHeaderComponent\" follows this convention.</p>\n<p>To maintain the relationship between the component and its token while still distinguishing between them, the recommended style is to use the component base name with the suffix \"Token\" to name your lightweight injection tokens: \"LibHeaderToken\".</p>\n\n</div>\n\n<!-- links to this doc:\n - guide/creating-libraries\n-->\n<!-- links from this doc:\n - api/core/AfterContentInit\n - api/core/Component\n - api/core/ContentChild\n - api/core/ContentChildren\n - api/core/Inject\n - api/core/Optional\n - guide/dependency-injection-providers#tree-shakable-providers\n - guide/lifecycle-hooks#using-aftercontent-hooks\n - guide/lightweight-injection-tokens#naming-your-lightweight-injection-token\n - guide/lightweight-injection-tokens#optimizing-client-app-size-with-lightweight-injection-tokens\n - guide/lightweight-injection-tokens#use-the-lightweight-injection-token-for-api-definition\n - guide/lightweight-injection-tokens#using-lightweight-injection-tokens\n - guide/lightweight-injection-tokens#when-to-use-the-lightweight-injection-token-pattern\n - guide/lightweight-injection-tokens#when-tokens-are-retained\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/lightweight-injection-tokens.md?message=docs%3A%20请简述你的修改...\n-->"
}