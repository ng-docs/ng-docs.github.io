{"id":"guide/testing-services","title":"Testing services","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/angular/angular-cn/edit/cn/aio/content/guide/testing-services.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"testing-services\" translation-result=\"on\">测试服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-services\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Testing services<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-services\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">为了检查你的服务是否正常工作，你可以专门为它们编写测试。</p><p translation-origin=\"off\">To check that your services are working as you intend, you can write tests specifically for them.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">如果你要试验本指南中所讲的应用，请<live-example name=\"testing\" nodownload=\"\">在浏览器中运行它</live-example>或<live-example name=\"testing\" downloadonly=\"\">下载并在本地运行它</live-example>。</p><p translation-origin=\"off\">If you'd like to experiment with the application that this guide describes, <live-example name=\"testing\" nodownload=\"\">run it in your browser</live-example> or <live-example name=\"testing\" downloadonly=\"\">download and run it locally</live-example>.</p>\n\n</div>\n<p translation-result=\"on\">服务往往是最容易进行单元测试的文件。下面是一些针对 <code>ValueService</code> 的同步和异步单元测试，甚至不需要 Angular 测试工具的帮助。</p><p translation-origin=\"off\">Services are often the smoothest files to unit test.\nHere are some synchronous and asynchronous unit tests of the <code>ValueService</code> written without assistance from Angular testing utilities.</p>\n\n<code-example header=\"app/demo/demo.spec.ts\" path=\"testing/src/app/demo/demo.spec.ts\" region=\"ValueService\">\n// Straight Jasmine testing without Angular's testing support\ndescribe('ValueService', () =&gt; {\n  let service: ValueService;\n  beforeEach(() =&gt; { service = new ValueService(); });\n\n  it('#getValue should return real value', () =&gt; {\n    expect(service.getValue()).toBe('real value');\n  });\n\n  it('#getObservableValue should return value from observable',\n    (done: DoneFn) =&gt; {\n    service.getObservableValue().subscribe(value =&gt; {\n      expect(value).toBe('observable value');\n      done();\n    });\n  });\n\n  it('#getPromiseValue should return value from a promise',\n    (done: DoneFn) =&gt; {\n    service.getPromiseValue().then(value =&gt; {\n      expect(value).toBe('promise value');\n      done();\n    });\n  });\n});\n\n</code-example>\n<p><a id=\"services-with-dependencies\"></a></p>\n<h2 id=\"services-with-dependencies\" translation-result=\"on\">有依赖的服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#services-with-dependencies\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Services with dependencies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#services-with-dependencies\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">服务通常依赖于 Angular 在构造函数中注入的其它服务。在很多情况下，调用服务的构造函数时，很容易手动创建和<em>注入</em>这些依赖。</p><p translation-origin=\"off\">Services often depend on other services that Angular injects into the constructor.\nIn many cases, you can create and <em>inject</em> these dependencies by hand while calling the service's constructor.</p>\n\n<p translation-result=\"on\"><code>MasterService</code> 就是一个简单的例子：</p><p translation-origin=\"off\">The <code>MasterService</code> is a simple example:</p>\n\n<code-example header=\"app/demo/demo.ts\" path=\"testing/src/app/demo/demo.ts\" region=\"MasterService\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class MasterService {\n  constructor(private valueService: ValueService) { }\n  getValue() { return this.valueService.getValue(); }\n}\n\n</code-example>\n<p translation-result=\"on\"><code>MasterService</code> 只把它唯一的方法 <code>getValue</code> 委托给了所注入的 <code>ValueService</code>。</p><p translation-origin=\"off\"><code>MasterService</code> delegates its only method, <code>getValue</code>, to the injected <code>ValueService</code>.</p>\n\n<p translation-result=\"on\">这里有几种测试方法。</p><p translation-origin=\"off\">Here are several ways to test it.</p>\n\n<code-example header=\"app/demo/demo.spec.ts\" path=\"testing/src/app/demo/demo.spec.ts\" region=\"MasterService\">\ndescribe('MasterService without Angular testing support', () =&gt; {\n  let masterService: MasterService;\n\n  it('#getValue should return real value from the real service', () =&gt; {\n    masterService = new MasterService(new ValueService());\n    expect(masterService.getValue()).toBe('real value');\n  });\n\n  it('#getValue should return faked value from a fakeService', () =&gt; {\n    masterService = new MasterService(new FakeValueService());\n    expect(masterService.getValue()).toBe('faked service value');\n  });\n\n  it('#getValue should return faked value from a fake object', () =&gt; {\n    const fake =  { getValue: () =&gt; 'fake value' };\n    masterService = new MasterService(fake as ValueService);\n    expect(masterService.getValue()).toBe('fake value');\n  });\n\n  it('#getValue should return stubbed value from a spy', () =&gt; {\n    // create `getValue` spy on an object representing the ValueService\n    const valueServiceSpy =\n      jasmine.createSpyObj('ValueService', ['getValue']);\n\n    // set the value to return when the `getValue` spy is called.\n    const stubValue = 'stub value';\n    valueServiceSpy.getValue.and.returnValue(stubValue);\n\n    masterService = new MasterService(valueServiceSpy);\n\n    expect(masterService.getValue())\n      .withContext('service returned stub value')\n      .toBe(stubValue);\n    expect(valueServiceSpy.getValue.calls.count())\n      .withContext('spy method was called once')\n      .toBe(1);\n    expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)\n      .toBe(stubValue);\n  });\n});\n\n</code-example>\n<p translation-result=\"on\">第一个测试使用 <code>new</code> 创建了一个 <code>ValueService</code>，并把它传给了 <code>MasterService</code> 的构造函数。</p><p translation-origin=\"off\">The first test creates a <code>ValueService</code> with <code>new</code> and passes it to the <code>MasterService</code> constructor.</p>\n\n<p translation-result=\"on\">然而，注入真实服务很难工作良好，因为大多数被依赖的服务都很难创建和控制。</p><p translation-origin=\"off\">However, injecting the real service rarely works well as most dependent services are difficult to create and control.</p>\n\n<p translation-result=\"on\">相反，可以模拟依赖、使用仿制品，或者在相关的服务方法上<a href=\"https://jasmine.github.io/tutorials/your_first_suite#section-Spies\">创建一个测试间谍</a>。</p><p translation-origin=\"off\">Instead, mock the dependency, use a dummy value, or create a <a href=\"https://jasmine.github.io/tutorials/your_first_suite#section-Spies\">spy</a> on the pertinent service method.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">我更喜欢用测试间谍，因为它们通常是模拟服务的最佳途径。</p><p translation-origin=\"off\">Prefer spies as they are usually the best way to mock services.</p>\n\n</div>\n<p translation-result=\"on\">这些标准的测试技巧非常适合对服务进行单独测试。</p><p translation-origin=\"off\">These standard testing techniques are great for unit testing services in isolation.</p>\n\n<p translation-result=\"on\">但是，你几乎总是使用 Angular 依赖注入机制来将服务注入到应用类中，你应该有一些测试来体现这种使用模式。Angular 测试实用工具可以让你轻松调查这些注入服务的行为。</p><p translation-origin=\"off\">However, you almost always inject services into application classes using Angular dependency injection and you should have tests that reflect that usage pattern.\nAngular testing utilities make it straightforward to investigate how injected services behave.</p>\n\n<h2 id=\"testing-services-with-the-testbed\" translation-result=\"on\">使用 <em>TestBed</em> 测试服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/core/testing/TestBed\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Testing services with the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-services-with-the-testbed\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你的应用依靠 Angular 的<a href=\"guide/dependency-injection\">依赖注入（DI）</a>来创建服务。当服务有依赖时，DI 会查找或创建这些被依赖的服务。如果该被依赖的服务还有自己的依赖，DI 也会查找或创建它们。</p><p translation-origin=\"off\">Your application relies on Angular <a href=\"guide/dependency-injection\">dependency injection (DI)</a> to create services.\nWhen a service has a dependent service, DI finds or creates that dependent service.\nAnd if that dependent service has its own dependencies, DI finds-or-creates them as well.</p>\n\n<p translation-result=\"on\">作为服务的<em>消费者</em>，你不应该关心这些。你不应该关心构造函数参数的顺序或它们是如何创建的。</p><p translation-origin=\"off\">As service <em>consumer</em>, you don't worry about any of this.\nYou don't worry about the order of constructor arguments or how they're created.</p>\n\n<p translation-result=\"on\">作为服务的<em>测试人员</em>，你至少要考虑第一层的服务依赖，但当你用 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 测试实用工具来提供和创建服务时，你<em>可以</em>让 Angular DI 来创建服务并处理构造函数的参数顺序。</p><p translation-origin=\"off\">As a service <em>tester</em>, you must at least think about the first level of service dependencies but you <em>can</em> let Angular DI do the service creation and deal with constructor argument order when you use the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> testing utility to provide and create services.</p>\n\n<p><a id=\"testbed\"></a></p>\n<h2 id=\"angular-testbed\">Angular <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#angular-testbed\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-result=\"on\"><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 是 Angular 测试实用工具中最重要的。<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 创建了一个动态构造的 Angular <em>测试</em>模块，用来模拟一个 Angular 的 <a href=\"guide/ngmodules\">@NgModule</a>。</p><p translation-origin=\"off\">The <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> is the most important of the Angular testing utilities.\nThe <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> creates a dynamically-constructed Angular <em>test</em> module that emulates an Angular <a href=\"guide/ngmodules\">@NgModule</a>.</p>\n\n<p translation-result=\"on\"><code>TestBed.configureTestingModule()</code> 方法接受一个元数据对象，它可以拥有<a href=\"guide/ngmodules\">@NgModule</a>的大部分属性。</p><p translation-origin=\"off\">The <code>TestBed.configureTestingModule()</code> method takes a metadata object that can have most of the properties of an <a href=\"guide/ngmodules\">@NgModule</a>.</p>\n\n<p translation-result=\"on\">要测试某个服务，你可以在元数据属性 <code>providers</code> 中设置一个要测试或模拟的服务数组。</p><p translation-origin=\"off\">To test a service, you set the <code>providers</code> metadata property with an array of the services that you'll test or mock.</p>\n\n<code-example header=\"app/demo/demo.testbed.spec.ts (provide ValueService in beforeEach)\" path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-before-each\">\nlet service: ValueService;\n\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({ providers: [ValueService] });\n});\n\n</code-example>\n<p translation-result=\"on\">将服务类作为参数调用 <code>TestBed.inject()</code>，将它注入到测试中。</p><p translation-origin=\"off\">Then inject it inside a test by calling <code>TestBed.inject()</code> with the service class as the argument.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n<code>TestBed.get()</code> 已在 Angular 9 中弃用。为了帮助减少重大变更，Angular 引入了一个名为 <code>TestBed.inject()</code> 的新函数，你可以改用它。关于删除 <code>TestBed.get()</code> 的信息，请参阅<a href=\"guide/deprecations#index\">弃用索引</a>中的条目。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\n<code>TestBed.get()</code> was deprecated as of Angular version 9.\nTo help minimize breaking changes, Angular introduces a new function called <code>TestBed.inject()</code>, which you should use instead.\nFor information on the removal of <code>TestBed.get()</code>, see its entry in the <a href=\"guide/deprecations#index\">Deprecations index</a>.</p>\n\n</div>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-inject-it\">\nit('should use ValueService', () =&gt; {\n  service = TestBed.inject(ValueService);\n  expect(service.getValue()).toBe('real value');\n});\n\n</code-example>\n<p translation-result=\"on\">或者，如果你喜欢把这个服务作为设置代码的一部分进行注入，也可以在 <code>beforeEach()</code> 中做。</p><p translation-origin=\"off\">Or inside the <code>beforeEach()</code> if you prefer to inject the service as part of your setup.</p>\n\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-inject-before-each\">\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({ providers: [ValueService] });\n  service = TestBed.inject(ValueService);\n});\n\n</code-example>\n<p translation-result=\"on\">测试带依赖的服务时，需要在 <code>providers</code> 数组中提供 mock。</p><p translation-origin=\"off\">When testing a service with a dependency, provide the mock in the <code>providers</code> array.</p>\n\n<p translation-result=\"on\">在下面的例子中，mock 是一个间谍对象。</p><p translation-origin=\"off\">In the following example, the mock is a spy object.</p>\n\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"master-service-before-each\">\nlet masterService: MasterService;\nlet valueServiceSpy: jasmine.SpyObj&lt;ValueService&gt;;\n\nbeforeEach(() =&gt; {\n  const spy = jasmine.createSpyObj('ValueService', ['getValue']);\n\n  TestBed.configureTestingModule({\n    // Provide both the service-to-test and its (spy) dependency\n    providers: [\n      MasterService,\n      { provide: ValueService, useValue: spy }\n    ]\n  });\n  // <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> both the service-to-test and its (spy) dependency\n  masterService = TestBed.inject(MasterService);\n  valueServiceSpy = TestBed.inject(ValueService) as jasmine.SpyObj&lt;ValueService&gt;;\n});\n\n</code-example>\n<p translation-result=\"on\">该测试会像以前一样使用该间谍。</p><p translation-origin=\"off\">The test consumes that spy in the same way it did earlier.</p>\n\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"master-service-it\">\nit('#getValue should return stubbed value from a spy', () =&gt; {\n  const stubValue = 'stub value';\n  valueServiceSpy.getValue.and.returnValue(stubValue);\n\n  expect(masterService.getValue())\n    .withContext('service returned stub value')\n    .toBe(stubValue);\n  expect(valueServiceSpy.getValue.calls.count())\n    .withContext('spy method was called once')\n    .toBe(1);\n  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)\n    .toBe(stubValue);\n});\n\n</code-example>\n<p><a id=\"no-before-each\"></a></p>\n<h2 id=\"testing-without-beforeeach\" translation-result=\"on\">没有 <code>beforeEach()</code> 的测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-without-beforeeach\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Testing without <code>beforeEach()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-without-beforeeach\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">本指南中的大多数测试套件都会调用 <code>beforeEach()</code> 来为每一个 <code>it()</code> 测试设置前置条件，并依赖 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 来创建类和注入服务。</p><p translation-origin=\"off\">Most test suites in this guide call <code>beforeEach()</code> to set the preconditions for each <code>it()</code> test and rely on the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> to create classes and inject services.</p>\n\n<p translation-result=\"on\">还有另一种测试，它们从不调用 <code>beforeEach()</code>，而是更喜欢显式地创建类，而不是使用 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>。</p><p translation-origin=\"off\">There's another school of testing that never calls <code>beforeEach()</code> and prefers to create classes explicitly rather than use the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>.</p>\n\n<p translation-result=\"on\">你可以用这种风格重写 <code>MasterService</code> 中的一个测试。</p><p translation-origin=\"off\">Here's how you might rewrite one of the <code>MasterService</code> tests in that style.</p>\n\n<p translation-result=\"on\">首先，在 <em>setup</em> 函数中放入可供复用的预备代码，而不用 <code>beforeEach()</code>。</p><p translation-origin=\"off\">Begin by putting re-usable, preparatory code in a <em>setup</em> function instead of <code>beforeEach()</code>.</p>\n\n<code-example header=\"app/demo/demo.spec.ts (setup)\" path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-setup\">\nfunction setup() {\n  const valueServiceSpy =\n    jasmine.createSpyObj('ValueService', ['getValue']);\n  const stubValue = 'stub value';\n  const masterService = new MasterService(valueServiceSpy);\n\n  valueServiceSpy.getValue.and.returnValue(stubValue);\n  return { masterService, stubValue, valueServiceSpy };\n}\n\n</code-example>\n<p translation-result=\"on\"><code>setup()</code> 函数返回一个包含测试可能引用的变量（如 <code>masterService</code>）的对象字面量。你并没有在 <code>describe()</code> 的函数体中定义<em>半全局</em>变量（比如 <code>let masterService: MasterService</code>）。</p><p translation-origin=\"off\">The <code>setup()</code> function returns an object literal with the variables, such as <code>masterService</code>, that a test might reference.\nYou don't define <em>semi-global</em> variables (for example, <code>let masterService: MasterService</code>) in the body of the <code>describe()</code>.</p>\n\n<p translation-result=\"on\">然后，每个测试都会在第一行调用 <code>setup()</code>，然后继续执行那些操纵被测主体和断言期望值的步骤。</p><p translation-origin=\"off\">Then each test invokes <code>setup()</code> in its first line, before continuing with steps that manipulate the test subject and assert expectations.</p>\n\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-test\">\nit('#getValue should return stubbed value from a spy', () =&gt; {\n  const { masterService, stubValue, valueServiceSpy } = setup();\n  expect(masterService.getValue())\n    .withContext('service returned stub value')\n    .toBe(stubValue);\n  expect(valueServiceSpy.getValue.calls.count())\n    .withContext('spy method was called once')\n    .toBe(1);\n  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)\n    .toBe(stubValue);\n});\n\n</code-example>\n<p translation-result=\"on\">请注意测试如何使用<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\"><em>解构赋值</em></a>来提取它需要的设置变量。</p><p translation-origin=\"off\">Notice how the test uses <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\"><em>destructuring assignment</em></a> to extract the setup variables that it needs.</p>\n\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-setup-call\">\nconst { masterService, stubValue, valueServiceSpy } = setup();\n\n</code-example>\n<p translation-result=\"on\">许多开发人员都觉得这种方法比传统的 <code>beforeEach()</code> 风格更清晰明了。</p><p translation-origin=\"off\">Many developers feel this approach is cleaner and more explicit than the traditional <code>beforeEach()</code> style.</p>\n\n<p translation-result=\"on\">虽然这个测试指南遵循传统的样式，并且默认的<a href=\"https://github.com/angular/angular-cli\">CLI 原理图</a>会生成带有 <code>beforeEach()</code> 和 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的测试文件，但你可以在自己的项目中采用<em>这种替代方式</em>。</p><p translation-origin=\"off\">Although this testing guide follows the traditional style and the default <a href=\"https://github.com/angular/angular-cli\">CLI schematics</a> generate test files with <code>beforeEach()</code> and <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>, feel free to adopt <em>this alternative approach</em> in your own projects.</p>\n\n<h2 id=\"testing-http-services\" translation-result=\"on\">测试 HTTP 服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-http-services\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Testing HTTP services<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-http-services\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">对远程服务器进行 HTTP 调用的数据服务通常会注入并委托给 Angular 的 <a href=\"guide/http\"><code>HttpClient</code></a>服务进行 XHR 调用。</p><p translation-origin=\"off\">Data services that make HTTP calls to remote servers typically inject and delegate to the Angular <a href=\"guide/http\"><code>HttpClient</code></a> service for XHR calls.</p>\n\n<p translation-result=\"on\">你可以测试一个注入了 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 间谍的数据服务，就像测试所有带依赖的服务一样。</p><p translation-origin=\"off\">You can test a data service with an injected <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> spy as you would test any service with a dependency.</p>\n\n<code-example header=\"app/model/hero.service.spec.ts (tests with spies)\" path=\"testing/src/app/model/hero.service.spec.ts\" region=\"test-with-spies\">\nlet httpClientSpy: jasmine.SpyObj&lt;<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>&gt;;\nlet heroService: HeroService;\n\nbeforeEach(() =&gt; {\n  // TODO: spy on other methods too\n  httpClientSpy = jasmine.createSpyObj('<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>', ['get']);\n  heroService = new HeroService(httpClientSpy);\n});\n\nit('should return expected heroes (<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> called once)', (done: DoneFn) =&gt; {\n  const expectedHeroes: Hero[] =\n    [{ id: 1, name: 'A' }, { id: 2, name: 'B' }];\n\n  httpClientSpy.get.and.returnValue(asyncData(expectedHeroes));\n\n  heroService.getHeroes().subscribe({\n    next: heroes =&gt; {\n      expect(heroes)\n        .withContext('expected heroes')\n        .toEqual(expectedHeroes);\n      done();\n    },\n    error: done.fail\n  });\n  expect(httpClientSpy.get.calls.count())\n    .withContext('one call')\n    .toBe(1);\n});\n\nit('should return an error when the server returns a 404', (done: DoneFn) =&gt; {\n  const errorResponse = new <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>({\n    error: 'test 404 error',\n    status: 404, statusText: 'Not Found'\n  });\n\n  httpClientSpy.get.and.returnValue(asyncError(errorResponse));\n\n  heroService.getHeroes().subscribe({\n    next: heroes =&gt; done.fail('expected an error, not heroes'),\n    error: error  =&gt; {\n      expect(error.message).toContain('test 404 error');\n      done();\n    }\n  });\n});\n\n</code-example>\n<div class=\"alert is-important\">\n<p translation-result=\"on\"><code>HeroService</code> 方法会返回 <code>Observables</code>。你必须<em>订阅</em>一个可观察对象（a）让它执行，（b）断言该方法成功或失败。</p><p translation-origin=\"off\">The <code>HeroService</code> methods return <code>Observables</code>.\nYou must <em>subscribe</em> to an observable to (a) cause it to execute and (b) assert that the method succeeds or fails.</p>\n\n<p translation-result=\"on\"><code>subscribe()</code> 方法会接受成功（<code>next</code>）和失败（<code>error</code>）回调。确保你会同时提供<em>这两个</em>回调函数，以便捕获错误。如果不这样做就会产生一个异步的、没有被捕获的可观察对象的错误，测试运行器可能会把它归因于一个完全不相关的测试。</p><p translation-origin=\"off\">The <code>subscribe()</code> method takes a success (<code>next</code>) and fail (<code>error</code>) callback.\nMake sure you provide <em>both</em> callbacks so that you capture errors.\nNeglecting to do so produces an asynchronous uncaught observable error that the test runner will likely attribute to a completely different test.</p>\n\n</div>\n<h2 id=\"httpclienttestingmodule\"><code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#httpclienttestingmodule\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-result=\"on\">数据服务和 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 之间的扩展交互可能比较复杂，并且难以通过间谍进行模拟。</p><p translation-origin=\"off\">Extended interactions between a data service and the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> can be complex and difficult to mock with spies.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> 可以让这些测试场景更易于管理。</p><p translation-origin=\"off\">The <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> can make these testing scenarios more manageable.</p>\n\n<p translation-result=\"on\">虽然本指南附带的<em>范例代码</em>演示了 <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code>，但是本页面还是要引用一下 <a href=\"guide/http#testing-http-requests\">Http 指南</a>，那份指南中详细介绍了 <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code>。</p><p translation-origin=\"off\">While the <em>code sample</em> accompanying this guide demonstrates <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code>, this page defers to the <a href=\"guide/http#testing-http-requests\">Http guide</a>, which covers testing with the <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> in detail.</p>\n\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间： 2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/testing\n - guide/testing-components-basics\n-->\n<!-- links from this doc:\n - api/common/http/HttpClient\n - api/common/http/HttpErrorResponse\n - api/common/http/testing/HttpClientTestingModule\n - api/core/Inject\n - api/core/Injectable\n - api/core/testing/TestBed\n - guide/dependency-injection\n - guide/deprecations#index\n - guide/http\n - guide/http#testing-http-requests\n - guide/ngmodules\n - guide/testing-services#angular-testbed\n - guide/testing-services#httpclienttestingmodule\n - guide/testing-services#services-with-dependencies\n - guide/testing-services#testing-http-services\n - guide/testing-services#testing-services\n - guide/testing-services#testing-services-with-the-testbed\n - guide/testing-services#testing-without-beforeeach\n - guide/testing-services#使用-testbed-测试服务\n - guide/testing-services#有依赖的服务\n - guide/testing-services#没有-beforeeach-的测试\n - guide/testing-services#测试-http-服务\n - guide/testing-services#测试服务\n - https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\n - https://github.com/angular/angular-cli\n - https://github.com/angular/angular-cn/edit/cn/aio/content/guide/testing-services.md?message=docs%3A%20请简述你的修改...\n - https://jasmine.github.io/tutorials/your_first_suite#section-Spies\n-->"}