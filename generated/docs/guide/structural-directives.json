{
  "id": "guide/structural-directives",
  "title": "Writing structural directives",
  "contents": "\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/aio/aio/content/guide/structural-directives.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"writing-structural-directives\" translation-result=\"on\">编写结构型指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#writing-structural-directives\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"writing-structural-directives\">Writing structural directives<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#writing-structural-directives\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">本主题演示如何创建结构型指令，并提供有关指令如何工作、Angular 如何解释简写形式以及如何添加模板守卫属性以捕获模板类型错误的概念性信息。</p><p translation-origin=\"off\">This topic demonstrates how to create a structural directive and provides conceptual information on how directives work, how Angular interprets shorthand, and how to add template guard properties to catch template type errors.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">有关此页面描述的示例应用程序，请参见<live-example></live-example> 。</p><p translation-origin=\"off\">For the example application that this page describes, see the <live-example></live-example>.</p>\n\n</div>\n<p translation-result=\"on\">有关 Angular 的内置结构型指令（如 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> ， <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 和 <code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>）的更多信息，请参见<a href=\"guide/built-in-directives\">内置指令</a>。</p><p translation-origin=\"off\">For more information on Angular's built-in structural directives, such as <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>, <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code>, and <code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>, see <a href=\"guide/built-in-directives\">Built-in directives</a>.</p>\n\n<a id=\"unless\"></a>\n<h2 id=\"creating-a-structural-directive\" translation-result=\"on\">创建结构型指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#creating-a-structural-directive\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"creating-a-structural-directive\">Creating a structural directive<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#creating-a-structural-directive\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">本节将指导你创建 <code>UnlessDirective</code> 以及如何设置 <code>condition</code> 值。 <code>UnlessDirective</code> 与 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 相反，并且 <code>condition</code> 值可以设置为 <code>true</code> 或 <code>false</code> 。 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 为 <code>true</code> 时显示模板内容；而 <code>UnlessDirective</code> 在这个条件为 <code>false</code> 时显示内容。</p><p translation-origin=\"off\">This section guides you through creating an <code>UnlessDirective</code> and how to set <code>condition</code> values.\nThe <code>UnlessDirective</code> does the opposite of <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>, and <code>condition</code> values can be set to <code>true</code> or <code>false</code>.\n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> displays the template content when the condition is <code>true</code>.\n<code>UnlessDirective</code> displays the content when the condition is <code>false</code>.</p>\n\n<p translation-result=\"on\">以下是应用于 p 元素的 <code>UnlessDirective</code> 选择器 <code>appUnless</code> 当 <code>condition</code> 为 <code>false</code> ，浏览器将显示该句子。</p><p translation-origin=\"off\">Following is the <code>UnlessDirective</code> selector, <code>appUnless</code>, applied to the paragraph element.\nWhen <code>condition</code> is <code>false</code>, the browser displays the sentence.</p>\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (appUnless-1)\" region=\"appUnless-1\">\n&#x3C;p *appUnless=\"condition\">Show this sentence unless the condition is true.&#x3C;/p>\n\n</code-example>\n<ol>\n<li>\n<p translation-result=\"on\">使用 Angular CLI，运行以下命令，其中 <code>unless</code> 是伪指令的名称：</p><p translation-origin=\"off\">Using the Angular CLI, run the following command, where <code>unless</code> is the name of the directive:</p>\n\n<code-example language=\"bash\">\nng generate directive unless\n</code-example>\n<p translation-result=\"on\">Angular 会创建指令类，并指定 CSS 选择器 <code>appUnless</code>，它会在模板中标识指令。</p><p translation-origin=\"off\">Angular creates the directive class and specifies the CSS selector, <code>appUnless</code>, that identifies the directive in a template.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">导入 <code><a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code>、<code><a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a></code> 和 <code><a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a></code>。</p><p translation-origin=\"off\">Import <code><a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code>, <code><a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a></code>, and <code><a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a></code>.</p>\n\n<code-example path=\"structural-directives/src/app/unless.directive.ts\" header=\"src/app/unless.directive.ts (skeleton)\" region=\"skeleton\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>, <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({ selector: '[appUnless]'})\nexport class UnlessDirective {\n}\n\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">在指令的构造函数中将 <code><a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a></code> 和 <code><a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a></code> 注入成私有变量。</p><p translation-origin=\"off\">Inject <code><a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a></code> and <code><a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a></code> in the directive constructor as private variables.</p>\n\n<code-example path=\"structural-directives/src/app/unless.directive.ts\" header=\"src/app/unless.directive.ts (ctor)\" region=\"ctor\">\nconstructor(\n  private templateRef: <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>&#x3C;any>,\n  private viewContainer: <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a>) { }\n\n</code-example>\n<p translation-result=\"on\"><code>UnlessDirective</code> 会通过 Angular 生成的 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> 创建一个<a href=\"api/core/EmbeddedViewRef\" title=\"API：EmbeddedViewRef\">嵌入的视图</a>，然后将该视图插入到该指令的原始 <code>&#x3C;p></code> 宿主元素紧后面的<a href=\"api/core/ViewContainerRef\" title=\"API：ViewContainerRef\">视图容器</a>中。</p><p translation-origin=\"off\">The <code>UnlessDirective</code> creates an <a href=\"api/core/EmbeddedViewRef\" title=\"API: EmbeddedViewRef\">embedded view</a> from the Angular-generated <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> and inserts that view in a <a href=\"api/core/ViewContainerRef\" title=\"API: ViewContainerRef\">view container</a> adjacent to the directive's original <code>&#x3C;p></code> host element.</p>\n\n<p translation-result=\"on\"><a href=\"api/core/TemplateRef\" title=\"API：TemplateRef\"><code>TemplateRef</code></a>可帮助你获取 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> 的内容，而 <a href=\"api/core/ViewContainerRef\" title=\"API：ViewContainerRef\"><code>ViewContainerRef</code></a> 可以访问视图容器。</p><p translation-origin=\"off\"><a href=\"api/core/TemplateRef\" title=\"API: TemplateRef\"><code>TemplateRef</code></a> helps you get to the <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> contents and <a href=\"api/core/ViewContainerRef\" title=\"API: ViewContainerRef\"><code>ViewContainerRef</code></a> accesses the view container.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">添加一个带 setter 的 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 属性 <code>appUnless</code>。</p><p translation-origin=\"off\">Add an <code>appUnless</code> <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> property with a setter.</p>\n\n<code-example path=\"structural-directives/src/app/unless.directive.ts\" header=\"src/app/unless.directive.ts (set)\" region=\"set\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() set appUnless(condition: boolean) {\n  if (!condition &#x26;&#x26; !this.hasView) {\n    this.viewContainer.createEmbeddedView(this.templateRef);\n    this.hasView = true;\n  } else if (condition &#x26;&#x26; this.hasView) {\n    this.viewContainer.clear();\n    this.hasView = false;\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">每当条件的值更改时，Angular 都会设置 <code>appUnless</code> 属性。</p><p translation-origin=\"off\">Angular sets the <code>appUnless</code> property whenever the value of the condition changes.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">如果条件是假值，并且 Angular 以前尚未创建视图，则此 setter 会导致视图容器从模板创建出嵌入式视图。</p><p translation-origin=\"off\">If the condition is falsy and Angular hasn't created the view previously, the setter causes the view container to create the embedded view from the template.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果条件为真值，并且当前正显示着视图，则此 setter 会清除容器，这会导致销毁该视图。</p><p translation-origin=\"off\">If the condition is truthy and the view is currently displayed, the setter clears the container, which disposes of the view.</p>\n\n</li>\n</ul>\n</li>\n</ol>\n<p translation-result=\"on\">完整的指令如下：</p><p translation-origin=\"off\">The complete directive is as follows:</p>\n\n<code-example path=\"structural-directives/src/app/unless.directive.ts\" header=\"src/app/unless.directive.ts (excerpt)\" region=\"no-docs\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>, <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a> } from '@angular/core';\n\n/**\n * Add the template content to the DOM unless the condition is true.\n */\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({ selector: '[appUnless]'})\nexport class UnlessDirective {\n  private hasView = false;\n\n  constructor(\n    private templateRef: <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>&#x3C;any>,\n    private viewContainer: <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a>) { }\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() set appUnless(condition: boolean) {\n    if (!condition &#x26;&#x26; !this.hasView) {\n      this.viewContainer.createEmbeddedView(this.templateRef);\n      this.hasView = true;\n    } else if (condition &#x26;&#x26; this.hasView) {\n      this.viewContainer.clear();\n      this.hasView = false;\n    }\n  }\n}\n\n\n</code-example>\n<h3 id=\"testing-the-directive\" translation-result=\"on\">测试指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#testing-the-directive\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"testing-the-directive\">Testing the directive<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#testing-the-directive\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在本节中，你将更新你的应用程序，以测试 <code>UnlessDirective</code> 。</p><p translation-origin=\"off\">In this section, you'll update your application to test the <code>UnlessDirective</code>.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">添加一个 <code>condition</code> 设置为 <code>false</code> 的 <code>AppComponent</code> 。</p><p translation-origin=\"off\">Add a <code>condition</code> set to <code>false</code> in the <code>AppComponent</code>.</p>\n\n<code-example path=\"structural-directives/src/app/app.component.ts\" header=\"src/app/app.component.ts (excerpt)\" region=\"condition\">\ncondition = false;\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\"> 更新模板以使用指令。这里，<code>*appUnless</code> 位于两个具有相反 <code>condition</code> 的 <code>&#x3C;p></code> 标记上，一个为 <code>true</code> ，一个为 <code>false</code> 。</p><p translation-origin=\"off\">Update the template to use the directive.\nHere, <code>*appUnless</code> is on two <code>&#x3C;p></code> tags with opposite <code>condition</code> values, one <code>true</code> and one <code>false</code>.</p>\n\n<p> <code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (appUnless)\" region=\"appUnless\">\n&#x3C;p *appUnless=\"condition\" class=\"unless a\">\n  (A) This paragraph is displayed because the condition is false.\n&#x3C;/p>\n\n&#x3C;p *appUnless=\"!condition\" class=\"unless b\">\n  (B) Although the condition is true,\n  this paragraph is displayed because appUnless is set to false.\n&#x3C;/p>\n\n</code-example></p>\n<p translation-result=\"on\"> 星号是将 <code>appUnless</code> 标记为结构型指令的简写形式。如果 <code>condition</code> 是假值，则会让顶部段落 A，而底部段落 B 消失。当 <code>condition</code> 为真时，顶部段落 A 消失，而底部段落 B 出现。</p><p translation-origin=\"off\"> The asterisk is shorthand that marks <code>appUnless</code> as a structural directive.\nWhen the <code>condition</code> is falsy, the top (A) paragraph appears and the bottom (B) paragraph disappears.\nWhen the <code>condition</code> is truthy, the top (A) paragraph disappears and the bottom (B) paragraph appears.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">要在浏览器中更改并显示 <code>condition</code> 的值，请添加一段标记代码以显示状态和按钮。</p><p translation-origin=\"off\">To change and display the value of <code>condition</code> in the browser, add markup that displays the status and a button.</p>\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html\" region=\"toggle-info\">\n&#x3C;p>\n  The condition is currently\n  &#x3C;span [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"{ 'a': !condition, 'b': condition, 'unless': true }\">{{condition}}&#x3C;/span>.\n  &#x3C;button\n    (click)=\"condition = !condition\"\n    [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>] = \"{ 'a': condition, 'b': !condition }\" >\n    Toggle condition to {{condition ? 'false' : 'true'}}\n  &#x3C;/button>\n&#x3C;/p>\n\n</code-example>\n</li>\n</ol>\n<p translation-result=\"on\">要验证指令是否有效，请单击按钮以更改 <code>condition</code> 的值。</p><p translation-origin=\"off\">To verify that the directive works, click the button to change the value of <code>condition</code>.</p>\n\n  <div class=\"lightbox\">\n    <img src=\"generated/images/guide/structural-directives/unless-anim.gif\" alt=\"UnlessDirective in action\" width=\"524\" height=\"100\">\n  </div>\n<a id=\"shorthand\"></a>\n<a id=\"asterisk\"></a>\n<h2 id=\"structural-directive-shorthand\" translation-result=\"on\">结构型指令简写形式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#structural-directive-shorthand\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"structural-directive-shorthand\">Structural directive shorthand<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#structural-directive-shorthand\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">结构型指令（例如 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>）上的星号 <code>*</code> 语法是 Angular 解释为较长形式的简写形式。 Angular 将结构型指令前面的星号转换为围绕宿主元素及其后代的 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code>。</p><p translation-origin=\"off\">The asterisk, <code>*</code>,  syntax on a structural directive, such as <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>, is shorthand that Angular interprets into a longer form.\nAngular transforms the asterisk in front of a structural directive into an <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> that surrounds the host element and its descendants.</p>\n\n<p translation-result=\"on\">下面是一个 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 的示例，如果 <code>hero</code> 存在，则显示英雄的名称：</p><p translation-origin=\"off\">The following is an example of <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> that displays the hero's name if <code>hero</code> exists:</p>\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (asterisk)\" region=\"asterisk\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\" class=\"name\">{{hero.name}}&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\"><code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 指令移到了 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> 上，在这里它成为绑定在方括号 <code>[<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>]</code> 中的属性。 <code>&#x3C;div></code> 的其余部分（包括其 class 属性）移到了 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> 内部。</p><p translation-origin=\"off\">The <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> directive moves to the <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> where it becomes a property binding in square brackets, <code>[<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>]</code>.\nThe rest of the <code>&#x3C;div></code>, including its class attribute, moves inside the <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code>.</p>\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngif-template)\" region=\"ngif-template\">\n&#x3C;ng-template [<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>]=\"hero\">\n  &#x3C;div class=\"name\">{{hero.name}}&#x3C;/div>\n&#x3C;/ng-template>\n\n</code-example>\n<p translation-result=\"on\">Angular 不会创建真正的 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> 元素，只会将 <code>&#x3C;div></code> 和注释节点占位符渲染到 DOM 中。</p><p translation-origin=\"off\">Angular does not create a real <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> element, instead rendering only the <code>&#x3C;div></code> and a comment node placeholder to the DOM.</p>\n\n<code-example language=\"html\">\n&#x3C;!--bindings={\n  \"ng-reflect-ng-if\": \"[object Object]\"\n}-->\n&#x3C;div _ngcontent-c0>Mr. Nice&#x3C;/div>\n</code-example>\n<p translation-result=\"on\"><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 中的星号的简写形式与非简写的 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> 形式进行比较：</p><p translation-origin=\"off\">The following example compares the shorthand use of the asterisk in <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> with the longhand <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> form:</p>\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (inside-ngfor)\" region=\"inside-ngfor\">\n&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes; let i=index; let odd=odd; trackBy: trackById\" [class.odd]=\"odd\">\n  ({{i}}) {{hero.name}}\n&#x3C;/div>\n\n&#x3C;ng-template <a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a> let-hero [<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>]=\"heroes\" let-i=\"index\" let-odd=\"odd\" [ngForTrackBy]=\"trackById\">\n  &#x3C;div [class.odd]=\"odd\">({{i}}) {{hero.name}}&#x3C;/div>\n&#x3C;/ng-template>\n\n</code-example>\n<p translation-result=\"on\">这里，<code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 结构型指令相关的所有内容都应用到了 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> 中。而元素上的所有其他绑定和属性应用到了 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> 中的 <code>&#x3C;div></code> 元素上。除了 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 字符串外，宿主元素上的其他修饰都会保留在 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> 中。在这个例子中，<code>[class.odd]=\"odd\"</code> 就留在了 <code>&#x3C;div></code> 中。</p><p translation-origin=\"off\">Here, everything related to the <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> structural directive applies to the <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code>.\nAll other bindings and attributes on the element apply to the <code>&#x3C;div></code> element within the <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code>.\nOther modifiers on the host element, in addition to the <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> string, remain in place as the element moves inside the <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code>.\nIn this example, the <code>[class.odd]=\"odd\"</code> stays on the <code>&#x3C;div></code>.</p>\n\n<p translation-result=\"on\"><code>let</code> 关键字会声明一个模板输入变量，你可以在模板中引用该变量。在这个例子中，是 <code>hero</code>、<code>i</code> 和 <code>odd</code>。解析器将 <code>let hero</code>、<code>let i</code> 和 <code>let odd</code> 转换为名为 <code>let-hero</code>、<code>let-i</code> 和 <code>let-odd</code> 的变量。 <code>let-i</code> 和 <code>let-odd</code> 变量变为 <code>let i=index</code> 和 <code>let odd=odd</code> 。 Angular 会将 <code>i</code> 和 <code>odd</code> 设置为上下文中 <code>index</code> 和 <code>odd</code> 属性的当前值。</p><p translation-origin=\"off\">The <code>let</code> keyword declares a template input variable that you can reference within the template.\nThe input variables in this example are <code>hero</code>, <code>i</code>, and <code>odd</code>.\nThe parser translates <code>let hero</code>, <code>let i</code>, and <code>let odd</code> into variables named <code>let-hero</code>, <code>let-i</code>, and <code>let-odd</code>.\nThe <code>let-i</code> and <code>let-odd</code> variables become <code>let i=index</code> and <code>let odd=odd</code>.\nAngular sets <code>i</code> and <code>odd</code> to the current value of the context's <code>index</code> and <code>odd</code> properties.</p>\n\n<p translation-result=\"on\">解析器会将 PascalCase 应用于所有指令，并为它们加上指令的属性名称（例如 ngFor）。比如，<code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 的输入特性 <code>of</code> 和 <code>trackBy</code> ，会映射为 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a></code> 和 <code>ngForTrackBy</code> 。当 <code>NgFor</code> 指令遍历列表时，它会设置和重置它自己的上下文对象的属性。这些属性可以包括但不限于 <code>index</code>、<code>odd</code> 和一个名为 <code>$implicit</code> 的特殊属性。</p><p translation-origin=\"off\">The parser applies PascalCase to all directives and prefixes them with the directive's attribute name, such as ngFor.\nFor example, the <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> input properties, <code>of</code> and <code>trackBy</code>, map to <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a></code> and <code>ngForTrackBy</code>.\nAs the <code>NgFor</code> directive loops through the list, it sets and resets properties of its own context object.\nThese properties can include, but aren't limited to, <code>index</code>, <code>odd</code>, and a special property\nnamed <code>$implicit</code>.</p>\n\n<p translation-result=\"on\">Angular 会将 <code>let-hero</code> 设置为上下文的 <code>$implicit</code> 属性的值， <code>NgFor</code> 已经将其初始化为当前正在迭代的英雄。</p><p translation-origin=\"off\">Angular sets <code>let-hero</code> to the value of the context's <code>$implicit</code> property, which <code>NgFor</code> has initialized with the hero for the current iteration.</p>\n\n<p translation-result=\"on\">有关更多信息，请参见 <a href=\"api/common/NgForOf\" title=\"API：NgFor\">NgFor API</a> 和 <a href=\"api/common/NgForOf\">NgForOf API</a> 文档。</p><p translation-origin=\"off\">For more information, see the <a href=\"api/common/NgForOf\" title=\"API: NgFor\">NgFor API</a> and <a href=\"api/common/NgForOf\">NgForOf API</a> documentation.</p>\n\n<h3 id=\"creating-template-fragments-with-ng-template\" translation-result=\"on\">用 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> 创建模板片段<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#creating-template-fragments-with-ng-template\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"creating-template-fragments-with-ng-template\">Creating template fragments with <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#creating-template-fragments-with-ng-template\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">Angular 的 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> 元素定义了一个默认情况下不渲染任何内容的模板。使用 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> ，你可以手动渲染内容，以完全控制内容的显示方式。</p><p translation-origin=\"off\">Angular's <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> element defines a template that doesn't render anything by default.\nWith <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code>, you can render the content manually for full control over how the content displays.</p>\n\n<p translation-result=\"on\">如果没有结构型指令，并且将某些元素包装在 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> 中，则这些元素会消失。在下面的示例中，Angular 不会渲染中间的 “Hip!”，因为它被 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> 包裹着。</p><p translation-origin=\"off\">If there is no structural directive and you wrap some elements in an <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code>, those elements disappear.\nIn the following example, Angular does not render the middle \"Hip!\" in the phrase \"Hip! Hip! Hooray!\" because of the surrounding <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code>.</p>\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (template-tag)\" region=\"template-tag\">\n&#x3C;p>Hip!&#x3C;/p>\n&#x3C;ng-template>\n  &#x3C;p>Hip!&#x3C;/p>\n&#x3C;/ng-template>\n&#x3C;p>Hooray!&#x3C;/p>\n\n</code-example>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/structural-directives/template-rendering.png\" alt=\"template tag rendering\" width=\"520\" height=\"94\">\n</div>\n<h2 id=\"structural-directive-syntax-reference\" translation-result=\"on\">结构型指令语法参考<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#structural-directive-syntax-reference\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"structural-directive-syntax-reference\">Structural directive syntax reference<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#structural-directive-syntax-reference\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">当你编写自己的结构型指令时，请使用以下语法：</p><p translation-origin=\"off\">When you write your own structural directives, use the following syntax:</p>\n\n<code-example>\n*:prefix=\"( :let | :expression ) (';' | ',')? ( :let | :as | :keyExp )*\"\n</code-example>\n<p translation-result=\"on\">下表描述了结构型指令语法的每个部分：</p><p translation-origin=\"off\">The following tables describe each portion of the structural directive grammar:</p>\n\n<table>\n  <tbody><tr>\n    <td><code>prefix</code></td>\n    <td><p translation-result=\"on\">HTML 属性的键名</p><p translation-origin=\"off\">HTML attribute key</p></td>\n  </tr>\n  \n  <tr>\n    <td><code>key</code></td>\n    <td><p translation-result=\"on\">HTML 属性的键名</p><p translation-origin=\"off\">HTML attribute key</p></td>\n  </tr>\n  \n  <tr>\n    <td><code>local</code></td>\n    <td><p translation-result=\"on\">在模板中使用的局部变量名</p><p translation-origin=\"off\">local variable name used in the template</p></td>\n  </tr>\n  \n  <tr>\n    <td><code>export</code></td>\n    <td><p translation-result=\"on\">该指令以特定名称导出的值</p><p translation-origin=\"off\">value exported by the directive under a given name</p></td>\n  </tr>\n  <tr>\n    <td><code>expression</code></td>\n    <td><p translation-result=\"on\">标准 Angular 表达式</p><p translation-origin=\"off\">standard Angular expression</p></td>\n  </tr>\n  \n</tbody></table>\n<table>\n  <tbody><tr>\n    <th></th>\n  </tr>\n  <tr>\n    <td colspan=\"3\"><code>keyExp = :key \":\"? :expression (\"as\" :local)? \";\"? </code></td>\n  </tr>\n  <tr>\n    <td colspan=\"3\"><code>let = \"let\" :local \"=\" :export \";\"?</code></td>\n  </tr>\n  <tr>\n    <td colspan=\"3\"><code>as = :export \"as\" :local \";\"?</code></td>\n  </tr>\n</tbody></table>\n<h3 id=\"how-angular-translates-shorthand\" translation-result=\"on\">Angular 如何翻译简写形式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#how-angular-translates-shorthand\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"how-angular-translates-shorthand\">How Angular translates shorthand<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#how-angular-translates-shorthand\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">Angular 会将结构型指令的简写形式转换为普通的绑定语法，如下所示：</p><p translation-origin=\"off\">Angular translates structural directive shorthand into the normal binding syntax as follows:</p>\n\n<table>\n  <tbody><tr>\n    <th><p translation-result=\"on\">简写形式</p><p translation-origin=\"off\">Shorthand</p></th>\n    <th><p translation-result=\"on\">翻译结果</p><p translation-origin=\"off\">Translation</p></th>\n  </tr>\n  \n  <tr>\n    <td><p translation-result=\"on\"><code>prefix</code> 和裸 <code>expression</code></p><p translation-origin=\"off\"><code>prefix</code> and naked <code>expression</code></p></td>\n    <td><code>[prefix]=\"expression\"</code></td>\n  </tr>\n  \n  <tr>\n    <td><code>keyExp</code></td>\n    <td><p translation-result=\"on\"><code>[prefixKey] \"expression\"\n    (let-prefixKey=\"export\")</code>\n    <br>\n    注意，这个 <code>prefix</code> 已经加到了 <code>key</code> 上。</p><p translation-origin=\"off\"><code>[prefixKey] \"expression\"\n    (let-prefixKey=\"export\")</code>\n    <br>\n    Notice that the <code>prefix</code>\n    is added to the <code>key</code>\n    </p></td>\n  </tr>\n  \n  <tr>\n    <td><code>let</code></td>\n    <td><code>let-local=\"export\"</code></td>\n  </tr>\n</tbody></table>\n<h3 id=\"shorthand-examples\" translation-result=\"on\">简写形式示例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#shorthand-examples\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"shorthand-examples\">Shorthand examples<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#shorthand-examples\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">下表提供了一些简写形式示例：</p><p translation-origin=\"off\">The following table provides shorthand examples:</p>\n\n<table>\n  <tbody><tr>\n    <th><p translation-result=\"on\">简写形式</p><p translation-origin=\"off\">Shorthand</p></th>\n    <th><p translation-result=\"on\">Angular 如何解释此语法</p><p translation-origin=\"off\">How Angular interprets the syntax</p></th>\n  </tr>\n  \n  <tr>\n    <td><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let item of [1,2,3]\"</code></td>\n    <td><code>&#x3C;ng-template <a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a> let-item [<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>]=\"[1,2,3]\"></code></td>\n  </tr>\n  <tr>\n    <td><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let item of [1,2,3] as items; trackBy: myTrack; index as i\"</code></td>\n    <td><code>&#x3C;ng-template <a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a> let-item [<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>]=\"[1,2,3]\" let-items=\"<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>\" [ngForTrackBy]=\"myTrack\" let-i=\"index\"></code>\n    </td>\n  </tr>\n  <tr>\n    <td><code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"exp\"</code></td>\n    <td><code>&#x3C;ng-template [<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>]=\"exp\"></code></td>\n  </tr>\n  <tr>\n    <td><code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"exp as value\"</code></td>\n    <td><code>&#x3C;ng-template [<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>]=\"exp\" let-value=\"<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>\"></code></td>\n  </tr>\n</tbody></table>\n<a id=\"directive-type-checks\"></a>\n<!-- To do follow up PR: move this section to a more general location because it also applies to attribute directives. -->\n<h2 id=\"improving-template-type-checking-for-custom-directives\" translation-result=\"on\">改进自定义指令的模板类型检查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#improving-template-type-checking-for-custom-directives\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"improving-template-type-checking-for-custom-directives\">Improving template type checking for custom directives<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#improving-template-type-checking-for-custom-directives\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你可以通过将模板守卫属性添加到指令定义中来改进自定义指令的模板类型检查。这些属性可帮助 Angular 的模板类型检查器在编译时发现模板中的错误，从而避免运行时错误。这些属性如下：</p><p translation-origin=\"off\">You can improve template type checking for custom directives by adding template guard properties to your directive definition.\nThese properties help the Angular template type checker find mistakes in the template at compile time, which can avoid runtime errors.\nThese properties are as follows:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>ngTemplateGuard_(someInputProperty)</code> 属性使你可以为模板中的输入表达式指定更准确的类型。</p><p translation-origin=\"off\">A property <code>ngTemplateGuard_(someInputProperty)</code> lets you specify a more accurate type for an input expression within the template.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">静态属性 <code>ngTemplateContextGuard</code> 声明了模板上下文的类型。</p><p translation-origin=\"off\">The <code>ngTemplateContextGuard</code> static property declares the type of the template context.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">本节提供了两种类型守卫的示例。欲知详情，请参见<a href=\"guide/template-typecheck\" title=\"模板类型检查指南\">模板类型检查</a>。</p><p translation-origin=\"off\">This section provides examples of both kinds of type-guard property.\nFor more information, see <a href=\"guide/template-typecheck\" title=\"Template type-checking guide\">Template type checking</a>.</p>\n\n<a id=\"narrowing-input-types\"></a>\n<h3 id=\"making-in-template-type-requirements-more-specific-with-template-guards\" translation-result=\"on\">使用模板守卫使模板中的类型要求更具体<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#making-in-template-type-requirements-more-specific-with-template-guards\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"making-in-template-type-requirements-more-specific-with-template-guards\">Making in-template type requirements more specific with template guards<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#making-in-template-type-requirements-more-specific-with-template-guards\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">模板中的结构型指令会根据输入表达式来控制是否要在运行时渲染该模板。为了帮助编译器捕获模板类型中的错误，你应该尽可能详细地指定模板内指令的输入表达式所期待的类型。</p><p translation-origin=\"off\">A structural directive in a template controls whether that template is rendered at run time, based on its input expression.\nTo help the compiler catch template type errors, you should specify as closely as possible the required type of a directive's input expression when it occurs inside the template.</p>\n\n<p translation-result=\"on\">类型保护函数会将输入表达式的预期类型缩小为可能在运行时传递给模板内指令的类型的子集。你可以提供这样的功能来帮助类型检查器在编译时为表达式推断正确的类型。</p><p translation-origin=\"off\">A type guard function narrows the expected type of an input expression to a subset of types that might be passed to the directive within the template at run time.\nYou can provide such a function to help the type-checker infer the proper type for the expression at compile time.</p>\n\n<p translation-result=\"on\">例如，<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 的实现使用类型窄化来确保只有当 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 的输入表达式为真时，模板才会被实例化。为了提供具体的类型要求，<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 指令定义了一个<a href=\"api/common/NgIf#static-properties\">静态属性 <code>ngTemplateGuard_ngIf: 'binding'</code></a>。这里的 <code>binding</code> 值是一种常见的类型窄化的例子，它会对输入表达式进行求值，以满足类型要求。</p><p translation-origin=\"off\">For example, the <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> implementation uses type-narrowing to ensure that the\ntemplate is only instantiated if the input expression to <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> is truthy.\nTo provide the specific type requirement, the <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> directive defines a <a href=\"api/common/NgIf#static-properties\">static property <code>ngTemplateGuard_ngIf: 'binding'</code></a>.\nThe <code>binding</code> value is a special case for a common kind of type-narrowing where the input expression is evaluated in order to satisfy the type requirement.</p>\n\n<p translation-result=\"on\">要为模板中指令的输入表达式提供更具体的类型，请在指令中添加 <code>ngTemplateGuard_xx</code> 属性，其中静态属性名称 <code>xx</code> 就是 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 字段的名字。该属性的值可以是基于其返回类型的常规类型窄化函数，也可以是字符串，例如 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 中的 <code>\"binding\"</code>。</p><p translation-origin=\"off\">To provide a more specific type for an input expression to a directive within the template, add an <code>ngTemplateGuard_xx</code> property to the directive, where the suffix to the static property name, <code>xx</code>, is the <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> field name.\nThe value of the property can be either a general type-narrowing function based on its return type, or the string <code>\"binding\"</code>, as in the case of <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>.</p>\n\n<p translation-result=\"on\">例如，考虑以下结构型指令，该指令以模板表达式的结果作为输入：</p><p translation-origin=\"off\">For example, consider the following structural directive that takes the result of a template expression as an input:</p>\n\n<code-example language=\"ts\" header=\"IfLoadedDirective\">\nexport type Loaded<t> = { type: 'loaded', data: T };\nexport type Loading = { type: 'loading' };\nexport type LoadingState<t> = Loaded<t> | Loading;\nexport class IfLoadedDirective<t> {\n    @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('ifLoaded') set state(state: LoadingState<t>) {}\n    <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> ngTemplateGuard_state<t>(dir: IfLoadedDirective<t>, expr: LoadingState<t>): expr is Loaded<t> { return true; };\n}\n\nexport interface Person {\n  name: string;\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  template: `&#x3C;div *ifLoaded=\"state\">{{ state.data }}&#x3C;/div>`,\n})\nexport class AppComponent {\n  state: LoadingState<person>;\n}\n</person></t></t></t></t></t></t></t></t></t></code-example>\n<p translation-result=\"on\">在这个例子中， <code>LoadingState&#x3C;T></code> 类型允许两个状态之一， <code>Loaded&#x3C;T></code> 或 <code>Loading</code> 。用作指令的 <code>state</code> 输入的表达式是宽泛的伞形类型 <code>LoadingState</code>，因为还不知道此时的加载状态是什么。</p><p translation-origin=\"off\">In this example, the <code>LoadingState&#x3C;T></code> type permits either of two states, <code>Loaded&#x3C;T></code> or <code>Loading</code>. The expression used as the directive’s <code>state</code> input is of the umbrella type <code>LoadingState</code>, as it’s unknown what the loading state is at that point.</p>\n\n<p translation-result=\"on\"><code>IfLoadedDirective</code> 定义声明了静态字段 <code>ngTemplateGuard_state</code>，以表示其窄化行为。在 <code>AppComponent</code> 模板中，<code>*ifLoaded</code> 结构型指令只有当实际的 <code>state</code> 是 <code>Loaded&#x3C;Person></code> 类型时，才会渲染该模板。类型守护允许类型检查器推断出模板中可接受的 <code>state</code> 类型是 <code>Loaded&#x3C;T></code>，并进一步推断出 <code>T</code> 必须是一个 <code>Person</code> 的实例。</p><p translation-origin=\"off\">The <code>IfLoadedDirective</code> definition declares the static field <code>ngTemplateGuard_state</code>, which expresses the narrowing behavior.\nWithin the <code>AppComponent</code> template, the <code>*ifLoaded</code> structural directive should render this template only when <code>state</code> is actually <code>Loaded&#x3C;Person></code>.\nThe type guard lets the type checker infer that the acceptable type of <code>state</code> within the template is a <code>Loaded&#x3C;T></code>, and further infer that <code>T</code> must be an instance of <code>Person</code>.</p>\n\n<a id=\"narrowing-context-type\"></a>\n<h3 id=\"typing-the-directives-context\" translation-result=\"on\">为指令的上下文指定类型<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#typing-the-directives-context\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"typing-the-directives-context\">Typing the directive's context<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#typing-the-directives-context\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果你的结构型指令要为实例化的模板提供一个上下文，可以通过提供静态的 <code>ngTemplateContextGuard</code> 函数在模板中给它提供合适的类型。下面的代码片段展示了该函数的一个例子。</p><p translation-origin=\"off\">If your structural directive provides a context to the instantiated template, you can properly type it inside the template by providing a static <code>ngTemplateContextGuard</code> function.\nThe following snippet shows an example of such a function.</p>\n\n<code-example language=\"ts\" header=\"myDirective.ts\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({…})\nexport class ExampleDirective {\n    // Make sure the template checker knows the type of the context with which the\n    // template of this directive will be rendered\n    <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> ngTemplateContextGuard(dir: ExampleDirective, ctx: unknown): ctx is ExampleContext { return true; };\n\n    // …\n}\n</code-example>\n\n  \n</div>\n\n\n<!-- links to this doc:\n - api/common\n - api/common/CommonModule\n - api/common/NgForOf\n - api/common/NgIf\n - api/common/NgSwitch\n - guide/ajs-quick-reference\n - guide/aot-compiler\n - guide/architecture-components\n - guide/bootstrapping\n - guide/built-in-directives\n - guide/example-apps-list\n - guide/glossary\n - guide/interpolation\n - guide/template-reference-variables\n - guide/template-statements\n - guide/template-typecheck\n - start\n-->\n<!-- links from this doc:\n - api/common/NgClass\n - api/common/NgForOf\n - api/common/NgIf\n - api/common/NgIf#static-properties\n - api/common/NgSwitch\n - api/core/Component\n - api/core/Directive\n - api/core/EmbeddedViewRef\n - api/core/Input\n - api/core/TemplateRef\n - api/core/ViewContainerRef\n - api/core/ng-template\n - api/upgrade/static\n - guide/built-in-directives\n - guide/structural-directives#creating-a-structural-directive\n - guide/structural-directives#creating-template-fragments-with-ng-template\n - guide/structural-directives#how-angular-translates-shorthand\n - guide/structural-directives#improving-template-type-checking-for-custom-directives\n - guide/structural-directives#making-in-template-type-requirements-more-specific-with-template-guards\n - guide/structural-directives#shorthand-examples\n - guide/structural-directives#structural-directive-shorthand\n - guide/structural-directives#structural-directive-syntax-reference\n - guide/structural-directives#testing-the-directive\n - guide/structural-directives#typing-the-directives-context\n - guide/structural-directives#writing-structural-directives\n - guide/template-typecheck\n - https://github.com/ng-docs/angular-cn/edit/aio/aio/content/guide/structural-directives.md?message=docs%3A%20请简述你的修改...\n-->"
}