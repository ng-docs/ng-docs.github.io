{
  "id": "guide/dependency-injection-providers",
  "title": "Dependency Providers",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/dependency-injection-providers.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n<div class=\"content\">\n<h1 translation-origin=\"off\" id=\"dependency-providers\">Dependency Providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#dependency-providers\"><i class=\"material-icons\">link</i></a></h1>\n<p translation-origin=\"off\">A dependency <a href=\"guide/glossary#provider\">provider</a> configures an injector\nwith a <a href=\"guide/glossary#di-token\">DI token</a>,\nwhich that injector uses to provide the concrete, runtime version of a dependency value.\nThe injector relies on the provider configuration to create instances of the dependencies\nthat it injects into components, directives, pipes, and other services.</p>\n<p translation-origin=\"off\">You must configure an injector with a provider, or it won't know how to create the dependency.<br>\nThe most obvious way for an injector to create an instance of a service class is with the class itself.\nIf you specify the service class itself as the provider token, the default behavior is for the injector to instantiate that class with <code>new</code>. </p>\n<p translation-origin=\"off\">In the following typical example, the <code>Logger</code> class itself provides a <code>Logger</code> instance. </p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-logger\">\nproviders: [Logger]\n\n</code-example>\n<p translation-origin=\"off\">You can, however, configure an injector with an alternative provider,\nin order to deliver some other object that provides the needed logging functionality.\nFor instance:</p>\n<ul>\n<li>\n<p translation-origin=\"off\">You can provide a substitute class.</p>\n</li>\n<li>\n<p translation-origin=\"off\">You can provide a logger-like object.</p>\n</li>\n<li>\n<p translation-origin=\"off\">Your provider can call a logger factory function.</p>\n</li>\n</ul>\n<a id=\"provide\"></a>\n<h2 translation-origin=\"off\" id=\"the-provider-object-literal\">The <code><a href=\"api/core/Provider\" class=\"code-anchor\">Provider</a></code> object literal<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#the-provider-object-literal\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-origin=\"off\">The class-provider syntax is a shorthand expression that expands\ninto a provider configuration, defined by the <a href=\"api/core/Provider\"><code>Provider</code> interface</a>.\nThe following code snippets shows how a class that is given as the <code>providers</code> value is expanded into a full provider object.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-logger\">\nproviders: [Logger]\n\n</code-example>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-3\">\n[{ provide: Logger, useClass: Logger }]\n\n</code-example>\n<p translation-origin=\"off\">The expanded provider configuration is an object literal with two properties.</p>\n<ul>\n<li>\n<p translation-origin=\"off\">The <code>provide</code> property holds the <a href=\"guide/dependency-injection#token\">token</a>\nthat serves as the key for both locating a dependency value and configuring the injector.</p>\n</li>\n<li>\n<p translation-origin=\"off\">The second property is a provider definition object, which tells the injector how to create the dependency value.\nThe provider-definition key can be <code>useClass</code>, as in the example.\nIt can also be <code>useExisting</code>, <code>useValue</code>, or <code>useFactory</code>.\nEach of these keys provides a different type of dependency, as discussed below. </p>\n</li>\n</ul>\n<a id=\"class-provider\"></a>\n<h2 translation-origin=\"off\" id=\"alternative-class-providers\">Alternative class providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#alternative-class-providers\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-origin=\"off\">Different classes can provide the same service.\nFor example, the following code tells the injector\nto return a <code>BetterLogger</code> instance when the component asks for a logger\nusing the <code>Logger</code> token.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-4\">\n[{ provide: Logger, useClass: BetterLogger }]\n\n</code-example>\n<a id=\"class-provider-dependencies\"></a>\n<h3 translation-origin=\"off\" id=\"class-providers-with-dependencies\">Class providers with dependencies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#class-providers-with-dependencies\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-origin=\"off\">Another class, <code>EvenBetterLogger</code>, might display the user name in the log message.\nThis logger gets the user from an injected <code>UserService</code> instance.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"EvenBetterLogger\" linenums=\"false\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class EvenBetterLogger extends Logger {\n  constructor(private userService: UserService) { super(); }\n\n  <a href=\"api/animations/browser/testing/MockAnimationDriver#log\" class=\"code-anchor\">log</a>(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>: string) {\n    let name = this.userService.user.name;\n    super.log(`Message to ${name}: ${<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>}`);\n  }\n}\n\n</code-example>\n<p translation-origin=\"off\">The injector needs providers for both this new logging service and its dependent <code>UserService</code>. Configure this alternative logger with the <code>useClass</code> provider-definition key, like <code>BetterLogger</code>. The following array specifies both providers in the <code>providers</code> metadata option of the parent module or component.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-5\" linenums=\"false\">\n[ UserService,\n  { provide: Logger, useClass: EvenBetterLogger }]\n\n</code-example>\n<a id=\"aliased-class-providers\"></a>\n<h3 translation-origin=\"off\" id=\"aliased-class-providers\">Aliased class providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#aliased-class-providers\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-origin=\"off\">Suppose an old component depends upon the <code>OldLogger</code> class.\n<code>OldLogger</code> has the same interface as <code>NewLogger</code>, but for some reason\nyou can't update the old component to use it. </p>\n<p translation-origin=\"off\">When the old component logs a message with <code>OldLogger</code>,\nyou want the singleton instance of <code>NewLogger</code> to handle it instead.\nIn this case, the dependency injector should inject that singleton instance\nwhen a component asks for either the new or the old logger.\n<code>OldLogger</code> should be an <em>alias</em> for <code>NewLogger</code>.</p>\n<p translation-origin=\"off\">If you try to alias <code>OldLogger</code> to <code>NewLogger</code> with <code>useClass</code>, you end up with two different <code>NewLogger</code> instances in your app. </p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-6a\" linenums=\"false\">\n[ NewLogger,\n  // Not aliased! Creates two instances of `NewLogger`\n  { provide: OldLogger, useClass: NewLogger}]\n\n</code-example>\n<p translation-origin=\"off\">To make sure there is only one instance of <code>NewLogger</code>, alias <code>OldLogger</code> with the <code>useExisting</code> option.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-6b\" linenums=\"false\">\n[ NewLogger,\n  // Alias OldLogger w/ reference to NewLogger\n  { provide: OldLogger, useExisting: NewLogger}]\n\n</code-example>\n<a id=\"value-provider\"></a>\n<h2 translation-origin=\"off\" id=\"value-providers\">Value providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#value-providers\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-origin=\"off\">Sometimes it's easier to provide a ready-made object rather than ask the injector to create it from a class.\nTo inject an object you have already created,\nconfigure the injector with the <code>useValue</code> option</p>\n<p translation-origin=\"off\">The following code defines a variable that creates such an object to play the logger role.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"silent-logger\" linenums=\"false\">\n// An object in the shape of the logger service\nexport function SilentLoggerFn() {}\n\nconst silentLogger = {\n  logs: ['Silent logger says \"Shhhhh!\". Provided via \"useValue\"'],\n  <a href=\"api/animations/browser/testing/MockAnimationDriver#log\" class=\"code-anchor\">log</a>: SilentLoggerFn\n};\n\n</code-example>\n<p translation-origin=\"off\">The following provider object uses the <code>useValue</code> key to associate the variable with the <code>Logger</code> token.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-7\" linenums=\"false\">\n[{ provide: Logger, useValue: silentLogger }]\n\n</code-example>\n<a id=\"non-class-dependencies\"></a>\n<h3 translation-origin=\"off\" id=\"non-class-dependencies\">Non-class dependencies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#non-class-dependencies\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-origin=\"off\">Not all dependencies are classes.\nSometimes you want to inject a string, function, or object.</p>\n<p translation-origin=\"off\">Apps often define configuration objects with lots of small facts,\nlike the title of the application or the address of a web API endpoint.\nThese configuration objects aren't always instances of a class.\nThey can be object literals, as shown in the following example.</p>\n<code-example path=\"dependency-injection/src/app/app.config.ts\" region=\"config\" header=\"src/app/app.config.ts (excerpt)\" linenums=\"false\">\nexport const HERO_DI_CONFIG: AppConfig = {\n  apiEndpoint: 'api.heroes.com',\n  title: 'Dependency Injection'\n};\n\n\n</code-example>\n<a id=\"interface-not-valid-token\"></a>\n<p translation-origin=\"off\"><strong>TypeScript interfaces are not valid tokens</strong></p>\n<p translation-origin=\"off\">The <code>HERO_DI_CONFIG</code> constant conforms to the <code>AppConfig</code> interface.\nUnfortunately, you cannot use a TypeScript interface as a token.\nIn TypeScript, an interface is a design-time artifact, and doesn't have a runtime representation (token) that the DI framework can use. </p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-9-interface\" linenums=\"false\">\n// FAIL! Can't use interface as provider token\n[{ provide: AppConfig, useValue: HERO_DI_CONFIG })]\n\n</code-example>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-9-ctor-interface\" linenums=\"false\">\n// FAIL! Can't inject using the interface as the parameter type\nconstructor(private <a href=\"api/router/Router#config\" class=\"code-anchor\">config</a>: AppConfig){ }\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\">This might seem strange if you're used to dependency injection in strongly typed languages where an interface is the preferred dependency lookup key.\nHowever, JavaScript, doesn't have interfaces, so when TypeScript is transpiled to JavaScript, the interface disappears.\nThere is no interface type information left for Angular to find at runtime.</p>\n</div>\n<p translation-origin=\"off\">One alternative is to provide and inject the configuration object in an NgModule like <code>AppModule</code>.</p>\n<code-example path=\"dependency-injection/src/app/app.module.ts\" region=\"providers\" header=\"src/app/app.module.ts (providers)\">\nproviders: [\n  UserService,\n  { provide: APP_CONFIG, useValue: HERO_DI_CONFIG }\n],\n\n</code-example>\n<p translation-origin=\"off\">Another solution to choosing a provider token for non-class dependencies is\nto define and use an <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> object.\nThe following example shows how to define such a token.</p>\n<code-example path=\"dependency-injection/src/app/app.config.ts\" region=\"token\" header=\"src/app/app.config.ts\" linenums=\"false\">\nimport { <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a> } from '@angular/core';\n\nexport const APP_CONFIG = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>&#x3C;AppConfig>('app.config');\n\n</code-example>\n<p translation-origin=\"off\">The type parameter, while optional, conveys the dependency's type to developers and tooling.\nThe token description is another developer aid.</p>\n<p translation-origin=\"off\">Register the dependency provider using the <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> object:</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-9\" linenums=\"false\">\nproviders: [{ provide: APP_CONFIG, useValue: HERO_DI_CONFIG }]\n\n</code-example>\n<p translation-origin=\"off\">Now you can inject the configuration object into any constructor that needs it, with\nthe help of an <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>()</code> parameter decorator.</p>\n<code-example path=\"dependency-injection/src/app/app.component.2.ts\" region=\"ctor\" header=\"src/app/app.component.ts\" linenums=\"false\">\nconstructor(@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(APP_CONFIG) <a href=\"api/router/Router#config\" class=\"code-anchor\">config</a>: AppConfig) {\n  this.title = config.title;\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\">Although the <code>AppConfig</code> interface plays no role in dependency injection,\nit supports typing of the configuration object within the class.</p>\n</div>\n<a id=\"factory-provider\"></a>\n<a id=\"factory-providers\"></a>\n<h2 translation-origin=\"off\" id=\"factory-providers\">Factory providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#factory-providers\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-origin=\"off\">Sometimes you need to create a dependent value dynamically,\nbased on information you won't have until run time.\nFor example, you might need information that changes repeatedly in the course of the browser session.\nAlso, your injectable service might not have independent access to the source of the information.</p>\n<p translation-origin=\"off\">In cases like this you can use a <em>factory provider</em>.\nFactory providers can also be useful when creating an instance of a dependency from\na third-party library that wasn't designed to work with DI.</p>\n<p translation-origin=\"off\">For example, suppose <code>HeroService</code> must hide <em>secret</em> heroes from normal users.\nOnly authorized users should see secret heroes.</p>\n<p translation-origin=\"off\">Like  <code>EvenBetterLogger</code>, <code>HeroService</code> needs to know if the user is authorized to see secret heroes.\nThat authorization can change during the course of a single application session,\nas when you log in a different user.</p>\n<p translation-origin=\"off\">Let's say you don't want to inject <code>UserService</code> directly into <code>HeroService</code>, because you don't want to complicate that service with security-sensitive information.\n<code>HeroService</code> won't have direct access to the user information to decide\nwho is authorized and who isn't.</p>\n<p translation-origin=\"off\">To resolve this, we give the <code>HeroService</code> constructor a boolean flag to control display of secret heroes.</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.ts\" region=\"internals\" header=\"src/app/heroes/hero.service.ts (excerpt)\" linenums=\"false\">\nconstructor(\n  private logger: Logger,\n  private isAuthorized: boolean) { }\n\ngetHeroes() {\n  let auth = this.isAuthorized ? 'authorized ' : 'unauthorized';\n  this.logger.log(`Getting heroes for ${auth} user.`);\n  return HEROES.filter(hero => this.isAuthorized || !hero.isSecret);\n}\n\n</code-example>\n<p translation-origin=\"off\">You can inject <code>Logger</code>, but you can't inject the  <code>isAuthorized</code> flag. Instead, you can use a factory provider to create a new logger instance for <code>HeroService</code>.</p>\n<p translation-origin=\"off\">A factory provider needs a factory function.</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"factory\" header=\"src/app/heroes/hero.service.provider.ts (excerpt)\" linenums=\"false\">\nlet heroServiceFactory = (logger: Logger, userService: UserService) => {\n  return new HeroService(logger, userService.user.isAuthorized);\n};\n\n</code-example>\n<p translation-origin=\"off\">Although <code>HeroService</code> has no access to <code>UserService</code>, the factory function does.\nYou inject both <code>Logger</code> and <code>UserService</code> into the factory provider\nand let the injector pass them along to the factory function.</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"provider\" header=\"src/app/heroes/hero.service.provider.ts (excerpt)\" linenums=\"false\">\nexport let heroServiceProvider =\n  { provide: HeroService,\n    useFactory: heroServiceFactory,\n    <a href=\"api/core/ConstructorSansProvider#deps\" class=\"code-anchor\">deps</a>: [Logger, UserService]\n  };\n\n</code-example>\n<ul>\n<li>\n<p translation-origin=\"off\">The <code>useFactory</code> field tells Angular that the provider is a factory function whose implementation is <code>heroServiceFactory</code>.</p>\n</li>\n<li>\n<p translation-origin=\"off\">The <code><a href=\"api/core/ConstructorSansProvider#deps\" class=\"code-anchor\">deps</a></code> property is an array of <a href=\"guide/dependency-injection#token\">provider tokens</a>.\nThe <code>Logger</code> and <code>UserService</code> classes serve as tokens for their own class providers.\nThe injector resolves these tokens and injects the corresponding services into the matching factory function parameters.</p>\n</li>\n</ul>\n<p translation-origin=\"off\">Notice that you captured the factory provider in an exported variable, <code>heroServiceProvider</code>.\nThis extra step makes the factory provider reusable.\nYou can configure a provider of <code>HeroService</code> with this variable wherever you need it.\nIn this sample, you need it only in <code>HeroesComponent</code>,\nwhere <code>heroServiceProvider</code> replaces <code>HeroService</code> in the metadata <code>providers</code> array.</p>\n<p translation-origin=\"off\">The following shows the new and the old implementations side-by-side.</p>\n<code-tabs>\n\n  <code-pane header=\"src/app/heroes/heroes.component (v3)\" path=\"dependency-injection/src/app/heroes/heroes.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }          from '@angular/core';\nimport { heroServiceProvider } from './hero.service.provider';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  providers: [ heroServiceProvider ],\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;h2>Heroes&#x3C;/h2>\n    &#x3C;app-hero-list>&#x3C;/app-hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/heroes.component (v2)\" path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\nimport { HeroService } from './hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  providers: [ HeroService ],\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;h2>Heroes&#x3C;/h2>\n    &#x3C;app-hero-list>&#x3C;/app-hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n</code-tabs>\n<h2 translation-origin=\"off\" id=\"predefined-tokens-and-multiple-providers\">Predefined tokens and multiple providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#predefined-tokens-and-multiple-providers\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-origin=\"off\">Angular provides a number of built-in injection-token constants that you can use to customize the behavior of\nvarious systems. </p>\n<p translation-origin=\"off\">For example, you can use the following built-in tokens as hooks into the frameworkâ€™s bootstrapping and initialization process.<br>\nA provider object can associate any of these injection tokens with one or more callback functions that take app-specific initialization actions.</p>\n<ul>\n<li>\n<p translation-origin=\"off\"><a href=\"api/core/PLATFORM_INITIALIZER\">PLATFORM_INITIALIZER</a>: Callback is invoked when a platform is initialized.</p>\n</li>\n<li>\n<p translation-origin=\"off\"><a href=\"api/core/APP_BOOTSTRAP_LISTENER\">APP_BOOTSTRAP_LISTENER</a>: Callback is invoked for each component that is bootstrapped. The handler function receives the ComponentRef instance of the bootstrapped component.</p>\n</li>\n<li>\n<p translation-origin=\"off\"><a href=\"api/core/APP_INITIALIZER\">APP_INITIALIZER</a>: Callback is invoked before an app is initialized. All registered initializers can optionally return a Promise. All initializer functions that return Promises must be resolved before the application is bootstrapped. If one of the initializers fails to resolves, the application is not bootstrapped.</p>\n</li>\n</ul>\n<p translation-origin=\"off\">The provider object can have a third option, <code>multi: true</code>, which you can use with <code><a href=\"api/core/APP_INITIALIZER\" class=\"code-anchor\">APP_INITIALIZER</a></code>\nto register multiple handlers for the provide event.</p>\n<p translation-origin=\"off\">For example, when bootstrapping an application, you can register many initializers using the same token.</p>\n<code-example>\nexport const APP_TOKENS = [\n { provide: <a href=\"api/core/PLATFORM_INITIALIZER\" class=\"code-anchor\">PLATFORM_INITIALIZER</a>, useFactory: platformInitialized, multi: true    },\n { provide: <a href=\"api/core/APP_INITIALIZER\" class=\"code-anchor\">APP_INITIALIZER</a>, useFactory: delayBootstrapping, multi: true },\n { provide: <a href=\"api/core/APP_BOOTSTRAP_LISTENER\" class=\"code-anchor\">APP_BOOTSTRAP_LISTENER</a>, useFactory: appBootstrapped, multi: true },\n];\n</code-example>\n<p translation-origin=\"off\">Multiple providers can be associated with a single token in other areas as well.\nFor example, you can register a custom form validator using the built-in <a href=\"api/forms/NG_VALIDATORS\">NG_VALIDATORS</a> token,\nand provide multiple instances of a given validator provider by using the <code>multi: true</code> property in the provider object.\nAngular adds your custom validators to the existing collection.</p>\n<p translation-origin=\"off\">The Router also makes use of multiple providers associated with a single token.\nWhen you provide multiple sets of routes using <a href=\"api/router/RouterModule#forroot\">RouterModule.forRoot</a>\nand <a href=\"api/router/RouterModule#forchild\">RouterModule.forChild</a> in a single module,\nthe <a href=\"api/router/ROUTES\">ROUTES</a> token combines all the different provided sets of routes into a single value.</p>\n<div class=\"alert is-helpful> <p translation-origin=\" off&#x22;=\"\">Search for <a href=\"api?type=const\">Constants in API documentation</a> to find more built-in tokens. <p></p>\n</div>\n<a id=\"tree-shakable-provider\"></a>\n<a id=\"tree-shakable-providers\"></a>\n<h2 translation-origin=\"off\" id=\"tree-shakable-providers\">Tree-shakable providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#tree-shakable-providers\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-origin=\"off\">Tree shaking refers to a compiler option that removes code from the final bundle if that code not referenced in an application.\nWhen providers are tree-shakable, the Angular compiler removes the associated\nservices from the final output when it determines that they are not used in your application.\nThis significantly reduces the size of your bundles.</p>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\">Ideally, if an application isn't injecting a service, it shouldn't be included in the final output.\nHowever, Angular has to be able to identify at build time whether the service will be required or not.\nBecause it's always possible to inject a service directly using <code>injector.get(Service)</code>,\nAngular can't identify all of the places in your code where this injection could happen,\nso it has no choice but to include the service in the injector.\nThus, services provided at the NgModule or component level are not tree-shakable.</p>\n</div>\n<p translation-origin=\"off\">The following example of non-tree-shakable providers in Angular configures a service provider for the injector of an NgModule.</p>\n<code-example path=\"dependency-injection/src/app/tree-shaking/service-and-module.ts\" header=\"src/app/tree-shaking/service-and-modules.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>, <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Service {\n  doSomething(): void {\n  }\n}\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [Service],\n})\nexport class ServiceModule {\n}\n\n\n</code-example>\n<p translation-origin=\"off\">This module can then be imported into your application module\nto make the service available for injection in your app,\nas shown in the following example.</p>\n<code-example path=\"dependency-injection/src/app/tree-shaking/app.module.ts\" header=\"src/app/tree-shaking/app.modules.ts\" linenums=\"false\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    RouterModule.forRoot([]),\n    ServiceModule,\n  ],\n})\nexport class AppModule {\n}\n\n\n</code-example>\n<p translation-origin=\"off\">When <code>ngc</code> runs, it compiles <code>AppModule</code> into a module factory, which contains definitions for all the providers declared in all the modules it includes. At runtime, this factory becomes an injector that instantiates these services.</p>\n<p translation-origin=\"off\">Tree-shaking doesn't work here because Angular can't decide to exclude one chunk of code (the provider definition for the service within the module factory) based on whether another chunk of code (the service class) is used. To make services tree-shakable, the information about how to construct an instance of the service (the provider definition) needs to be a part of the service class itself.</p>\n<h3 translation-origin=\"off\" id=\"creating-tree-shakable-providers\">Creating tree-shakable providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#creating-tree-shakable-providers\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-origin=\"off\">You can make a provider tree-shakable by specifying it in the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator on the service itself, rather than in the metadata for the NgModule or component that depends on the service.</p>\n<p translation-origin=\"off\">The following example shows the tree-shakable equivalent to the <code>ServiceModule</code> example above.</p>\n<code-example path=\"dependency-injection/src/app/tree-shaking/service.ts\" header=\"src/app/tree-shaking/service.ts\" linenums=\"false\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class Service {\n}\n\n\n</code-example>\n<p translation-origin=\"off\">The service can be instantiated by configuring a factory function, as in the following example.</p>\n<code-example path=\"dependency-injection/src/app/tree-shaking/service.0.ts\" header=\"src/app/tree-shaking/service.0.ts\" linenums=\"false\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n  useFactory: () => new Service('dependency'),\n})\nexport class Service {\n  constructor(private dep: string) {\n  }\n}\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\">To override a tree-shakable provider, configure the injector of a specific NgModule or component with another provider, using the <code>providers: []</code> array syntax of the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> or <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator.</p>\n</div>\n\n</div>\n\n<!-- links to this doc:\n - guide/dependency-injection\n - guide/dependency-injection-in-action\n - guide/hierarchical-dependency-injection\n - guide/providers\n - guide/upgrade\n-->\n<!-- links from this doc:\n - api/animations/browser/testing/MockAnimationDriver#log\n - api/common/http/HttpErrorResponse#message\n - api/core/APP_BOOTSTRAP_LISTENER\n - api/core/APP_INITIALIZER\n - api/core/Component\n - api/core/Component#template\n - api/core/ConstructorSansProvider#deps\n - api/core/Inject\n - api/core/Injectable\n - api/core/Injectable#providedIn\n - api/core/InjectionToken\n - api/core/NgModule\n - api/core/NgModule#imports\n - api/core/PLATFORM_INITIALIZER\n - api/core/Provider\n - api/forms/NG_VALIDATORS\n - api/platform-browser/BrowserModule\n - api/router/ROUTES\n - api/router/Router#config\n - api/router/RouterModule#forchild\n - api/router/RouterModule#forroot\n - api?type=const\n - guide/dependency-injection#token\n - guide/dependency-injection-providers#aliased-class-providers\n - guide/dependency-injection-providers#alternative-class-providers\n - guide/dependency-injection-providers#class-providers-with-dependencies\n - guide/dependency-injection-providers#creating-tree-shakable-providers\n - guide/dependency-injection-providers#dependency-providers\n - guide/dependency-injection-providers#factory-providers\n - guide/dependency-injection-providers#non-class-dependencies\n - guide/dependency-injection-providers#predefined-tokens-and-multiple-providers\n - guide/dependency-injection-providers#the-provider-object-literal\n - guide/dependency-injection-providers#tree-shakable-providers\n - guide/dependency-injection-providers#value-providers\n - guide/glossary#di-token\n - guide/glossary#provider\n - https://github.com/angular/angular/edit/master/aio/content/guide/dependency-injection-providers.md?message=docs%3A%20describe%20your%20change...\n-->"
}