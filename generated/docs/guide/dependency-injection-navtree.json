{"id":"guide/dependency-injection-navtree","title":"Navigate the component tree with DI","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/angular/angular-cn/edit/cn/aio/content/guide/dependency-injection-navtree.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"navigate-the-component-tree-with-di\" translation-result=\"on\">使用 DI 浏览组件树<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#navigate-the-component-tree-with-di\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Navigate the component tree with DI<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#navigate-the-component-tree-with-di\"><i class=\"material-icons\">link</i></a></h1>\n\n<div class=\"callout is-critical\">\n<header ng-should-translate=\"\" translation-result=\"on\">已标记为归档</header><header ng-should-translate=\"\" translation-origin=\"off\">Marked for archiving</header>\n\n<p translation-result=\"on\">为确保你拥有最佳的体验，本主题已标记为归档，直到我们确定其清楚地传达了最准确的信息为止。</p><p translation-origin=\"off\">To ensure that you have the best experience possible, this topic is marked for archiving until we determine that it clearly conveys the most accurate information possible.</p>\n\n<p translation-result=\"on\">同时，下列主题可能会有所帮助：<a href=\"guide/hierarchical-dependency-injection\">多级注入器</a>。</p><p translation-origin=\"off\">In the meantime, this topic might be helpful: <a href=\"guide/hierarchical-dependency-injection\">Hierarchical injectors</a>.</p>\n\n<p translation-result=\"on\">如果你认为不应将此内容归档，请提交 <a href=\"https://github.com/angular/angular/issues/new?template=3-docs-bug.md\">GitHub 问题</a>。</p><p translation-origin=\"off\">If you think this content should not be archived, please file a <a href=\"https://github.com/angular/angular/issues/new?template=3-docs-bug.md\">GitHub issue</a>.</p>\n\n</div>\n<p translation-result=\"on\">应用的组件之间经常需要共享信息。你通常要用松耦合的技术来共享信息，比如数据绑定和服务共享。但是有时候让一个组件直接引用另一个组件还是很有意义的。比如，你需要通过另一个组件的直接引用来访问其属性或调用其方法。</p><p translation-origin=\"off\">Application components often need to share information.\nYou can often use loosely coupled techniques for sharing information, such as data binding and service sharing, but sometimes it makes sense for one component to have a direct reference to another component.\nYou need a direct reference, for instance, to access values or call methods on that component.</p>\n\n<p translation-result=\"on\">在 Angular 中获取组件引用略微有些棘手。Angular 组件本身并没有一棵可以用编程方式检查或浏览的树。其父子关系是通过组件的<a href=\"guide/glossary#view\">视图对象</a>间接建立的。</p><p translation-origin=\"off\">Obtaining a component reference is a bit tricky in Angular.\nAngular components themselves do not have a tree that you can inspect or navigate programmatically.\nThe parent-child relationship is indirect, established through the components' <a href=\"guide/glossary#view\">view objects</a>.</p>\n\n<p translation-result=\"on\">每个组件都有一个<em>宿主视图</em>和一些<em>内嵌视图</em>。组件 A 的内嵌视图可以是组件 B 的宿主视图，而组件 B 还可以有它自己的内嵌视图。这意味着每个组件都有一棵以该组件的宿主视图为根节点的<a href=\"guide/glossary#view-hierarchy\">视图树</a>。</p><p translation-origin=\"off\">Each component has a <em>host view</em>, and can have additional <em>embedded views</em>.\nAn embedded view in component A is the host view of component B, which can in turn have embedded view.\nThis means that there is a <a href=\"guide/glossary#view-hierarchy\">view hierarchy</a> for each component, of which that component's host view is the root.</p>\n\n<p translation-result=\"on\">有一些用于在视图树中<em>向下</em>导航的 API。请到 <a href=\"api\">API 参考手册</a>中查看 <code><a href=\"api/core/Query\" class=\"code-anchor\">Query</a></code>、<code><a href=\"api/core/QueryList\" class=\"code-anchor\">QueryList</a></code>、<code><a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 和 <code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code>。</p><p translation-origin=\"off\">There is an API for navigating <em>down</em> the view hierarchy.\nCheck out <code><a href=\"api/core/Query\" class=\"code-anchor\">Query</a></code>, <code><a href=\"api/core/QueryList\" class=\"code-anchor\">QueryList</a></code>, <code><a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code>, and <code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> in the <a href=\"api\">API Reference</a>.</p>\n\n<p translation-result=\"on\">不存在用于获取父引用的公共 API。不过，由于每个组件的实例都会添加到注入器的容器中，因此你可以通过 Angular 的依赖注入来访问父组件。</p><p translation-origin=\"off\">There is no public API for acquiring a parent reference.\nHowever, because every component instance is added to an injector's container, you can use Angular dependency injection to reach a parent component.</p>\n\n<p translation-result=\"on\">本节描述的就是关于这种做法的一些技巧。</p><p translation-origin=\"off\">This section describes some techniques for doing that.</p>\n\n<p><a id=\"find-parent\"></a>\n<a id=\"known-parent\"></a></p>\n<h3 id=\"find-a-parent-component-of-known-type\" translation-result=\"on\">查找已知类型的父组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-component-of-known-type\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Find a parent component of known type<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-component-of-known-type\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你可以使用标准的类注入形式来获取类型已知的父组件。</p><p translation-origin=\"off\">You use standard class injection to acquire a parent component whose type you know.</p>\n\n<p translation-result=\"on\">在下面的例子中，父组件 <code>AlexComponent</code> 具有一些子组件，包括 <code>CathyComponent</code>：</p><p translation-origin=\"off\">In the following example, the parent <code>AlexComponent</code> has several children including a <code>CathyComponent</code>:</p>\n\n<p><a id=\"alex\"></a></p>\n<code-example header=\"parent-finder.component.ts (AlexComponent v.1)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-1\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'alex',\n  template: `\n    &lt;div class=\"a\"&gt;\n      &lt;h3&gt;{{name}}&lt;/h3&gt;\n      &lt;cathy&gt;&lt;/cathy&gt;\n      &lt;craig&gt;&lt;/craig&gt;\n      &lt;carol&gt;&lt;/carol&gt;\n    &lt;/div&gt;`,\n})\nexport class AlexComponent extends Base\n{\n  override name = 'Alex';\n}\n\n</code-example>\n<p translation-result=\"on\">在把 <code>AlexComponent</code> 注入到 <code>CathyComponent</code> 的构造函数中之后，<em>Cathy</em> 可以报告她是否能访问 <em>Alex</em>：</p><p translation-origin=\"off\"><em>Cathy</em> reports whether or not she has access to <em>Alex</em> after injecting an <code>AlexComponent</code> into her constructor:</p>\n\n<code-example header=\"parent-finder.component.ts (CathyComponent)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"cathy\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'cathy',\n  template: `\n  &lt;div class=\"c\"&gt;\n    &lt;h3&gt;Cathy&lt;/h3&gt;\n    {{alex ? 'Found' : 'Did not find'}} Alex via the component class.&lt;br&gt;\n  &lt;/div&gt;`\n})\nexport class CathyComponent {\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public alex?: AlexComponent ) { }\n}\n\n</code-example>\n<p translation-result=\"on\">注意，虽然为了安全起见我们用了 <a href=\"guide/dependency-injection-in-action#optional\">@Optional</a> 限定符，但是<live-example name=\"dependency-injection-in-action\"></live-example>中仍然会确认 <code>alex</code> 参数是否有值。</p><p translation-origin=\"off\">Notice that even though the <a href=\"guide/dependency-injection-in-action#optional\">@Optional</a> qualifier is there for safety, the <live-example name=\"dependency-injection-in-action\"></live-example> confirms that the <code>alex</code> parameter is set.</p>\n\n<p><a id=\"base-parent\"></a></p>\n<h3 id=\"unable-to-find-a-parent-by-its-base-class\" translation-result=\"on\">不能根据父组件的基类访问父组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#unable-to-find-a-parent-by-its-base-class\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Unable to find a parent by its base class<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#unable-to-find-a-parent-by-its-base-class\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果你<em>不知道</em>具体的父组件类怎么办？</p><p translation-origin=\"off\">What if you <em>don't</em> know the concrete parent component class?</p>\n\n<p translation-result=\"on\">可复用组件可能是多个组件的子组件。想象一个用于渲染相关金融工具的突发新闻的组件。出于商业原因，当市场上的数据流发生变化时，这些新组件会频繁调用其父组件。</p><p translation-origin=\"off\">A re-usable component might be a child of multiple components.\nImagine a component for rendering breaking news about a financial instrument.\nFor business reasons, this news component makes frequent calls directly into its parent instrument as changing market data streams by.</p>\n\n<p translation-result=\"on\">该应用可能定义了十几个金融工具组件。理想情况下，它们全都实现了同一个基类，你的 <code>NewsComponent</code> 也能理解其 API。</p><p translation-origin=\"off\">The app probably defines more than a dozen financial instrument components.\nIf you're lucky, they all implement the same base class whose API your <code>NewsComponent</code> understands.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">如果能查找实现了某个接口的组件当然更好。但那是不可能的。因为 TypeScript 接口在转译后的 JavaScript 中不存在，而 JavaScript 不支持接口。因此，找无可找。</p><p translation-origin=\"off\">Looking for components that implement an interface would be better.\nThat's not possible because TypeScript interfaces disappear from the transpiled JavaScript, which doesn't support interfaces.\nThere's no artifact to look for.</p>\n\n</div>\n<p translation-result=\"on\">这个设计并不怎么好。该例子是为了验证<em>组件是否能通过其父组件的基类来注入父组件</em>。</p><p translation-origin=\"off\">This isn't necessarily good design.\nThis example is examining <em>whether a component can inject its parent via the parent's base class</em>.</p>\n\n<p translation-result=\"on\">这个例子中的 <code>CraigComponent</code> 体现了此问题。<a href=\"guide/dependency-injection-navtree#alex\">往回看</a>，你可以看到 <code>Alex</code> 组件<em>扩展</em>（<em>继承</em>）了基类 <code>Base</code>。</p><p translation-origin=\"off\">The sample's <code>CraigComponent</code> explores this question.\n<a href=\"guide/dependency-injection-navtree#alex\">Looking back</a>, you see that the <code>Alex</code> component <em>extends</em> (<em>inherits</em>) from a class named <code>Base</code>.</p>\n\n<code-example header=\"parent-finder.component.ts (Alex class signature)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-class-signature\">\nexport class AlexComponent extends Base\n\n</code-example>\n<p translation-result=\"on\"><code>CraigComponent</code> 试图把 <code>Base</code> 注入到它的构造函数参数 <code>alex</code> 中，并汇报这次注入是否成功了。</p><p translation-origin=\"off\">The <code>CraigComponent</code> tries to inject <code>Base</code> into its <code>alex</code> constructor parameter and reports if it succeeded.</p>\n\n<code-example header=\"parent-finder.component.ts (CraigComponent)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"craig\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'craig',\n  template: `\n  &lt;div class=\"c\"&gt;\n    &lt;h3&gt;Craig&lt;/h3&gt;\n    {{alex ? 'Found' : 'Did not find'}} Alex via the base class.\n  &lt;/div&gt;`\n})\nexport class CraigComponent {\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public alex?: Base ) { }\n}\n\n</code-example>\n<p translation-result=\"on\">不幸的是，这不行！\n<live-example name=\"dependency-injection-in-action\"></live-example> 确认了 <code>alex</code> 参数为空。\n因此，<em>你不能通过父组件的基类注入它</em>。</p><p translation-origin=\"off\">Unfortunately, this doesn't work.\nThe <live-example name=\"dependency-injection-in-action\"></live-example> confirms that the <code>alex</code> parameter is null.\n<em>You cannot inject a parent by its base class.</em></p>\n\n<p><a id=\"class-interface-parent\"></a></p>\n<h3 id=\"find-a-parent-by-its-class-interface\" translation-result=\"on\">根据父组件的类接口查找它<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-by-its-class-interface\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Find a parent by its class interface<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-by-its-class-interface\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你可以通过父组件的<a href=\"guide/dependency-injection-in-action#class-interface\">类接口</a>来查找它。</p><p translation-origin=\"off\">You can find a parent component with a <a href=\"guide/dependency-injection-in-action#class-interface\">class interface</a>.</p>\n\n<p translation-result=\"on\">该父组件必须合作，以类接口令牌为名，为自己定义一个<em>别名提供者</em>。</p><p translation-origin=\"off\">The parent must cooperate by providing an <em>alias</em> to itself in the name of a class interface token.</p>\n\n<p translation-result=\"on\">回忆一下，Angular 总是会把组件实例添加到它自己的注入器中，因此<a href=\"guide/dependency-injection-navtree#known-parent\">以前</a>你才能把 <em>Alex</em> 注入到 <em>Cathy</em> 中。</p><p translation-origin=\"off\">Recall that Angular always adds a component instance to its own injector; that's why you could inject <em>Alex</em> into <em>Cathy</em> <a href=\"guide/dependency-injection-navtree#known-parent\">earlier</a>.</p>\n\n<p translation-result=\"on\">编写一个 <a href=\"guide/dependency-injection-in-action#useexisting\"><em>别名提供者</em></a>（一个 <code>provide</code> 对象字面量，其中有一个 <code>useExisting</code> 定义），创造了另一种方式来注入同一个组件实例，并把那个提供者添加到 <code>AlexComponent</code> <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 元数据的 <code>providers</code> 数组中。</p><p translation-origin=\"off\">Write an <a href=\"guide/dependency-injection-in-action#useexisting\"><em>alias provider</em></a> —a <code>provide</code> object literal with a <code>useExisting</code> definition— that creates an <em>alternative</em> way to inject the same component instance and add that provider to the <code>providers</code> array of the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> metadata for the <code>AlexComponent</code>.</p>\n\n<p><a id=\"alex-providers\"></a></p>\n<code-example header=\"parent-finder.component.ts (AlexComponent providers)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-providers\">\nproviders: [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; AlexComponent) }],\n\n</code-example>\n<p translation-result=\"on\"><a href=\"guide/dependency-injection-navtree#parent-token\">Parent</a> 是该提供者的类接口。\n<a href=\"guide/dependency-injection-in-action#forwardref\"><em>forwardRef</em></a> 用于打破循环引用，因为在你刚才这个定义中 <code>AlexComponent</code> 引用了自身。</p><p translation-origin=\"off\"><a href=\"guide/dependency-injection-navtree#parent-token\">Parent</a> is the provider's class interface token.\nThe <a href=\"guide/dependency-injection-in-action#forwardref\"><em>forwardRef</em></a> breaks the circular reference you just created by having the <code>AlexComponent</code> refer to itself.</p>\n\n<p translation-result=\"on\"><em>Alex</em> 的第三个子组件 <em>Carol</em>，把其父组件注入到了自己的 <code>parent</code> 参数中 —— 和你以前做过的一样。</p><p translation-origin=\"off\"><em>Carol</em>, the third of <em>Alex</em>'s child components, injects the parent into its <code>parent</code> parameter, the same way you've done it before.</p>\n\n<code-example header=\"parent-finder.component.ts (CarolComponent class)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"carol-class\">\nexport class CarolComponent {\n  name = 'Carol';\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent?: Parent ) { }\n}\n\n</code-example>\n<p translation-result=\"on\">下面是 <em>Alex</em> 及其家人的运行效果。</p><p translation-origin=\"off\">Here's <em>Alex</em> and family in action.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Alex in action\" src=\"generated/images/guide/dependency-injection-in-action/alex.png\" width=\"302\" height=\"374\">\n</div>\n<p><a id=\"parent-tree\"></a></p>\n<h3 id=\"find-a-parent-in-a-tree-with-skipself\" translation-result=\"on\">使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 在树中查找父级<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#使用-skipself-在树中查找父级\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Find a parent in a tree with <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-in-a-tree-with-skipself\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">想象一下组件树的一个分支：<em>Alice</em> -&gt; <em>Barry</em> -&gt; <em>Carol</em>。无论 <em>Alice</em> 还是 <em>Barry</em> 都实现了类接口 <code>Parent</code>。</p><p translation-origin=\"off\">Imagine one branch of a component hierarchy: <em>Alice</em> -&gt; <em>Barry</em> -&gt; <em>Carol</em>.\nBoth <em>Alice</em> and <em>Barry</em> implement the <code>Parent</code> class interface.</p>\n\n<p translation-result=\"on\"><em>Barry</em> 很为难。他需要访问他的母亲 <em>Alice</em>，同时他自己还是 <em>Carol</em> 的父亲。这意味着他必须同时<em>注入</em> <code>Parent</code> 类接口来找到 <em>Alice</em>，同时还要<em>提供</em>一个 <code>Parent</code> 来满足 <em>Carol</em> 的要求。</p><p translation-origin=\"off\"><em>Barry</em> is the problem.\nHe needs to reach his parent, <em>Alice</em>, and also be a parent to <em>Carol</em>.\nThat means he must both <em>inject</em> the <code>Parent</code> class interface to get <em>Alice</em> and <em>provide</em> a <code>Parent</code> to satisfy <em>Carol</em>.</p>\n\n<p translation-result=\"on\"><em>Barry</em> 的代码如下。</p><p translation-origin=\"off\">Here's <em>Barry</em>.</p>\n\n<code-example header=\"parent-finder.component.ts (BarryComponent)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"barry\">\nconst templateB = `\n  &lt;div class=\"b\"&gt;\n    &lt;div&gt;\n      &lt;h3&gt;{{name}}&lt;/h3&gt;\n      &lt;p&gt;My parent is {{parent?.name}}&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;carol&gt;&lt;/carol&gt;\n    &lt;chris&gt;&lt;/chris&gt;\n  &lt;/div&gt;`;\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector:   'barry',\n  template:   templateB,\n  providers:  [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; BarryComponent) }]\n})\nexport class BarryComponent implements Parent {\n  name = 'Barry';\n  constructor( @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent?: Parent ) { }\n}\n\n</code-example>\n<p translation-result=\"on\"><em>Barry</em> 的 <code>providers</code> 数组看起来和 <a href=\"guide/dependency-injection-navtree#alex-providers\"><em>Alex</em></a> 的一样。\n如果你准备继续像这样编写<a href=\"guide/dependency-injection-in-action#useexisting\"><em>别名提供者</em></a>，就应该创建一个辅助函数。</p><p translation-origin=\"off\"><em>Barry</em>'s <code>providers</code> array looks just like <a href=\"guide/dependency-injection-navtree#alex-providers\"><em>Alex</em>'s</a>.\nIf you're going to keep writing <a href=\"guide/dependency-injection-in-action#useexisting\"><em>alias providers</em></a> like this you should create a helper function.</p>\n\n<p translation-result=\"on\">现在，注意看 <em>Barry</em> 的构造函数。</p><p translation-origin=\"off\">For now, focus on <em>Barry</em>'s constructor.</p>\n\n<code-tabs>\n    <code-pane header=\"Barry's constructor\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"barry-ctor\">\nconstructor( @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent?: Parent ) { }\n\n</code-pane>\n    <code-pane header=\"Carol's constructor\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"carol-ctor\">\nconstructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent?: Parent ) { }\n\n</code-pane>\n</code-tabs>\n<p translation-result=\"on\">除增加了 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 装饰器之外，它和 <em>Carol</em> 的构造函数相同。</p><p translation-origin=\"off\">It's identical to <em>Carol</em>'s constructor except for the additional <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> decorator.</p>\n\n<p translation-result=\"on\">使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 有两个重要原因：</p><p translation-origin=\"off\"><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> is essential for two reasons:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">它告诉注入器开始从组件树中<em>高于</em>自己的位置（也就是父组件）开始搜索 <code>Parent</code> 依赖。</p><p translation-origin=\"off\">It tells the injector to start its search for a <code>Parent</code> dependency in a component <em>above</em> itself, which <em>is</em> what parent means.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果你省略了 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 装饰器，Angular 就会抛出循环依赖错误。</p><p translation-origin=\"off\">Angular throws a cyclic dependency error if you omit the <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> decorator.</p>\n\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nNG0200: Circular dependency in DI detected for BethComponent. Dependency path: BethComponent -&gt; Parent -&gt; BethComponent\n\n</code-example>\n</li>\n</ol>\n<p translation-result=\"on\">下面是 <em>Alice</em>、<em>Barry</em> 及其家人的运行效果。</p><p translation-origin=\"off\">Here's <em>Alice</em>, <em>Barry</em>, and family in action.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Alice in action\" src=\"generated/images/guide/dependency-injection-in-action/alice.png\" width=\"298\" height=\"631\">\n</div>\n<p><a id=\"parent-token\"></a></p>\n<h3 id=\"parent-class-interface\" translation-result=\"on\">父类接口<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#parent-class-interface\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Parent class interface<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#parent-class-interface\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你<a href=\"guide/dependency-injection-in-action#class-interface\">已经学过</a>，类接口是一个抽象类，它实际上用做接口而不是基类。</p><p translation-origin=\"off\">You <a href=\"guide/dependency-injection-in-action#class-interface\">learned earlier</a> that a class interface is an abstract class used as an interface rather than as a base class.</p>\n\n<p translation-result=\"on\">下面的例子定义了一个类接口 <code>Parent</code>。</p><p translation-origin=\"off\">The example defines a <code>Parent</code> class interface.</p>\n\n<code-example header=\"parent-finder.component.ts (Parent class-interface)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"parent\">\nexport abstract class Parent { abstract name: string; }\n\n</code-example>\n<p translation-result=\"on\"><code>Parent</code> 类接口定义了一个带类型的 <code>name</code> 属性，但没有实现它。这个 <code>name</code> 属性是父组件中唯一可供子组件调用的成员。这样的窄化接口帮助把子组件从它的父组件中解耦出来。</p><p translation-origin=\"off\">The <code>Parent</code> class interface defines a <code>name</code> property with a type declaration but <em>no implementation</em>.\nThe <code>name</code> property is the only member of a parent component that a child component can call.\nSuch a narrow interface helps decouple the child component class from its parent components.</p>\n\n<p translation-result=\"on\">一个组件想要作为父组件使用，就<em>应该</em>像 <code>AliceComponent</code> 那样实现这个类接口。</p><p translation-origin=\"off\">A component that could serve as a parent <em>should</em> implement the class interface as the <code>AliceComponent</code> does.</p>\n\n<code-example header=\"parent-finder.component.ts (AliceComponent class signature)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alice-class-signature\">\nexport class AliceComponent implements Parent\n\n</code-example>\n<p translation-result=\"on\">这样做可以增加代码的清晰度，但在技术上并不是必要的。虽然 <code>AlexComponent</code> 像 <code>Base</code> 类所要求的一样具有 <code>name</code> 属性，但它的类签名中并没有提及 <code>Parent</code>。</p><p translation-origin=\"off\">Doing so adds clarity to the code.\nBut it's not technically necessary.\nAlthough <code>AlexComponent</code> has a <code>name</code> property, as required by its <code>Base</code> class,\nits class signature doesn't mention <code>Parent</code>.</p>\n\n<code-example header=\"parent-finder.component.ts (AlexComponent class signature)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-class-signature\">\nexport class AlexComponent extends Base\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><code>AlexComponent</code> <em>应该</em>实现 <code>Parent</code> 才是一种正确的风格。这个例子中之所以没这样做，<em>只是</em>为了证明即使没有声明接口，代码也可以编译和运行。</p><p translation-origin=\"off\"><code>AlexComponent</code> <em>should</em> implement <code>Parent</code> as a matter of proper style.\nIt doesn't in this example <em>only</em> to demonstrate that the code will compile and run without the interface.</p>\n\n</div>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间： 2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core/TemplateRef\n-->\n<!-- links from this doc:\n - api\n - api/core/Component\n - api/core/ContentChildren\n - api/core/Optional\n - api/core/Query\n - api/core/QueryList\n - api/core/SkipSelf\n - api/core/ViewChildren\n - api/core/forwardRef\n - guide/dependency-injection-in-action#class-interface\n - guide/dependency-injection-in-action#forwardref\n - guide/dependency-injection-in-action#optional\n - guide/dependency-injection-in-action#useexisting\n - guide/dependency-injection-navtree#alex\n - guide/dependency-injection-navtree#alex-providers\n - guide/dependency-injection-navtree#find-a-parent-by-its-class-interface\n - guide/dependency-injection-navtree#find-a-parent-component-of-known-type\n - guide/dependency-injection-navtree#find-a-parent-in-a-tree-with-skipself\n - guide/dependency-injection-navtree#known-parent\n - guide/dependency-injection-navtree#navigate-the-component-tree-with-di\n - guide/dependency-injection-navtree#parent-class-interface\n - guide/dependency-injection-navtree#parent-token\n - guide/dependency-injection-navtree#unable-to-find-a-parent-by-its-base-class\n - guide/dependency-injection-navtree#不能根据父组件的基类访问父组件\n - guide/dependency-injection-navtree#使用-di-浏览组件树\n - guide/dependency-injection-navtree#使用-skipself-在树中查找父级\n - guide/dependency-injection-navtree#查找已知类型的父组件\n - guide/dependency-injection-navtree#根据父组件的类接口查找它\n - guide/dependency-injection-navtree#父类接口\n - guide/glossary#view\n - guide/glossary#view-hierarchy\n - guide/hierarchical-dependency-injection\n - https://github.com/angular/angular-cn/edit/cn/aio/content/guide/dependency-injection-navtree.md?message=docs%3A%20请简述你的修改...\n - https://github.com/angular/angular/issues/new?template=3-docs-bug.md\n-->"}