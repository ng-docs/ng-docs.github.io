{
  "id": "guide/dependency-injection-navtree",
  "title": "Navigate the component tree with DI",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/dependency-injection-navtree.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"navigate-the-component-tree-with-di\" translation-result=\"on\">使用 DI 浏览组件树<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#navigate-the-component-tree-with-di\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"navigate-the-component-tree-with-di\">Navigate the component tree with DI<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#navigate-the-component-tree-with-di\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">应用的组件之间经常需要共享信息。你通常要用松耦合的技术来共享信息，比如数据绑定和服务共享。但是有时候让一个组件直接引用另一个组件还是很有意义的。\n例如，你需要通过另一个组件的直接引用来访问其属性或调用其方法。</p><p translation-origin=\"off\">Application components often need to share information.\nYou can often use loosely coupled techniques for sharing information,\nsuch as data binding and service sharing,\nbut sometimes it makes sense for one component to have a direct reference to another component.\nYou need a direct reference, for instance, to access values or call methods on that component.</p>\n\n<p translation-result=\"on\">在 Angular 中获取组件引用略微有些棘手。\nAngular 组件本身并没有一棵可以用编程方式检查或浏览的树。\n其父子关系是通过组件的<a href=\"guide/glossary#view\">视图对象</a>间接建立的。</p><p translation-origin=\"off\">Obtaining a component reference is a bit tricky in Angular.\nAngular components themselves do not have a tree that you can\ninspect or navigate programmatically. The parent-child relationship is indirect,\nestablished through the components' <a href=\"guide/glossary#view\">view objects</a>.</p>\n\n<p translation-result=\"on\">每个组件都有一个<em>宿主视图</em>和一些<em>内嵌视图</em>。\n组件 A 的内嵌视图可以是组件 B 的宿主视图，而组件 B 还可以有它自己的内嵌视图。\n这意味着每个组件都有一棵以该组件的宿主视图为根节点的<a href=\"guide/glossary#view-hierarchy\">视图树</a>。</p><p translation-origin=\"off\">Each component has a <em>host view</em>, and can have additional <em>embedded views</em>.\nAn embedded view in component A is the\nhost view of component B, which can in turn have embedded view.\nThis means that there is a <a href=\"guide/glossary#view-hierarchy\">view hierarchy</a> for each component,\nof which that component's host view is the root.</p>\n\n<p translation-result=\"on\">有一些用于在视图树中<em>向下</em>导航的 API。\n请到 <a href=\"api/\">API 参考手册</a>中查看 <code><a href=\"api/core/Query\" class=\"code-anchor\">Query</a></code>、<code><a href=\"api/core/QueryList\" class=\"code-anchor\">QueryList</a></code>、<code><a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 和 <code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code>。</p><p translation-origin=\"off\">There is an API for navigating <em>down</em> the view hierarchy.\nCheck out <code><a href=\"api/core/Query\" class=\"code-anchor\">Query</a></code>, <code><a href=\"api/core/QueryList\" class=\"code-anchor\">QueryList</a></code>, <code><a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code>, and <code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code>\nin the <a href=\"api/\">API Reference</a>.</p>\n\n<p translation-result=\"on\">不存在用于获取父引用的公共 API。\n不过，由于每个组件的实例都会添加到注入器的容器中，因此你可以通过 Angular 的依赖注入来访问父组件。</p><p translation-origin=\"off\">There is no public API for acquiring a parent reference.\nHowever, because every component instance is added to an injector's container,\nyou can use Angular dependency injection to reach a parent component.</p>\n\n<p translation-result=\"on\">本节描述的就是关于这种做法的一些技巧。</p><p translation-origin=\"off\">This section describes some techniques for doing that.</p>\n\n<a id=\"find-parent\"></a>\n<a id=\"known-parent\"></a>\n<h3 id=\"find-a-parent-component-of-known-type\" translation-result=\"on\">查找已知类型的父组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-component-of-known-type\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"find-a-parent-component-of-known-type\">Find a parent component of known type<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-component-of-known-type\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你可以使用标准的类注入形式来获取类型已知的父组件。</p><p translation-origin=\"off\">You use standard class injection to acquire a parent component whose type you know.</p>\n\n<p translation-result=\"on\">在下面的例子中，父组件 <code>AlexComponent</code> 具有一些子组件，包括 <code>CathyComponent</code>：</p><p translation-origin=\"off\">In the following example, the parent <code>AlexComponent</code> has several children including a <code>CathyComponent</code>:</p>\n\n<a id=\"alex\"></a>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-1\" header=\"parent-finder.component.ts (AlexComponent v.1)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'alex',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;div class=\"<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>\">\n      &#x3C;h3>{{name}}&#x3C;/h3>\n      &#x3C;cathy>&#x3C;/cathy>\n      &#x3C;craig>&#x3C;/craig>\n      &#x3C;carol>&#x3C;/carol>\n    &#x3C;/div>`,\n})\nexport class AlexComponent extends Base\n{\n  name = 'Alex';\n}\n\n</code-example>\n<p translation-result=\"on\">在把 <code>AlexComponent</code> 注入到 <code>CathyComponent</code> 的构造函数中之后，<em>Cathy</em> 可以报告她是否能访问 <em>Alex</em>：</p><p translation-origin=\"off\"><em>Cathy</em> reports whether or not she has access to <em>Alex</em>\nafter injecting an <code>AlexComponent</code> into her constructor:</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"cathy\" header=\"parent-finder.component.ts (CathyComponent)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'cathy',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n  &#x3C;div class=\"c\">\n    &#x3C;h3>Cathy&#x3C;/h3>\n    {{alex ? 'Found' : 'Did not find'}} Alex via the component class.&#x3C;br>\n  &#x3C;/div>`\n})\nexport class CathyComponent {\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public alex: AlexComponent ) { }\n}\n\n</code-example>\n<p translation-result=\"on\">注意，虽然为了安全起见我们用了 <a href=\"guide/dependency-injection-in-action#optional\">@Optional</a> 限定符，但是<live-example name=\"dependency-injection-in-action\"></live-example>中仍然会确认 <code>alex</code> 参数是否有值。</p><p translation-origin=\"off\">Notice that even though the <a href=\"guide/dependency-injection-in-action#optional\">@Optional</a> qualifier\nis there for safety,\nthe <live-example name=\"dependency-injection-in-action\"></live-example>\nconfirms that the <code>alex</code> parameter is set.</p>\n\n<a id=\"base-parent\"></a>\n<h3 id=\"unable-to-find-a-parent-by-its-base-class\" translation-result=\"on\">不能根据父组件的基类访问父组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#unable-to-find-a-parent-by-its-base-class\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"unable-to-find-a-parent-by-its-base-class\">Unable to find a parent by its base class<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#unable-to-find-a-parent-by-its-base-class\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果你<em>不知道</em>具体的父组件类怎么办？</p><p translation-origin=\"off\">What if you <em>don't</em> know the concrete parent component class?</p>\n\n<p translation-result=\"on\">可复用组件可能是多个组件的子组件。想象一个用于呈现相关金融工具的突发新闻的组件。\n出于商业原因，当市场上的数据流发生变化时，这些新组件会频繁调用其父组件。</p><p translation-origin=\"off\">A re-usable component might be a child of multiple components.\nImagine a component for rendering breaking news about a financial instrument.\nFor business reasons, this news component makes frequent calls\ndirectly into its parent instrument as changing market data streams by.</p>\n\n<p translation-result=\"on\">该应用可能定义了十几个金融工具组件。理想情况下，它们全都实现了同一个基类，你的 <code>NewsComponent</code> 也能理解其 API。 </p><p translation-origin=\"off\">The app probably defines more than a dozen financial instrument components.\nIf you're lucky, they all implement the same base class whose API your <code>NewsComponent</code> understands.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">如果能查找实现了某个接口的组件当然更好。\n但那是不可能的。因为 TypeScript 接口在转译后的 JavaScript 中不存在，而 JavaScript 不支持接口。\n因此，找无可找。</p><p translation-origin=\"off\">Looking for components that implement an interface would be better.\nThat's not possible because TypeScript interfaces disappear\nfrom the transpiled JavaScript, which doesn't support interfaces.\nThere's no artifact to look for.</p>\n\n</div>\n<p translation-result=\"on\">这个设计并不怎么好。\n该例子是为了验证<em>组件是否能通过其父组件的基类来注入父组件</em>。</p><p translation-origin=\"off\">This isn't necessarily good design.\nThis example is examining <em>whether a component can\ninject its parent via the parent's base class</em>.</p>\n\n<p translation-result=\"on\">这个例子中的 <code>CraigComponent</code> 体现了此问题。<a href=\"guide/dependency-injection-navtree#alex\">往回看</a>，你可以看到 <code>Alex</code> 组件<em>扩展</em>（<em>继承</em>）了基类 <code>Base</code>。</p><p translation-origin=\"off\">The sample's <code>CraigComponent</code> explores this question. <a href=\"guide/dependency-injection-navtree#alex\">Looking back</a>,\nyou see that the <code>Alex</code> component <em>extends</em> (<em>inherits</em>) from a class named <code>Base</code>.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-class-signature\" header=\"parent-finder.component.ts (Alex class signature)\" linenums=\"false\">\nexport class AlexComponent extends Base\n\n</code-example>\n<p translation-result=\"on\"><code>CraigComponent</code> 试图把 <code>Base</code> 注入到它的构造函数参数 <code>alex</code> 中，并汇报这次注入是否成功了。</p><p translation-origin=\"off\">The <code>CraigComponent</code> tries to inject <code>Base</code> into its <code>alex</code> constructor parameter and reports if it succeeded.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"craig\" header=\"parent-finder.component.ts (CraigComponent)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'craig',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n  &#x3C;div class=\"c\">\n    &#x3C;h3>Craig&#x3C;/h3>\n    {{alex ? 'Found' : 'Did not find'}} Alex via the base class.\n  &#x3C;/div>`\n})\nexport class CraigComponent {\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public alex: Base ) { }\n}\n\n</code-example>\n<p translation-result=\"on\">不幸的是，这不行！\n<live-example name=\"dependency-injection-in-action\"></live-example> 确认了 <code>alex</code> 参数为空。\n因此，<em>你不能通过父组件的基类注入它</em>。</p><p translation-origin=\"off\">Unfortunately, this doesn't work.\nThe <live-example name=\"dependency-injection-in-action\"></live-example>\nconfirms that the <code>alex</code> parameter is null.\n<em>You cannot inject a parent by its base class.</em></p>\n\n<a id=\"class-interface-parent\"></a>\n<h3 id=\"find-a-parent-by-its-class-interface\" translation-result=\"on\">根据父组件的类接口查找它<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-by-its-class-interface\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"find-a-parent-by-its-class-interface\">Find a parent by its class interface<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-by-its-class-interface\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你可以通过父组件的<a href=\"guide/dependency-injection-in-action#class-interface\">类接口</a>来查找它。</p><p translation-origin=\"off\">You can find a parent component with a <a href=\"guide/dependency-injection-in-action#class-interface\">class interface</a>.</p>\n\n<p translation-result=\"on\">该父组件必须合作，以类接口令牌为名，为自己定义一个<em>别名提供商</em>。</p><p translation-origin=\"off\">The parent must cooperate by providing an <em>alias</em> to itself in the name of a class interface token.</p>\n\n<p translation-result=\"on\">回忆一下，Angular 总是会把组件实例添加到它自己的注入器中，因此<a href=\"guide/dependency-injection-navtree#known-parent\">以前</a>你才能把 <em>Alex</em> 注入到 <em>Cathy</em> 中。</p><p translation-origin=\"off\">Recall that Angular always adds a component instance to its own injector;\nthat's why you could inject <em>Alex</em> into <em>Cathy</em> <a href=\"guide/dependency-injection-navtree#known-parent\">earlier</a>.</p>\n\n<p translation-result=\"on\">编写一个 <a href=\"guide/dependency-injection-in-action#useexisting\"><em>别名提供商</em></a>（一个 <code>provide</code> 对象字面量，其中有一个 <code>useExisting</code> 定义），创造了另一种方式来注入同一个组件实例，并把那个提供商添加到 <code>AlexComponent</code> <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 元数据的 <code>providers</code> 数组中。</p><p translation-origin=\"off\">Write an <a href=\"guide/dependency-injection-in-action#useexisting\"><em>alias provider</em></a>—a <code>provide</code> object literal with a <code>useExisting</code>\ndefinition—that creates an <em>alternative</em> way to inject the same component instance\nand add that provider to the <code>providers</code> array of the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> metadata for the <code>AlexComponent</code>.</p>\n\n<a id=\"alex-providers\"></a>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-providers\" header=\"parent-finder.component.ts (AlexComponent providers)\" linenums=\"false\">\nproviders: [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() => AlexComponent) }],\n\n</code-example>\n<p translation-result=\"on\"><a href=\"guide/dependency-injection-navtree#parent-token\">Parent</a> 是该提供商的类接口。\n<a href=\"guide/dependency-injection-in-action#forwardref\"><em>forwardRef</em></a> 用于打破循环引用，因为在你刚才这个定义中 <code>AlexComponent</code> 引用了自身。</p><p translation-origin=\"off\"><a href=\"guide/dependency-injection-navtree#parent-token\">Parent</a> is the provider's class interface token.\nThe <a href=\"guide/dependency-injection-in-action#forwardref\"><em>forwardRef</em></a> breaks the circular reference you just created by having the <code>AlexComponent</code> refer to itself.</p>\n\n<p translation-result=\"on\"><em>Alex</em> 的第三个子组件 <em>Carol</em>，把其父组件注入到了自己的 <code>parent</code> 参数中 —— 和你以前做过的一样。</p><p translation-origin=\"off\"><em>Carol</em>, the third of <em>Alex</em>'s child components, injects the parent into its <code>parent</code> parameter,\nthe same way you've done it before.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"carol-class\" header=\"parent-finder.component.ts (CarolComponent class)\" linenums=\"false\">\nexport class CarolComponent {\n  name = 'Carol';\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent: Parent ) { }\n}\n\n</code-example>\n<p translation-result=\"on\">下面是 <em>Alex</em> 及其家人的运行效果。</p><p translation-origin=\"off\">Here's <em>Alex</em> and family in action.</p>\n\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/alex.png\" alt=\"Alex in action\" width=\"302\" height=\"374\">\n</figure>\n<a id=\"parent-tree\"></a>\n<h3 id=\"find-a-parent-in-a-tree-with-skipself\" translation-result=\"on\">使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 在树中查找父组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-in-a-tree-with-skipself\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"find-a-parent-in-a-tree-with-skipself\">Find a parent in a tree with <em>@SkipSelf()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-in-a-tree-with-skipself\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">想象一下组件树的一个分支：<em>Alice</em> -> <em>Barry</em> -> <em>Carol</em>。\n无论 <em>Alice</em> 还是 <em>Barry</em> 都实现了类接口 <code>Parent</code>。</p><p translation-origin=\"off\">Imagine one branch of a component hierarchy: <em>Alice</em> -> <em>Barry</em> -> <em>Carol</em>.\nBoth <em>Alice</em> and <em>Barry</em> implement the `Parent' class interface.</p>\n\n<p translation-result=\"on\"><em>Barry</em> 很为难。他需要访问他的母亲 <em>Alice</em>，同时他自己还是 <em>Carol</em> 的父亲。\n这意味着他必须同时<em>注入</em> <code>Parent</code> 类接口来找到 <em>Alice</em>，同时还要<em>提供</em>一个 <code>Parent</code> 来满足 <em>Carol</em> 的要求。</p><p translation-origin=\"off\"><em>Barry</em> is the problem. He needs to reach his parent, <em>Alice</em>, and also be a parent to <em>Carol</em>.\nThat means he must both <em>inject</em> the <code>Parent</code> class interface to get <em>Alice</em> and\n<em>provide</em> a <code>Parent</code> to satisfy <em>Carol</em>.</p>\n\n<p translation-result=\"on\"><em>Barry</em> 的代码如下。</p><p translation-origin=\"off\">Here's <em>Barry</em>.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"barry\" header=\"parent-finder.component.ts (BarryComponent)\" linenums=\"false\">\nconst templateB = `\n  &#x3C;div class=\"b\">\n    &#x3C;div>\n      &#x3C;h3>{{name}}&#x3C;/h3>\n      &#x3C;p>My parent is {{parent?.name}}&#x3C;/p>\n    &#x3C;/div>\n    &#x3C;carol>&#x3C;/carol>\n    &#x3C;chris>&#x3C;/chris>\n  &#x3C;/div>`;\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector:   'barry',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>:   templateB,\n  providers:  [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() => BarryComponent) }]\n})\nexport class BarryComponent implements Parent {\n  name = 'Barry';\n  constructor( @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent: Parent ) { }\n}\n\n</code-example>\n<p translation-result=\"on\"><em>Barry</em> 的 <code>providers</code> 数组看起来和 <a href=\"guide/dependency-injection-navtree#alex-providers\" translation-result=\"on\"><em>别名提供商</em></a><a href=\"guide/dependency-injection-navtree#alex-providers\" translation-origin=\"off\"><em>Alex</em></a> 的一样。\n如果你准备继续像这样编写，就应该创建一个<a href=\"guide/dependency-injection-navtree#provideparent\">辅助函数</a>。</p><p translation-origin=\"off\"><em>Barry</em>'s <code>providers</code> array looks just like <a href=\"guide/dependency-injection-navtree#alex-providers\"><em>Alex</em>'s</a>.\nIf you're going to keep writing <a href=\"guide/dependency-injection-in-action#useexisting\"><em>alias providers</em></a> like this you should create a <a href=\"guide/dependency-injection-navtree#provideparent\">helper function</a>.</p>\n\n<p translation-result=\"on\">现在，注意看 <em>Barry</em> 的构造函数。</p><p translation-origin=\"off\">For now, focus on <em>Barry</em>'s constructor.</p>\n\n<code-tabs>\n\n  <code-pane header=\"Barry&#x27;s constructor\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"barry-ctor\">\nconstructor( @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent: Parent ) { }\n\n</code-pane>\n\n  <code-pane header=\"Carol&#x27;s constructor\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"carol-ctor\">\nconstructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent: Parent ) { }\n\n</code-pane>\n\n</code-tabs>\n<p translation-result=\"on\">除增加了 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 装饰器之外，它和 <em>Carol</em> 的构造函数相同。</p><p translation-origin=\"off\">It's identical to <em>Carol</em>'s constructor except for the additional <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> decorator.</p>\n\n<p translation-result=\"on\">使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 有两个重要原因：</p><p translation-origin=\"off\"><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> is essential for two reasons:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">   它告诉注入器开始从组件树中<em>高于</em>自己的位置（也就是父组件）开始搜索 <code>Parent</code> 依赖。</p><p translation-origin=\"off\">It tells the injector to start its search for a <code>Parent</code> dependency in a component <em>above</em> itself,\nwhich <em>is</em> what parent means.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 如果你省略了 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 装饰器，Angular 就会抛出循环依赖错误。</p><p translation-origin=\"off\">Angular throws a cyclic dependency error if you omit the <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> decorator.</p>\n\n<p><code>Cannot instantiate cyclic dependency! (BethComponent -> Parent -> BethComponent)</code></p>\n</li>\n</ol>\n<p translation-result=\"on\">下面是 <em>Alice</em>、<em>Barry</em> 及其家人的运行效果。</p><p translation-origin=\"off\">Here's <em>Alice</em>, <em>Barry</em>, and family in action.</p>\n\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/alice.png\" alt=\"Alice in action\" width=\"298\" height=\"631\">\n</figure>\n<a id=\"parent-token\"></a>\n<h3 id=\"parent-class-interface\" translation-result=\"on\">父类接口<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#parent-class-interface\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"parent-class-interface\">Parent class interface<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#parent-class-interface\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你<a href=\"guide/dependency-injection-in-action#class-interface\">已经学过</a>，类接口是一个抽象类，它实际上用做接口而不是基类。</p><p translation-origin=\"off\">You <a href=\"guide/dependency-injection-in-action#class-interface\">learned earlier</a> that a class interface is an abstract class used as an interface rather than as a base class.</p>\n\n<p translation-result=\"on\">下面的例子定义了一个类接口 <code>Parent</code>。</p><p translation-origin=\"off\">The example defines a <code>Parent</code> class interface.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"parent\" header=\"parent-finder.component.ts (Parent class-interface)\" linenums=\"false\">\nexport abstract class Parent { name: string; }\n\n</code-example>\n<p translation-result=\"on\"><code>Parent</code> 类接口定义了一个带类型的 <code>name</code> 属性，但没有实现它。\n这个 <code>name</code> 属性是父组件中唯一可供子组件调用的成员。\n这样的窄化接口帮助把子组件从它的父组件中解耦出来。</p><p translation-origin=\"off\">The <code>Parent</code> class interface defines a <code>name</code> property with a type declaration but <em>no implementation</em>.\nThe <code>name</code> property is the only member of a parent component that a child component can call.\nSuch a narrow interface helps decouple the child component class from its parent components.</p>\n\n<p translation-result=\"on\">一个组件想要作为父组件使用，就<em>应该</em>像 <code>AliceComponent</code> 那样实现这个类接口。</p><p translation-origin=\"off\">A component that could serve as a parent <em>should</em> implement the class interface as the <code>AliceComponent</code> does.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alice-class-signature\" header=\"parent-finder.component.ts (AliceComponent class signature)\" linenums=\"false\">\nexport class AliceComponent implements Parent\n\n</code-example>\n<p translation-result=\"on\">这样做可以增加代码的清晰度，但在技术上并不是必要的。\n虽然 <code>AlexComponent</code> 像 <code>Base</code> 类所要求的一样具有 <code>name</code> 属性，但它的类签名中并没有提及 <code>Parent</code>。</p><p translation-origin=\"off\">Doing so adds clarity to the code.  But it's not technically necessary.\nAlthough <code>AlexComponent</code> has a <code>name</code> property, as required by its <code>Base</code> class,\nits class signature doesn't mention <code>Parent</code>.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-class-signature\" header=\"parent-finder.component.ts (AlexComponent class signature)\" linenums=\"false\">\nexport class AlexComponent extends Base\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><code>AlexComponent</code> <em>应该</em>实现 <code>Parent</code> 才是一种正确的风格。\n这个例子中之所以没这样做，<em>只是</em>为了证明即使没有声明接口，代码也可以编译和运行。</p><p translation-origin=\"off\"><code>AlexComponent</code> <em>should</em> implement <code>Parent</code> as a matter of proper style.\nIt doesn't in this example <em>only</em> to demonstrate that the code will compile and run without the interface.</p>\n\n</div>\n<a id=\"provideparent\"></a>\n<h3 id=\"provideparent-helper-function\" translation-result=\"on\"><code>provideParent()</code> 辅助函数<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#provideparent-helper-function\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"provideparent-helper-function\"><code>provideParent()</code> helper function<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#provideparent-helper-function\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你很快就会厌倦为同一个父组件编写<em>别名提供商</em>的变体形式，特别是带有 <a href=\"guide/dependency-injection-in-action#forwardref\"><em>forwardRef</em></a> 的那种。</p><p translation-origin=\"off\">Writing variations of the same parent <em>alias provider</em> gets old quickly,\nespecially this awful mouthful with a <a href=\"guide/dependency-injection-in-action#forwardref\"><em>forwardRef</em></a>.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-providers\" header=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" linenums=\"false\">\nproviders: [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() => AlexComponent) }],\n\n</code-example>\n<p translation-result=\"on\">你可以像把这些逻辑抽取到辅助函数中，就像这样。</p><p translation-origin=\"off\">You can extract that logic into a helper function like the following.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"provide-the-parent\" header=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" linenums=\"false\">\n// Helper method to provide the current component instance in the name of <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> `parentType`.\nconst provideParent =\n  (component: any) => {\n    return { provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() => component) };\n  };\n\n</code-example>\n<p translation-result=\"on\">现在，你可以为组件添加一个更简单、更有意义的父组件提供商。</p><p translation-origin=\"off\">Now you can add a simpler, more meaningful parent provider to your components.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alice-providers\" header=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" linenums=\"false\">\nproviders:  [ provideParent(AliceComponent) ]\n\n</code-example>\n<p translation-result=\"on\">你还可以做得更好。当前版本的辅助函数只能为类接口 <code>Parent</code> 定义别名。\n应用可能具有多种父组件类型，每个父组件都有自己的类接口令牌。</p><p translation-origin=\"off\">You can do better. The current version of the helper function can only alias the <code>Parent</code> class interface.\nThe application might have a variety of parent types, each with its own class interface token.</p>\n\n<p translation-result=\"on\">这是一个修订后的版本，它默认为 <code>parent</code>，但是也能接受另一个父类接口作为可选的第二参数。</p><p translation-origin=\"off\">Here's a revised version that defaults to <code>parent</code> but also accepts an optional second parameter for a different parent class interface.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"provide-parent\" header=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" linenums=\"false\">\n// Helper method to provide the current component instance in the name of <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> `parentType`.\n// The `parentType` defaults to `Parent` when omitting the second parameter.\nconst provideParent =\n  (component: any, parentType?: any) => {\n    return { provide: parentType || Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() => component) };\n  };\n\n</code-example>\n<p translation-result=\"on\">下面是针对不同父组件类型的用法。</p><p translation-origin=\"off\">And here's how you could use it with a different parent type.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"beth-providers\" header=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" linenums=\"false\">\nproviders:  [ provideParent(BethComponent, DifferentParent) ]\n\n</code-example>\n\n</div>\n\n<!-- links to this doc:\n - api/core/TemplateRef\n-->\n<!-- links from this doc:\n - api/\n - api/core/Component\n - api/core/Component#template\n - api/core/ContentChildren\n - api/core/Optional\n - api/core/Query\n - api/core/QueryList\n - api/core/SkipSelf\n - api/core/ViewChildren\n - api/core/forwardRef\n - api/router/RouterLinkWithHref\n - guide/dependency-injection-in-action#class-interface\n - guide/dependency-injection-in-action#forwardref\n - guide/dependency-injection-in-action#optional\n - guide/dependency-injection-in-action#useexisting\n - guide/dependency-injection-navtree#alex\n - guide/dependency-injection-navtree#alex-providers\n - guide/dependency-injection-navtree#find-a-parent-by-its-class-interface\n - guide/dependency-injection-navtree#find-a-parent-component-of-known-type\n - guide/dependency-injection-navtree#find-a-parent-in-a-tree-with-skipself\n - guide/dependency-injection-navtree#known-parent\n - guide/dependency-injection-navtree#navigate-the-component-tree-with-di\n - guide/dependency-injection-navtree#parent-class-interface\n - guide/dependency-injection-navtree#parent-token\n - guide/dependency-injection-navtree#provideparent\n - guide/dependency-injection-navtree#provideparent-helper-function\n - guide/dependency-injection-navtree#unable-to-find-a-parent-by-its-base-class\n - guide/glossary#view\n - guide/glossary#view-hierarchy\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/dependency-injection-navtree.md?message=docs%3A%20请简述你的修改...\n-->"
}