{"id":"guide/lazy-loading-ngmodules","title":"惰性加载特性模块","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/angular/angular-cn/edit/cn/aio/content/guide/lazy-loading-ngmodules.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"lazy-loading-feature-modules\" translation-result=\"on\">惰性加载特性模块<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#lazy-loading-feature-modules\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Lazy-loading feature modules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#lazy-loading-feature-modules\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">默认情况下，NgModule 都是急性加载的。意思是它会在应用加载时尽快加载，所有模块都是如此，无论是否立即要用。对于带有很多路由的大型应用，考虑使用惰性加载 —— 一种按需加载 NgModule 的模式。惰性加载可以减小初始包的尺寸，从而减少加载时间。</p><p translation-origin=\"off\">By default, NgModules are eagerly loaded. This means that as soon as the application loads, so do all the NgModules, whether they are immediately necessary or not.\nFor large applications with lots of routes, consider lazy loading —a design pattern that loads NgModules as needed.\nLazy loading helps keep initial bundle sizes smaller, which in turn helps decrease load times.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">如果需要本页描述的具有两个惰性加载模块的范例应用，参阅<live-example></live-example>。</p><p translation-origin=\"off\">For the final sample application with two lazy-loaded modules that this page describes, see the <live-example></live-example>.</p>\n\n</div>\n<p><a id=\"lazy-loading\"></a></p>\n<h2 id=\"lazy-loading-basics\" translation-result=\"on\">惰性加载入门<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#lazy-loading-basics\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Lazy loading basics<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#lazy-loading-basics\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">本节会介绍配置惰性加载路由的基本过程。\n想要一个分步的范例，参阅本页的<a href=\"guide/lazy-loading-ngmodules#step-by-step\">分步设置</a>部分。</p><p translation-origin=\"off\">This section introduces the basic procedure for configuring a lazy-loaded route.\nFor a step-by-step example, see the <a href=\"guide/lazy-loading-ngmodules#step-by-step\">step-by-step setup</a> section on this page.</p>\n\n<p translation-result=\"on\">要惰性加载 Angular 模块，请在 <code>AppRoutingModule</code> <code>routes</code> 中使用 <code>loadChildren</code> 代替 <code>component</code> 进行配置，代码如下。</p><p translation-origin=\"off\">To lazy load Angular modules, use <code>loadChildren</code> (instead of <code>component</code>) in your <code>AppRoutingModule</code> <code>routes</code> configuration as follows.</p>\n\n<code-example header=\"AppRoutingModule (excerpt)\">\n\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'items',\n    loadChildren: () =&gt; import('./items/items.module').then(m =&gt; m.ItemsModule)\n  }\n];\n\n</code-example>\n<p translation-result=\"on\">在惰性加载模块的路由模块中，添加一个指向该组件的路由。</p><p translation-origin=\"off\">In the lazy-loaded module's routing module, add a route for the component.</p>\n\n<code-example header=\"Routing module for lazy loaded module (excerpt)\">\n\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: '',\n    component: ItemsComponent\n  }\n];\n\n</code-example>\n<p translation-result=\"on\">还要确保从 <code>AppModule</code> 中移除了 <code>ItemsModule</code>。想要一个关于惰性加载模块的分步操作指南，请继续查看本页的后续章节。</p><p translation-origin=\"off\">Also be sure to remove the <code>ItemsModule</code> from the <code>AppModule</code>.\nFor step-by-step instructions on lazy loading modules, continue with the following sections of this page.</p>\n\n<p><a id=\"step-by-step\"></a></p>\n<h2 id=\"step-by-step-setup\" translation-result=\"on\">分步设置<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#step-by-step-setup\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Step-by-step setup<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#step-by-step-setup\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">建立惰性加载的特性模块需要两个主要步骤：</p><p translation-origin=\"off\">Setting up a lazy-loaded feature module requires two main steps:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">使用 <code>--route</code> 标志，用 Angular CLI 创建特性模块。</p><p translation-origin=\"off\">Create the feature module with the Angular CLI, using the <code>--route</code> flag.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">配置相关路由。</p><p translation-origin=\"off\">Configure the routes.</p>\n\n</li>\n</ol>\n<h3 id=\"set-up-an-application\" translation-result=\"on\">建立应用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#set-up-an-application\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Set up an application<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#set-up-an-application\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果你还没有应用，可以遵循下面的步骤使用 Angular CLI 创建一个。如果已经有了，可以直接跳到 <a href=\"guide/lazy-loading-ngmodules#config-routes\">配置路由</a>部分。</p><p translation-origin=\"off\">If you don't already have an application, follow the following steps to create one with the Angular CLI.\nIf you already have an application, skip to <a href=\"guide/lazy-loading-ngmodules#config-routes\">Configure the routes</a>.</p>\n\n<!-- vale Angular.Google_WordListWarnings = NO -->\n<p translation-result=\"on\">输入下列命令，其中的 <code>customer-app</code> 表示你的应用名称。</p><p translation-origin=\"off\">Enter the following command where <code>customer-app</code> is the name of your app:</p>\n\n<!-- vale Angular.Google_WordListWarnings = YES -->\n<code-example format=\"shell\" language=\"shell\">\n\nng new customer-app --routing\n\n</code-example>\n<p translation-result=\"on\">这会创建一个名叫 <code>customer-app</code> 的应用，而 <code>--routing</code> 标识生成了一个名叫 <code>app-routing.module.ts</code> 的文件.它是你建立惰性加载的特性模块时所必须的。输入命令 <code>cd customer-app</code> 进入该项目。</p><p translation-origin=\"off\">This creates an application called <code>customer-app</code> and the <code>--routing</code> flag generates a file called <code>app-routing.module.ts</code>. This is one of the files you need for setting up lazy loading for your feature module.\nNavigate into the project by issuing the command <code>cd customer-app</code>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><code>--routing</code> 选项需要 Angular/CLI 8.1 或更高版本。请参阅<a href=\"guide/updating\">保持最新</a>。</p><p translation-origin=\"off\">The <code>--routing</code> option requires Angular CLI version 8.1 or higher.\nSee <a href=\"guide/updating\">Keeping Up to Date</a>.</p>\n\n</div>\n<h3 id=\"create-a-feature-module-with-routing\" translation-result=\"on\">创建一个带路由的特性模块<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#create-a-feature-module-with-routing\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Create a feature module with routing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#create-a-feature-module-with-routing\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">接下来，你将需要一个包含路由的目标组件的特性模块。要创建它，在命令行工具中输入如下命令，其中 <code>customers</code> 是特性模块的名称。加载 <code>customers</code> 特性模块的路径也是 <code>customers</code>，因为它是通过 <code>--route</code> 选项指定的：</p><p translation-origin=\"off\">Next, you need a feature module with a component to route to.\nTo make one, enter the following command in the command line tool, where <code>customers</code> is the name of the feature module.\nThe path for loading the <code>customers</code> feature modules is also <code>customers</code> because it is specified with the <code>--route</code> option:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate module customers --route customers --module app.module\n\n</code-example>\n<p translation-result=\"on\">这将创建一个 <code>customers</code> 目录，在其 <code>customers.module.ts</code> 文件中定义了新的可惰性加载模块 <code>CustomersModule</code>。该命令会自动在新特性模块中声明 <code>CustomersComponent</code>。</p><p translation-origin=\"off\">This creates a <code>customers</code> directory having the new lazy-loadable feature module <code>CustomersModule</code> defined in the <code>customers.module.ts</code> file and the routing module <code>CustomersRoutingModule</code> defined in the <code>customers-routing.module.ts</code> file.\nThe command automatically declares the <code>CustomersComponent</code> and imports <code>CustomersRoutingModule</code> inside the new feature module.</p>\n\n<p translation-result=\"on\">因为这个新模块想要惰性加载，所以该命令<strong>不会</strong>在应用的根模块 <code>app.module.ts</code> 中添加对新特性模块的引用。相反，它将声明的路由 <code>customers</code> 添加到以 <code>--module</code> 选项指定的模块中声明的 <code>routes</code> 数组中。</p><p translation-origin=\"off\">Because the new module is meant to be lazy-loaded, the command does <strong>not</strong> add a reference to it in the application's root module file, <code>app.module.ts</code>.\nInstead, it adds the declared route, <code>customers</code> to the <code>routes</code> array declared in the module provided as the <code>--module</code> option.</p>\n\n<code-example header=\"src/app/app-routing.module.ts\" path=\"lazy-loading-ngmodules/src/app/app-routing.module.ts\" region=\"routes-customers\">\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'customers',\n    loadChildren: () =&gt; import('./customers/customers.module').then(m =&gt; m.CustomersModule)\n  }\n];\n\n</code-example>\n<p translation-result=\"on\">注意，惰性加载语法使用 <code>loadChildren</code>，其后是一个使用浏览器内置的 <code>import('...')</code> 语法进行动态导入的函数。其导入路径是到当前模块的相对路径。</p><p translation-origin=\"off\">Notice that the lazy-loading syntax uses <code>loadChildren</code> followed by a function that uses the browser's built-in <code>import('...')</code> syntax for dynamic imports.\nThe import path is the relative path to the module.</p>\n\n<div class=\"callout is-helpful\">\n<header ng-should-translate=\"\" translation-result=\"on\">基于字符串的惰性加载</header><header ng-should-translate=\"\" translation-origin=\"off\">String-based lazy loading</header>\n\n<p translation-result=\"on\">在 Angular 版本 8 中，<code>loadChildren</code> 路由规范的字符串语法<a href=\"guide/deprecations#loadchildren-string-syntax\">已弃用</a>，建议改用 <code>import()</code> 语法。你可以通过在 <code>tsconfig</code> 文件中包含惰性加载的路由来选择使用基于字符串的惰性加载（<code>loadChildren: './path/to/module#Module'</code>），这样它就会在编译时包含惰性加载的文件。</p><p translation-origin=\"off\">In Angular version 8, the string syntax for the <code>loadChildren</code> route specification <a href=\"guide/deprecations#loadchildren-string-syntax\">was deprecated</a> in favor of the <code>import()</code> syntax.\nYou can opt into using string-based lazy loading (<code>loadChildren: './path/to/module#Module'</code>) by including the lazy-loaded routes in your <code>tsconfig</code> file, which includes the lazy-loaded files in the compilation.</p>\n\n<p translation-result=\"on\">默认情况下，会用 Angular CLI 生成项目，这些项目将更严格地包含旨在与 <code>import()</code> 语法一起使用的文件。</p><p translation-origin=\"off\">By default the Angular CLI generates projects with stricter file inclusions intended to be used with the <code>import()</code> syntax.</p>\n\n</div>\n<h3 id=\"add-another-feature-module\" translation-result=\"on\">添加另一个特性模块<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#add-another-feature-module\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Add another feature module<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#add-another-feature-module\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">使用同样的命令创建第二个带路由的惰性加载特性模块及其桩组件。</p><p translation-origin=\"off\">Use the same command to create a second lazy-loaded feature module with routing, along with its stub component.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate module orders --route orders --module app.module\n\n</code-example>\n<p translation-result=\"on\">这将创建一个名为 <code>orders</code> 的新目录，其中包含 <code>OrdersModule</code> 和 <code>OrdersRoutingModule</code> 以及新的 <code>OrdersComponent</code> 源文件。使用 <code>--route</code> 选项指定的 <code>orders</code> 路由，用惰性加载语法添加到了 <code>app-routing.module.ts</code> 文件内的 <code>routes</code> 数组中。</p><p translation-origin=\"off\">This creates a new directory called <code>orders</code> containing the <code>OrdersModule</code> and <code>OrdersRoutingModule</code>, along with the new <code>OrdersComponent</code> source files.\nThe <code>orders</code> route, specified with the <code>--route</code> option, is added to the <code>routes</code> array inside the <code>app-routing.module.ts</code> file, using the lazy-loading syntax.</p>\n\n<code-example header=\"src/app/app-routing.module.ts\" path=\"lazy-loading-ngmodules/src/app/app-routing.module.ts\" region=\"routes-customers-orders\">\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'customers',\n    loadChildren: () =&gt; import('./customers/customers.module').then(m =&gt; m.CustomersModule)\n  },\n  {\n    path: 'orders',\n    loadChildren: () =&gt; import('./orders/orders.module').then(m =&gt; m.OrdersModule)\n  }\n];\n\n</code-example>\n<h3 id=\"set-up-the-ui\" translation-result=\"on\">建立 UI<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#set-up-the-ui\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Set up the UI<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#set-up-the-ui\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">虽然你也可以在地址栏中输入 URL，不过导航 UI 会更好用，也更常见。把 <code>app.component.html</code> 中的占位脚本替换成一个自定义的导航，以便你在浏览器中能在模块之间导航。</p><p translation-origin=\"off\">Though you can type the URL into the address bar, a navigation UI is straightforward for the user and more common.\nReplace the default placeholder markup in <code>app.component.html</code> with a custom nav, so you can navigate to your modules in the browser:</p>\n\n<code-example header=\"src/app/app.component.html\" path=\"lazy-loading-ngmodules/src/app/app.component.html\" region=\"app-component-template\">\n&lt;h1&gt;\n  {{title}}\n&lt;/h1&gt;\n\n&lt;button type=\"button\" <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/customers\"&gt;Customers&lt;/button&gt;\n&lt;button type=\"button\" <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/orders\"&gt;Orders&lt;/button&gt;\n&lt;button type=\"button\" <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"\"&gt;Home&lt;/button&gt;\n\n&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n\n\n</code-example>\n<p translation-result=\"on\">要想在浏览器中看到你的应用，就在命令行工具窗口中输入下列命令：</p><p translation-origin=\"off\">To see your application in the browser so far, enter the following command in the command line tool window:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng serve\n\n</code-example>\n<!-- vale Angular.Google_WordListWarnings = NO -->\n<p translation-result=\"on\">然后，跳转到 <code>localhost:4200</code>，这时你应该看到 \"customer-app\" 和三个按钮。</p><p translation-origin=\"off\">Then go to <code>localhost:4200</code> where you should see \"customer-app\" and three buttons.</p>\n\n<!-- vale Angular.Google_WordListWarnings = YES -->\n<div class=\"lightbox\">\n<img alt=\"three buttons in the browser\" src=\"generated/images/guide/lazy-loading-ngmodules/three-buttons.png\" width=\"300\">\n</div>\n<p translation-result=\"on\">这些按钮生效了，因为 Angular CLI 会自动将特性模块的路由添加到 <code>app-routing.module.ts</code> 中的 <code>routes</code> 数组中。</p><p translation-origin=\"off\">These buttons work, because the Angular CLI automatically added the routes to the feature modules to the <code>routes</code> array in <code>app-routing.module.ts</code>.</p>\n\n<p><a id=\"config-routes\"></a></p>\n<h3 id=\"imports-and-route-configuration\" translation-result=\"on\">导入与路由配置<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#imports-and-route-configuration\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Imports and route configuration<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#imports-and-route-configuration\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">Angular CLI 会将每个特性模块自动添加到应用级的路由映射表中。通过添加默认路由来最终完成这些步骤。在 <code>app-routing.module.ts</code> 文件中，使用如下命令更新 <code>routes</code> 数组：</p><p translation-origin=\"off\">The Angular CLI automatically added each feature module to the routes map at the application level.\nFinish this off by adding the default route.\nIn the <code>app-routing.module.ts</code> file, update the <code>routes</code> array with the following:</p>\n\n<code-example header=\"src/app/app-routing.module.ts\" path=\"lazy-loading-ngmodules/src/app/app-routing.module.ts\" id=\"app-routing.module.ts\" region=\"const-routes\">\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'customers',\n    loadChildren: () =&gt; import('./customers/customers.module').then(m =&gt; m.CustomersModule)\n  },\n  {\n    path: 'orders',\n    loadChildren: () =&gt; import('./orders/orders.module').then(m =&gt; m.OrdersModule)\n  },\n  {\n    path: '',\n    redirectTo: '',\n    pathMatch: 'full'\n  }\n];\n\n</code-example>\n<p translation-result=\"on\">前两个路径是到 <code>CustomersModule</code> 和 <code>OrdersModule</code> 的路由。最后一个条目则定义了默认路由。空路径匹配所有不匹配先前路径的内容。</p><p translation-origin=\"off\">The first two paths are the routes to the <code>CustomersModule</code> and the <code>OrdersModule</code>.\nThe final entry defines a default route.\nThe empty path matches everything that doesn't match an earlier path.</p>\n\n<h3 id=\"inside-the-feature-module\" translation-result=\"on\">特性模块内部<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#inside-the-feature-module\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Inside the feature module<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#inside-the-feature-module\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">接下来，仔细看看 <code>customers.module.ts</code> 文件。如果你使用的是 Angular CLI，并按照此页面中的步骤进行操作，则无需在此处执行任何操作。</p><p translation-origin=\"off\">Next, take a look at the <code>customers.module.ts</code> file.\nIf you're using the Angular CLI and following the steps outlined in this page, you don't have to do anything here.</p>\n\n<code-example header=\"src/app/customers/customers.module.ts\" path=\"lazy-loading-ngmodules/src/app/customers/customers.module.ts\" id=\"customers.module.ts\" region=\"customers-module\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';\nimport { CustomersRoutingModule } from './customers-routing.module';\nimport { CustomersComponent } from './customers.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    CustomersRoutingModule\n  ],\n  declarations: [CustomersComponent]\n})\nexport class CustomersModule { }\n\n</code-example>\n<p translation-result=\"on\"><code>customers.module.ts</code> 文件导入了 <code>customers-routing.module.ts</code> 和 <code>customers.component.ts</code> 文件。<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的 <code>imports</code> 数组中列出了 <code>CustomersRoutingModule</code>，让 <code>CustomersModule</code> 可以访问它自己的路由模块。<code>CustomersComponent</code> 位于 <code>declarations</code> 数组中，这意味着 <code>CustomersComponent</code> 属于 <code>CustomersModule</code>。</p><p translation-origin=\"off\">The <code>customers.module.ts</code> file imports the <code>customers-routing.module.ts</code> and <code>customers.component.ts</code> files.\n<code>CustomersRoutingModule</code> is listed in the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> <code>imports</code> array giving <code>CustomersModule</code> access to its own routing module.\n<code>CustomersComponent</code> is in the <code>declarations</code> array, which means <code>CustomersComponent</code> belongs to the <code>CustomersModule</code>.</p>\n\n<p translation-result=\"on\">然后，<code>app-routing.module.ts</code> 会使用 JavaScript 的动态导入功能来导入特性模块 <code>customers.module.ts</code>。</p><p translation-origin=\"off\">The <code>app-routing.module.ts</code> then imports the feature module, <code>customers.module.ts</code> using JavaScript's dynamic import.</p>\n\n<p translation-result=\"on\">专属于特性模块的路由定义文件 <code>customers-routing.module.ts</code> 将导入在 <code>customers.component.ts</code> 文件中定义的自有特性组件，以及其它 JavaScript 导入语句。然后将空路径映射到 <code>CustomersComponent</code>。</p><p translation-origin=\"off\">The feature-specific route definition file <code>customers-routing.module.ts</code> imports its own feature component defined in the <code>customers.component.ts</code> file, along with the other JavaScript import statements.\nIt then maps the empty path to the <code>CustomersComponent</code>.</p>\n\n<code-example header=\"src/app/customers/customers-routing.module.ts\" path=\"lazy-loading-ngmodules/src/app/customers/customers-routing.module.ts\" id=\"customers-routing.module.ts\" region=\"customers-routing-module\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> } from '@angular/router';\n\nimport { CustomersComponent } from './customers.component';\n\n\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: '',\n    component: CustomersComponent\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [RouterModule.forChild(routes)],\n  exports: [<a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>]\n})\nexport class CustomersRoutingModule { }\n\n</code-example>\n<p translation-result=\"on\">这里的 <code>path</code> 设置为空字符串，因为 <code>AppRoutingModule</code> 中的路径已经设置为 <code>customers</code>，因此，<code>CustomersRoutingModule</code> 中的此路由已经位于 <code>customers</code> 这个上下文中。此路由模块中的每个路由都是其子路由。</p><p translation-origin=\"off\">The <code>path</code> here is set to an empty string because the path in <code>AppRoutingModule</code> is already set to <code>customers</code>, so this route in the <code>CustomersRoutingModule</code>, is already within the <code>customers</code> context.\nEvery route in this routing module is a child route.</p>\n\n<p translation-result=\"on\">另一个特性模块中路由模块的配置也类似。</p><p translation-origin=\"off\">The other feature module's routing module is configured similarly.</p>\n\n<code-example header=\"src/app/orders/orders-routing.module.ts (excerpt)\" path=\"lazy-loading-ngmodules/src/app/orders/orders-routing.module.ts\" id=\"orders-routing.module.ts\" region=\"orders-routing-module-detail\">\nimport { OrdersComponent } from './orders.component';\n\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: '',\n    component: OrdersComponent\n  }\n];\n\n</code-example>\n<h3 id=\"verify-lazy-loading\" translation-result=\"on\">确认它工作正常<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#verify-lazy-loading\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Verify lazy loading<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#verify-lazy-loading\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你可以使用 Chrome 开发者工具来验证一下这些模块真的是惰性加载的。在 Chrome 中，按 <code>Cmd+Option+i</code>（Mac）或 <code>Ctrl+Shift+j</code>（PC），并选中 <code>Network</code> 页标签。</p><p translation-origin=\"off\">You can verify that a module is indeed being lazy loaded with the Chrome developer tools.\nIn Chrome, open the developer tools by pressing <code>Cmd+Option+i</code> on a Mac or <code>Ctrl+Shift+j</code> on a PC and go to the Network Tab.</p>\n\n<div class=\"lightbox\">\n<img alt=\"lazy loaded modules diagram\" src=\"generated/images/guide/lazy-loading-ngmodules/network-tab.png\" width=\"600\">\n</div>\n<p translation-result=\"on\">点击 Orders 或 Customers 按钮。如果你看到某个 chunk 文件出现了，就表示一切就绪，特性模块被惰性加载成功了。Orders 和 Customers 都应该出现一次 chunk，并且它们各自只应该出现一次。</p><p translation-origin=\"off\">Click on the Orders or Customers button.\nIf you see a chunk appear, everything is wired up properly and the feature module is being lazy loaded.\nA chunk should appear for Orders and for Customers but only appears once for each.</p>\n\n<div class=\"lightbox\">\n<img alt=\"lazy loaded modules diagram\" src=\"generated/images/guide/lazy-loading-ngmodules/chunk-arrow.png\" width=\"600\">\n</div>\n<p translation-result=\"on\">要想再次查看它或测试修改后的行为，只要点击 Network 页左上放的 <code>清除</code> 图标即可。</p><p translation-origin=\"off\">To see it again, or to test after making changes, click the circle with a line through it in the upper left of the Network Tab:</p>\n\n<div class=\"lightbox\">\n<img alt=\"lazy loaded modules diagram\" src=\"generated/images/guide/lazy-loading-ngmodules/clear.gif\" width=\"200\">\n</div>\n<p translation-result=\"on\">然后，使用 <code>Cmd+r</code>（Mac）或 <code>Ctrl+r</code>（PC）重新加载页面。</p><p translation-origin=\"off\">Then reload with <code>Cmd+r</code> or <code>Ctrl+r</code>, depending on your platform.</p>\n\n<h2 id=\"forroot-and-forchild\" translation-result=\"on\"><code>forRoot()</code> 与 <code>forChild()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#forroot-and-forchild\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\"><code>forRoot()</code> and <code>forChild()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#forroot-and-forchild\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你可能已经注意到了，Angular CLI 会把 <code>RouterModule.forRoot(routes)</code> 添加到 <code>AppRoutingModule</code> 的 <code>imports</code> 数组中。这会让 Angular 知道 <code>AppRoutingModule</code> 是一个路由模块，而 <code>forRoot()</code> 表示这是一个根路由模块。它会配置你传入的所有路由、让你能访问路由器指令并注册 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>。<code>forRoot()</code> 在应用中只应该使用一次，也就是这个 <code>AppRoutingModule</code> 中。</p><p translation-origin=\"off\">You might have noticed that the Angular CLI adds <code>RouterModule.forRoot(routes)</code> to the <code>AppRoutingModule</code> <code>imports</code> array.\nThis lets Angular know that the <code>AppRoutingModule</code> is a routing module and <code>forRoot()</code> specifies that this is the root routing module.\nIt configures all the routes you pass to it, gives you access to the router directives, and registers the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> service.\nUse <code>forRoot()</code> only once in the application, inside the <code>AppRoutingModule</code>.</p>\n\n<p translation-result=\"on\">Angular CLI 还会把 <code>RouterModule.forChild(routes)</code> 添加到各个特性模块中。这种方式下 Angular 就会知道这个路由列表只负责提供额外的路由并且其设计意图是作为特性模块使用。你可以在多个模块中使用 <code>forChild()</code>。</p><p translation-origin=\"off\">The Angular CLI also adds <code>RouterModule.forChild(routes)</code> to feature routing modules.\nThis way, Angular knows that the route list is only responsible for providing extra routes and is intended for feature modules.\nYou can use <code>forChild()</code> in multiple modules.</p>\n\n<p translation-result=\"on\"><code>forRoot()</code> 方法为路由器管理<em>全局性的</em>注入器配置。<code>forChild()</code> 方法中没有注入器配置，只有像 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> 和 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 这样的指令。欲知详情，参阅<a href=\"guide/singleton-services\">单例服务</a>章的 <a href=\"guide/singleton-services#forRoot\"><code>forRoot()</code> 模式</a>小节。</p><p translation-origin=\"off\">The <code>forRoot()</code> method takes care of the <em>global</em> injector configuration for the Router.\nThe <code>forChild()</code> method has no injector configuration.\nIt uses directives such as <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> and <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>.\nFor more information, see the <a href=\"guide/singleton-services#forRoot\"><code>forRoot()</code> pattern</a> section of the <a href=\"guide/singleton-services\">Singleton Services</a> guide.</p>\n\n<p><a id=\"preloading\"></a></p>\n<h2 id=\"preloading\" translation-result=\"on\">预加载<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#preloading\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Preloading<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#preloading\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">预加载通过在后台加载部分应用来改进用户体验。你可以预加载模块或组件数据。</p><p translation-origin=\"off\">Preloading improves UX by loading parts of your application in the background.\nYou can preload modules or component data.</p>\n\n<h3 id=\"preloading-modules\" translation-result=\"on\">预加载模块<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#preloading-modules\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Preloading modules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#preloading-modules\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">预加载模块通过在后台加载部分应用来改善用户体验。这样一来，用户在激活路由时就无需等待下载这些元素。</p><p translation-origin=\"off\">Preloading modules improves UX by loading parts of your application in the background. By doing this, users don't have to wait for the elements to download when they activate a route.</p>\n\n<p translation-result=\"on\">要启用所有惰性加载模块的预加载，请从 Angular 的 <code>router</code> 导入 <code><a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a></code> 令牌。</p><p translation-origin=\"off\">To enable preloading of all lazy loaded modules, import the <code><a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a></code> token from the Angular <code>router</code>.</p>\n\n<code-example header=\"AppRoutingModule (excerpt)\">\n\nimport { <a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a> } from '@angular/router';\n\n</code-example>\n<p translation-result=\"on\">还是在 <code>AppRoutingModule</code> 中，通过 <code>forRoot()</code> 指定你的预加载策略。</p><p translation-origin=\"off\">Still in the <code>AppRoutingModule</code>, specify your preloading strategy in <code>forRoot()</code>.</p>\n\n<code-example header=\"AppRoutingModule (excerpt)\">\n\nRouterModule.forRoot(\n  appRoutes,\n  {\n    preloadingStrategy: <a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a>\n  }\n)\n\n</code-example>\n<h3 id=\"preloading-component-data\" translation-result=\"on\">预加载组件数据<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#preloading-component-data\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Preloading component data<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#preloading-component-data\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要预加载组件数据，可以用 <code>resolver</code> 守卫。解析器通过阻止页面加载来改进用户体验，直到显示页面时的全部必要数据都可用。</p><p translation-origin=\"off\">To preload component data, use a <code>resolver</code>.\nResolvers improve UX by blocking the page load until all necessary data is available to fully display the page.</p>\n\n<h4 id=\"resolvers\" translation-result=\"on\">解析器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#resolvers\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Resolvers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#resolvers\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">创建一个解析器服务。通过 Angular CLI，创建服务的命令如下：</p><p translation-origin=\"off\">Create a resolver service.\nWith the Angular CLI, the command to create a service is as follows:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate service &lt;service-name&gt;\n\n</code-example>\n<p translation-result=\"on\">在新创建的服务中，实现由 <code>@angular/router</code> 包提供的 <code><a href=\"api/router/Resolve\" class=\"code-anchor\">Resolve</a></code> 接口：</p><p translation-origin=\"off\">In the newly created service, implement the <code><a href=\"api/router/Resolve\" class=\"code-anchor\">Resolve</a></code> interface provided by the <code>&amp;commat;angular/router</code> package:</p>\n\n<code-example header=\"Resolver service (excerpt)\">\n\nimport { <a href=\"api/router/Resolve\" class=\"code-anchor\">Resolve</a> } from '@angular/router';\n\n…\n\n/* An interface that represents your data model */\nexport interface Crisis {\n  id: number;\n  name: string;\n}\n\nexport class CrisisDetailResolverService implements <a href=\"api/router/Resolve\" class=\"code-anchor\">Resolve</a>&lt;Crisis&gt; {\n  resolve(route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>, state: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): Observable&lt;Crisis&gt; {\n    // your logic goes here\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">把这个解析器导入此模块的路由模块。</p><p translation-origin=\"off\">Import this resolver into your module's routing module.</p>\n\n<code-example header=\"Feature module's routing module (excerpt)\">\n\nimport { CrisisDetailResolverService } from './crisis-detail-resolver.service';\n\n</code-example>\n<p translation-result=\"on\">在组件的 <code>route</code> 配置中添加一个 <code>resolve</code> 对象。</p><p translation-origin=\"off\">Add a <code>resolve</code> object to the component's <code>route</code> configuration.</p>\n\n<code-example header=\"Feature module's routing module (excerpt)\">\n\n{\n  path: '/your-path',\n  component: YourComponent,\n  resolve: {\n    crisis: CrisisDetailResolverService\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">在此组件的构造函数中，注入一个 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 实例，它可以表示当前路由。</p><p translation-origin=\"off\">In the component's constructor, inject an instance of the <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> class that represents the current route.</p>\n\n<code-example header=\"Component's constructor (excerpt)\">\n\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ … })\nclass YourComponent {\n  constructor(private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>) {}\n}\n\n</code-example>\n<p translation-result=\"on\">使用注入进来的 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 类实例来访问与指定路由关联的 <code>data</code> 值。</p><p translation-origin=\"off\">Use the injected instance of the <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> class to access <code>data</code> associated with a given route.</p>\n\n<code-example header=\"Component's ngOnInit lifecycle hook (excerpt)\">\n\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ … })\nclass YourComponent {\n  constructor(private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>) {}\n\n  ngOnInit() {\n    this.route.data\n      .subscribe(data =&gt; {\n        const crisis: Crisis = data.crisis;\n        // …\n      });\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">关于工作范例的更多信息，请参阅<a href=\"guide/router-tutorial-toh#preloading-background-loading-of-feature-areas\">路由教程的预加载部分</a>。</p><p translation-origin=\"off\">For more information with a working example, see the <a href=\"guide/router-tutorial-toh#preloading-background-loading-of-feature-areas\">routing tutorial section on preloading</a>.</p>\n\n<h2 id=\"troubleshooting-lazy-loading-modules\" translation-result=\"on\">对惰性加载模块进行故障排除<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#troubleshooting-lazy-loading-modules\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Troubleshooting lazy-loading modules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#troubleshooting-lazy-loading-modules\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">惰性加载模块时常见的错误之一，就是在应用程序中的多个位置导入通用模块。可以先用 Angular CLI 生成模块并包括 <code>--route route-name</code> 参数，来测试这种情况，其中 <code>route-name</code> 是模块的名称。接下来，创建不带 <code>--route</code> 参数的模块。如果你调用 <code>ng generate module</code> 时带上了 <code>--route</code> 参数，就会返回一个错误，否则它便可以正确运行，这样一来你就可能会在多个位置导入相同的模块。</p><p translation-origin=\"off\">A common error when lazy-loading modules is importing common modules in multiple places within an application.\nTest for this condition by first generating the module using the Angular CLI and including the <code>--route route-name</code> parameter, where <code>route-name</code> is the name of your module.\nNext, create the module without the <code>--route</code> parameter.\nIf <code>ng generate module</code> with the <code>--route</code> parameter returns an error, but runs correctly without it, you might have imported the same module in multiple places.</p>\n\n<p translation-result=\"on\">请记住，许多常见的 Angular 模块都应该导入应用的基础模块中。</p><p translation-origin=\"off\">Remember, many common Angular modules should be imported at the base of your application.</p>\n\n<p translation-result=\"on\">有关 Angular 模块的更多信息，请参见 <a href=\"guide/ngmodules\">NgModules</a>。</p><p translation-origin=\"off\">For more information on Angular Modules, see <a href=\"guide/ngmodules\">NgModules</a>.</p>\n\n<h2 id=\"more-on-ngmodules-and-routing\" translation-result=\"on\">更多关于 NgModule 和路由的知识<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#more-on-ngmodules-and-routing\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">More on NgModules and routing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#more-on-ngmodules-and-routing\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你可能还对下列内容感兴趣：</p><p translation-origin=\"off\">You might also be interested in the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><a href=\"guide/router\">路由与导航</a></p><p translation-origin=\"off\"><a href=\"guide/router\">Routing and Navigation</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/providers\">服务提供者</a></p><p translation-origin=\"off\"><a href=\"guide/providers\">Providers</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/module-types\">特性模块的分类</a></p><p translation-origin=\"off\"><a href=\"guide/module-types\">Types of Feature Modules</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"https://web.dev/route-level-code-splitting-in-angular/\">Angular 中的路由级代码拆分</a></p><p translation-origin=\"off\"><a href=\"https://web.dev/route-level-code-splitting-in-angular\">Route-level code-splitting in Angular</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"https://web.dev/route-preloading-in-angular/\">Angular 中的路由预加载策略</a></p><p translation-origin=\"off\"><a href=\"https://web.dev/route-preloading-in-angular\">Route preloading strategies in Angular</a></p>\n\n</li>\n</ul>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间： 2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/entry-components\n - guide/example-apps-list\n - guide/feature-modules\n - guide/module-types\n - guide/providers\n - guide/router\n - guide/singleton-services\n-->\n<!-- links from this doc:\n - api/common/CommonModule\n - api/core/Component\n - api/core/NgModule\n - api/router/ActivatedRoute\n - api/router/ActivatedRouteSnapshot\n - api/router/PreloadAllModules\n - api/router/Resolve\n - api/router/Router\n - api/router/RouterLink\n - api/router/RouterModule\n - api/router/RouterOutlet\n - api/router/RouterStateSnapshot\n - api/router/Routes\n - guide/deprecations#loadchildren-string-syntax\n - guide/lazy-loading-ngmodules#add-another-feature-module\n - guide/lazy-loading-ngmodules#config-routes\n - guide/lazy-loading-ngmodules#create-a-feature-module-with-routing\n - guide/lazy-loading-ngmodules#forroot-and-forchild\n - guide/lazy-loading-ngmodules#forroot-与-forchild\n - guide/lazy-loading-ngmodules#imports-and-route-configuration\n - guide/lazy-loading-ngmodules#inside-the-feature-module\n - guide/lazy-loading-ngmodules#lazy-loading-basics\n - guide/lazy-loading-ngmodules#lazy-loading-feature-modules\n - guide/lazy-loading-ngmodules#more-on-ngmodules-and-routing\n - guide/lazy-loading-ngmodules#preloading\n - guide/lazy-loading-ngmodules#preloading-component-data\n - guide/lazy-loading-ngmodules#preloading-modules\n - guide/lazy-loading-ngmodules#resolvers\n - guide/lazy-loading-ngmodules#set-up-an-application\n - guide/lazy-loading-ngmodules#set-up-the-ui\n - guide/lazy-loading-ngmodules#step-by-step\n - guide/lazy-loading-ngmodules#step-by-step-setup\n - guide/lazy-loading-ngmodules#troubleshooting-lazy-loading-modules\n - guide/lazy-loading-ngmodules#verify-lazy-loading\n - guide/lazy-loading-ngmodules#分步设置\n - guide/lazy-loading-ngmodules#创建一个带路由的特性模块\n - guide/lazy-loading-ngmodules#对惰性加载模块进行故障排除\n - guide/lazy-loading-ngmodules#导入与路由配置\n - guide/lazy-loading-ngmodules#建立-ui\n - guide/lazy-loading-ngmodules#建立应用\n - guide/lazy-loading-ngmodules#惰性加载入门\n - guide/lazy-loading-ngmodules#惰性加载特性模块\n - guide/lazy-loading-ngmodules#更多关于-ngmodule-和路由的知识\n - guide/lazy-loading-ngmodules#添加另一个特性模块\n - guide/lazy-loading-ngmodules#特性模块内部\n - guide/lazy-loading-ngmodules#确认它工作正常\n - guide/lazy-loading-ngmodules#解析器\n - guide/lazy-loading-ngmodules#预加载\n - guide/lazy-loading-ngmodules#预加载模块\n - guide/lazy-loading-ngmodules#预加载组件数据\n - guide/module-types\n - guide/ngmodules\n - guide/providers\n - guide/router\n - guide/router-tutorial-toh#preloading-background-loading-of-feature-areas\n - guide/singleton-services\n - guide/singleton-services#forRoot\n - guide/updating\n - https://github.com/angular/angular-cn/edit/cn/aio/content/guide/lazy-loading-ngmodules.md?message=docs%3A%20请简述你的修改...\n - https://web.dev/route-level-code-splitting-in-angular\n - https://web.dev/route-level-code-splitting-in-angular/\n - https://web.dev/route-preloading-in-angular\n - https://web.dev/route-preloading-in-angular/\n-->"}