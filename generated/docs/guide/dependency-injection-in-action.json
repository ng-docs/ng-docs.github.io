{
  "id": "guide/dependency-injection-in-action",
  "title": "Dependency Injection in Action",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/dependency-injection-in-action.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"dependency-injection-in-action\" translation-result=\"on\">依赖注入实战<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#dependency-injection-in-action\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"dependency-injection-in-action\">Dependency Injection in Action<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#dependency-injection-in-action\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">本节将会涉及 Angular 依赖注入（DI）的很多特性。</p><p translation-origin=\"off\">This section explores many of the features of dependency injection (DI) in Angular.</p>\n\n<a id=\"toc\"></a>\n<p translation-result=\"on\">要获取本文的代码，<strong>参见<live-example name=\"dependency-injection-in-action\"></live-example></strong>。</p><p translation-origin=\"off\">See the <live-example name=\"dependency-injection-in-action\"></live-example>\nof the code in this cookbook.</p>\n\n<a id=\"nested-dependencies\"></a>\n<h2 id=\"nested-service-dependencies\" translation-result=\"on\">嵌套的服务依赖<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#nested-service-dependencies\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"nested-service-dependencies\">Nested service dependencies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#nested-service-dependencies\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">这些被注入服务的消费者不需要知道如何创建这个服务。新建和缓存这个服务是依赖注入器的工作。消费者只要让依赖注入框架知道它需要哪些依赖项就可以了。</p><p translation-origin=\"off\">The <em>consumer</em> of an injected service doesn't need to know how to create that service.\nIt's the job of the DI framework to create and cache dependencies. The consumer just\nneeds to let the DI framework know which dependencies it needs.</p>\n\n<p translation-result=\"on\">有时候一个服务依赖其它服务...而其它服务可能依赖另外的更多服务。\n依赖注入框架会负责正确的顺序解析这些嵌套的依赖项。\n在每一步，依赖的使用者只要在它的构造函数里简单声明它需要什么，框架就会完成所有剩下的事情。</p><p translation-origin=\"off\">Sometimes a service depends on other services, which may depend on yet other services.\nThe dependency injection framework resolves these nested dependencies in the correct order.\nAt each step, the consumer of dependencies declares what it requires in its\nconstructor, and lets the framework provide them.</p>\n\n<p translation-result=\"on\">下面的例子往 <code>AppComponent</code> 里声明它依赖 <code>LoggerService</code> 和 <code>UserContext</code>。</p><p translation-origin=\"off\">The following example shows that <code>AppComponent</code> declares its dependence on <code>LoggerService</code> and <code>UserContext</code>.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/app.component.ts\" region=\"ctor\" header=\"src/app/app.component.ts\" linenums=\"false\">\nconstructor(logger: LoggerService, public userContext: UserContextService) {\n  userContext.loadUser(this.userId);\n  logger.logInfo('AppComponent initialized');\n}\n\n</code-example>\n<p translation-result=\"on\"><code>UserContext</code> 转而依赖 <code>LoggerService</code> 和 <code>UserService</code>（这个服务用来收集特定用户信息）。</p><p translation-origin=\"off\"><code>UserContext</code> in turn depends on both <code>LoggerService</code> and\n<code>UserService</code>, another service that gathers information about a particular user.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/user-context.service.ts\" region=\"injectables\" header=\"user-context.service.ts (injection)\" linenums=\"false\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root'\n})\nexport class UserContextService {\n  constructor(private userService: UserService, private loggerService: LoggerService) {\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">当 Angular 新建 <code>AppComponent</code> 时，依赖注入框架会先创建一个 <code>LoggerService</code> 的实例，然后创建 <code>UserContextService</code> 实例。\n<code>UserContextService</code> 也需要框架刚刚创建的这个 <code>LoggerService</code> 实例，这样框架才能为它提供同一个实例。<code>UserContextService</code> 还需要框架创建过的 <code>UserService</code>。\n<code>UserService</code> 没有其它依赖，所以依赖注入框架可以直接 <code>new</code> 出该类的一个实例，并把它提供给 <code>UserContextService</code> 的构造函数。</p><p translation-origin=\"off\">When Angular creates <code>AppComponent</code>, the DI framework creates an instance of <code>LoggerService</code> and starts to create <code>UserContextService</code>.\n<code>UserContextService</code> also needs <code>LoggerService</code>, which the framework already has, so the framework can provide the same instance. <code>UserContextService</code> also needs <code>UserService</code>, which the framework has yet to create. <code>UserService</code> has no further dependencies, so the framework can simply use <code>new</code> to instantiate the class and provide the instance to the <code>UserContextService</code> constructor.</p>\n\n<p translation-result=\"on\">父组件 <code>AppComponent</code> 不需要了解这些依赖的依赖。\n只要在构造函数中声明自己需要的依赖即可（这里是 <code>LoggerService</code> 和 <code>UserContextService</code>），框架会帮你解析这些嵌套的依赖。</p><p translation-origin=\"off\">The parent <code>AppComponent</code> doesn't need to know about the dependencies of dependencies.\nDeclare what's needed in the constructor (in this case <code>LoggerService</code> and <code>UserContextService</code>)\nand the framework resolves the nested dependencies.</p>\n\n<p translation-result=\"on\">当所有的依赖都就位之后，<code>AppComponent</code> 就会显示该用户的信息。</p><p translation-origin=\"off\">When all dependencies are in place, <code>AppComponent</code> displays the user information.</p>\n\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/logged-in-user.png\" alt=\"Logged In User\" width=\"145\" height=\"99\">\n</figure>\n<a id=\"service-scope\"></a>\n<h2 id=\"limit-service-scope-to-a-component-subtree\" translation-result=\"on\">把服务的范围限制到某个组件的子树下<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#limit-service-scope-to-a-component-subtree\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"limit-service-scope-to-a-component-subtree\">Limit service scope to a component subtree<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#limit-service-scope-to-a-component-subtree\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Angular 应用程序有多个依赖注入器，组织成一个与组件树平行的树状结构。\n每个注入器都会创建依赖的一个单例。在所有该注入器负责提供服务的地方，所提供的都是同一个实例。\n可以在注入器树的任何层级提供和建立特定的服务。这意味着，如果在多个注入器中提供该服务，那么该服务也就会有多个实例。</p><p translation-origin=\"off\">An Angular application has multiple injectors, arranged in a tree hierarchy that parallels the component tree.\nEach injector creates a singleton instance of a dependency.\nThat same instance is injected wherever that injector provides that service.\nA particular service can be provided and created at any level of the injector hierarchy,\nwhich means that there can be multiple instances of a service if it is provided by multiple injectors.</p>\n\n<p translation-result=\"on\">由根注入器提供的依赖可以注入到应用中任何地方的任何组件中。\n但有时候你可能希望把服务的有效性限制到应用程序的一个特定区域。\n比如，你可能希望用户明确选择一个服务，而不是让根注入器自动提供它。</p><p translation-origin=\"off\">Dependencies provided by the root injector can be injected into <em>any</em> component <em>anywhere</em> in the application.\nIn some cases, you might want to restrict service availability to a particular region of the application.\nFor instance, you might want to let users explicitly opt in to use a service,\nrather than letting the root injector provide it automatically. </p>\n\n<p translation-result=\"on\">通过<em>在组件树的子级根组件</em>中提供服务，可以把一个被注入服务的作用域局限在应用程序结构中的某个<em>分支</em>中。\n这个例子中展示了如何通过把服务添加到子组件 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 装饰器的 <code>providers</code> 数组中，来为 <code>HeroesBaseComponent</code> 提供另一个 <code>HeroService</code> 实例：</p><p translation-origin=\"off\">You can limit the scope of an injected service to a <em>branch</em> of the application hierarchy\nby providing that service <em>at the sub-root component for that branch</em>.\nThis example shows how to make a different instance of <code>HeroService</code> available to <code>HeroesBaseComponent</code>\nby adding it to the <code>providers</code> array of the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator of the sub-component.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/sorted-heroes.component.ts\" region=\"injection\" header=\"src/app/sorted-heroes.component.ts (HeroesBaseComponent excerpt)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-unsorted-heroes',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">{{hero.name}}&#x3C;/div>`,\n  providers: [HeroService]\n})\nexport class HeroesBaseComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private heroService: HeroService) { }\n}\n\n</code-example>\n<p translation-result=\"on\">当 Angular 新建 <code>HeroBaseComponent</code> 的时候，它会同时新建一个 <code>HeroService</code> 实例，该实例只在该组件及其子组件(如果有)中可见。</p><p translation-origin=\"off\">When Angular creates <code>HeroesBaseComponent</code>, it also creates a new instance of <code>HeroService</code>\nthat is visible only to that component and its children, if any.</p>\n\n<p translation-result=\"on\">也可以在应用程序别处的另一个组件里提供 <code>HeroService</code>。这样就会导致在另一个注入器中存在该服务的另一个实例。</p><p translation-origin=\"off\">You could also provide <code>HeroService</code> to a different component elsewhere in the application.\nThat would result in a different instance of the service, living in a different injector.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">这个例子中，局部化的 <code>HeroService</code> 单例，遍布整份范例代码，包括 <code>HeroBiosComponent</code>、<code>HeroOfTheMonthComponent</code> 和 <code>HeroBaseComponent</code>。\n这些组件每个都有自己的 <code>HeroService</code> 实例，用来管理独立的英雄库。</p><p translation-origin=\"off\">Examples of such scoped <code>HeroService</code> singletons appear throughout the accompanying sample code,\nincluding <code>HeroBiosComponent</code>, <code>HeroOfTheMonthComponent</code>, and <code>HeroesBaseComponent</code>.\nEach of these components has its own <code>HeroService</code> instance managing its own independent collection of heroes.</p>\n\n</div>\n<a id=\"multiple-service-instances\"></a>\n<h2 id=\"multiple-service-instances-sandboxing\" translation-result=\"on\">多个服务实例(沙箱式隔离)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#multiple-service-instances-sandboxing\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"multiple-service-instances-sandboxing\">Multiple service instances (sandboxing)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#multiple-service-instances-sandboxing\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在组件树的<em>同一个级别</em>上，有时需要一个服务的多个实例。</p><p translation-origin=\"off\">Sometimes you want multiple instances of a service at <em>the same level</em> of the component hierarchy.</p>\n\n<p translation-result=\"on\">一个用来保存其伴生组件的实例状态的服务就是个好例子。\n每个组件都需要该服务的单独实例。\n每个服务有自己的工作状态，与其它组件的服务和状态隔离。这叫做<em>沙箱化</em>，因为每个服务和组件实例都在自己的沙箱里运行。</p><p translation-origin=\"off\">A good example is a service that holds state for its companion component instance.\nYou need a separate instance of the service for each component.\nEach service has its own work-state, isolated from the service-and-state of a different component.\nThis is called <em>sandboxing</em> because each service and component instance has its own sandbox to play in.</p>\n\n<a id=\"hero-bios-component\"></a>\n<p translation-result=\"on\">在这个例子中，<code>HeroBiosComponent</code> 呈现了 <code>HeroBioComponent</code> 的三个实例。</p><p translation-origin=\"off\">In this example, <code>HeroBiosComponent</code> presents three instances of <code>HeroBioComponent</code>.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"simple\" header=\"ap/hero-bios.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-bios',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;app-hero-bio [heroId]=\"1\">&#x3C;/app-hero-bio>\n    &#x3C;app-hero-bio [heroId]=\"2\">&#x3C;/app-hero-bio>\n    &#x3C;app-hero-bio [heroId]=\"3\">&#x3C;/app-hero-bio>`,\n  providers: [HeroService]\n})\nexport class HeroBiosComponent {\n}\n\n</code-example>\n<p translation-result=\"on\">每个 <code>HeroBioComponent</code> 都能编辑一个英雄的生平。<code>HeroBioComponent</code> 依赖 <code>HeroCacheService</code> 服务来对该英雄进行读取、缓存和执行其它持久化操作。</p><p translation-origin=\"off\">Each <code>HeroBioComponent</code> can edit a single hero's biography.\n<code>HeroBioComponent</code> relies on <code>HeroCacheService</code> to fetch, cache, and perform other persistence operations on that hero.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/hero-cache.service.ts\" region=\"service\" header=\"src/app/hero-cache.service.ts\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroCacheService {\n  hero: Hero;\n  constructor(private heroService: HeroService) {}\n\n  fetchCachedHero(id: number) {\n    if (!this.hero) {\n      this.hero = this.heroService.getHeroById(id);\n    }\n    return this.hero;\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">这三个 <code>HeroBioComponent</code> 实例不能共享同一个 <code>HeroCacheService</code> 实例。否则它们会相互冲突，争相把自己的英雄放在缓存里面。</p><p translation-origin=\"off\">Three instances of <code>HeroBioComponent</code> can't share the same instance of <code>HeroCacheService</code>,\nas they'd be competing with each other to determine which hero to cache.</p>\n\n<p translation-result=\"on\">它们应该通过在自己的元数据(metadata)<code>providers</code> 数组里面列出 <code>HeroCacheService</code>, 这样每个 <code>HeroBioComponent</code> 就能<em>拥有</em>自己独立的 <code>HeroCacheService</code> 实例了。</p><p translation-origin=\"off\">Instead, each <code>HeroBioComponent</code> gets its <em>own</em> <code>HeroCacheService</code> instance\nby listing <code>HeroCacheService</code> in its metadata <code>providers</code> array.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/hero-bio.component.ts\" region=\"component\" header=\"src/app/hero-bio.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-bio',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;h4>{{hero.name}}&#x3C;/h4>\n    &#x3C;ng-content>&#x3C;/ng-content>\n    &#x3C;<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a> cols=\"25\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.description\">&#x3C;/<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a>>`,\n  providers: [HeroCacheService]\n})\n\nexport class HeroBioComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>  {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() heroId: number;\n\n  constructor(private heroCache: HeroCacheService) { }\n\n  ngOnInit() { this.heroCache.fetchCachedHero(this.heroId); }\n\n  get hero() { return this.heroCache.hero; }\n}\n\n</code-example>\n<p translation-result=\"on\">父组件 <code>HeroBiosComponent</code> 把一个值绑定到 <code>heroId</code>。<code>ngOnInit</code> 把该 <code>id</code> 传递到服务，然后服务获取和缓存英雄。<code>hero</code> 属性的 getter 从服务里面获取缓存的英雄，并在模板里显示它绑定到属性值。</p><p translation-origin=\"off\">The parent <code>HeroBiosComponent</code> binds a value to <code>heroId</code>.\n<code>ngOnInit</code> passes that ID to the service, which fetches and caches the hero.\nThe getter for the <code>hero</code> property pulls the cached hero from the service.\nThe template displays this data-bound property.</p>\n\n<p translation-result=\"on\">到<live-example name=\"dependency-injection-in-action\">在线例子</live-example>中找到这个例子，确认三个 <code>HeroBioComponent</code> 实例拥有自己独立的英雄数据缓存。</p><p translation-origin=\"off\">Find this example in <live-example name=\"dependency-injection-in-action\">live code</live-example>\nand confirm that the three <code>HeroBioComponent</code> instances have their own cached hero data.</p>\n\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/hero-bios.png\" alt=\"Bios\" width=\"199\" height=\"317\">\n</figure>\n<a id=\"qualify-dependency-lookup\"></a>\n<h2 id=\"qualify-dependency-lookup-with-parameter-decorators\" translation-result=\"on\">使用参数装饰器来限定依赖查找方式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#qualify-dependency-lookup-with-parameter-decorators\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"qualify-dependency-lookup-with-parameter-decorators\">Qualify dependency lookup with parameter decorators<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#qualify-dependency-lookup-with-parameter-decorators\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">当类需要某个依赖项时，该依赖项就会作为参数添加到类的构造函数中。\n当 Angular 需要实例化该类时，就会调用 DI 框架来提供该依赖。\n默认情况下，DI 框架会在注入器树中查找一个提供商，从该组件的局部注入器开始，如果需要，则沿着注入器树向上冒泡，直到根注入器。</p><p translation-origin=\"off\">When a class requires a dependency, that dependency is added to the constructor as a parameter.\nWhen Angular needs to instantiate the class, it calls upon the DI framework to supply the dependency.\nBy default, the DI framework searches for a provider in the injector hierarchy,\nstarting at the component's local injector of the component, and if necessary bubbling up\nthrough the injector tree until it reaches the root injector.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">第一个配置了该提供商的注入器就会把依赖（服务实例或值）提供给这个构造函数。</p><p translation-origin=\"off\">The first injector configured with a provider supplies the dependency (a service instance or value) to the constructor.  </p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果在根注入器中也没有找到提供商，则 DI 框架将会给构造函数返回一个 null。</p><p translation-origin=\"off\">If no provider is found in the root injector, the DI framework returns null to the constructor.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">通过在类的构造函数中对服务参数使用<em>参数装饰器</em>，可以提供一些选项来修改默认的搜索行为。</p><p translation-origin=\"off\">There are a number of options for modifying the default search behavior, using <em>parameter decorators</em>\non the service-valued parameters of a class constructor. </p>\n\n<a id=\"optional\"></a>\n<h3 id=\"make-a-dependency-codeoptionalcode-and-limit-search-with-codehostcode\" translation-result=\"on\">用 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> 来让依赖是可选的，以及使用 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> 来限定搜索方式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#make-a-dependency-codeoptionalcode-and-limit-search-with-codehostcode\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"make-a-dependency-optional-and-limit-search-with-host\">Make a dependency <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> and limit search with <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#make-a-dependency-optional-and-limit-search-with-host\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">依赖可以注册在组件树的任何层级上。\n当组件请求某个依赖时，Angular 会从该组件的注入器找起，沿着注入器树向上，直到找到了第一个满足要求的提供商。如果没找到依赖，Angular 就会抛出一个错误。</p><p translation-origin=\"off\">Dependencies can be registered at any level in the component hierarchy.\nWhen a component requests a dependency, Angular starts with that component's injector\nand walks up the injector tree until it finds the first suitable provider.<br>\nAngular throws an error if it can't find the dependency during that walk.</p>\n\n<p translation-result=\"on\">某些情况下，你需要限制搜索，或容忍依赖项的缺失。\n你可以使用组件构造函数参数上的 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> 和 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> 这两个限定装饰器来修改 Angular 的搜索行为。</p><p translation-origin=\"off\">In some cases, you need to limit the search or accommodate a missing dependency.\nYou can modify Angular's search behavior with the <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> and <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> qualifying\ndecorators on a service-valued parameter of the component's constructor. </p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> 属性装饰器告诉 Angular 当找不到依赖时就返回 null。</p><p translation-origin=\"off\">The <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> property decorator tells Angular to return null when it can't find the dependency.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">  <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> 属性装饰器会禁止在<em>宿主组件</em>以上的搜索。宿主组件通常就是请求该依赖的那个组件。\n不过，当该组件投影进某个<em>父</em>组件时，那个父组件就会变成宿主。下面的例子中介绍了第二种情况。</p><p translation-origin=\"off\">The <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> property decorator stops the upward search at the <em>host component</em>.\nThe host component is typically the component requesting the dependency.\nHowever, when this component is projected into a <em>parent</em> component,\nthat parent component becomes the host. The following example covers this second case.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">如下例所示，这些装饰器可以独立使用，也可以同时使用。这个<code>HeroBiosAndContactsComponent</code> 是你<a href=\"guide/dependency-injection-in-action#hero-bios-component\">以前</a>见过的那个 <code>HeroBiosComponent</code> 的修改版。</p><p translation-origin=\"off\">These decorators can be used individually or together, as shown in the example.\nThis <code>HeroBiosAndContactsComponent</code> is a revision of <code>HeroBiosComponent</code> which you looked at <a href=\"guide/dependency-injection-in-action#hero-bios-component\">above</a>.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"hero-bios-and-contacts\" header=\"src/app/hero-bios.component.ts (HeroBiosAndContactsComponent)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-bios-and-contacts',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;app-hero-bio [heroId]=\"1\"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio>\n    &#x3C;app-hero-bio [heroId]=\"2\"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio>\n    &#x3C;app-hero-bio [heroId]=\"3\"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio>`,\n  providers: [HeroService]\n})\nexport class HeroBiosAndContactsComponent {\n  constructor(logger: LoggerService) {\n    logger.logInfo('Creating HeroBiosAndContactsComponent');\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">注意看模板：</p><p translation-origin=\"off\">Focus on the template:</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"template\" header=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" linenums=\"false\">\n<a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n  &#x3C;app-hero-bio [heroId]=\"1\"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio>\n  &#x3C;app-hero-bio [heroId]=\"2\"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio>\n  &#x3C;app-hero-bio [heroId]=\"3\"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio>`,\n\n</code-example>\n<p translation-result=\"on\">在 <code>&#x3C;hero-bio></code> 标签中是一个新的 <code>&#x3C;hero-contact></code> 元素。Angular 就会把相应的 <code>HeroContactComponent</code><em>投影</em>(<em>transclude</em>)进 <code>HeroBioComponent</code> 的视图里，\n将它放在 <code>HeroBioComponent</code> 模板的 <code>&#x3C;ng-content></code> 标签槽里。</p><p translation-origin=\"off\">Now there's a new <code>&#x3C;hero-contact></code> element between the <code>&#x3C;hero-bio></code> tags.\nAngular <em>projects</em>, or <em>transcludes</em>, the corresponding <code>HeroContactComponent</code> into the <code>HeroBioComponent</code> view,\nplacing it in the <code>&#x3C;ng-content></code> slot of the <code>HeroBioComponent</code> template.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/hero-bio.component.ts\" region=\"template\" header=\"src/app/hero-bio.component.ts (template)\" linenums=\"false\">\n<a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n  &#x3C;h4>{{hero.name}}&#x3C;/h4>\n  &#x3C;ng-content>&#x3C;/ng-content>\n  &#x3C;<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a> cols=\"25\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.description\">&#x3C;/<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a>>`,\n\n</code-example>\n<p translation-result=\"on\">从 <code>HeroContactComponent</code> 获得的英雄电话号码，被投影到上面的英雄描述里，结果如下：</p><p translation-origin=\"off\">The result is shown below, with the hero's telephone number from <code>HeroContactComponent</code> projected above the hero description.</p>\n\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/hero-bio-and-content.png\" alt=\"bio and contact\" width=\"199\" height=\"92\">\n</figure>\n<p translation-result=\"on\">这里的 <code>HeroContactComponent</code> 演示了限定型装饰器。</p><p translation-origin=\"off\">Here's <code>HeroContactComponent</code>, which demonstrates the qualifying decorators.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/hero-contact.component.ts\" region=\"component\" header=\"src/app/hero-contact.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-contact',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n  &#x3C;div>Phone #: {{phoneNumber}}\n  &#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hasLogger\">!!!&#x3C;/span>&#x3C;/div>`\n})\nexport class HeroContactComponent {\n\n  hasLogger = false;\n\n  constructor(\n      @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() // <a href=\"api/animations/AnimationQueryOptions#limit\" class=\"code-anchor\">limit</a> to the <a href=\"api/core/Directive#host\" class=\"code-anchor\">host</a> component's instance of the HeroCacheService\n      private heroCache: HeroCacheService,\n\n      @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()     // <a href=\"api/animations/AnimationQueryOptions#limit\" class=\"code-anchor\">limit</a> <a href=\"api/common/PlatformLocation#search\" class=\"code-anchor\">search</a> for logger; hides the application-wide logger\n      @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() // ok if the logger doesn't exist\n      private loggerService: LoggerService\n  ) {\n    if (loggerService) {\n      this.hasLogger = true;\n      loggerService.logInfo('HeroContactComponent can <a href=\"api/animations/browser/testing/MockAnimationDriver#log\" class=\"code-anchor\">log</a>!');\n    }\n  }\n\n  get phoneNumber() { return this.heroCache.hero.phone; }\n\n}\n\n</code-example>\n<p translation-result=\"on\">注意构造函数的参数。</p><p translation-origin=\"off\">Focus on the constructor parameters.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/hero-contact.component.ts\" region=\"ctor-params\" header=\"src/app/hero-contact.component.ts\" linenums=\"false\">\n@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() // <a href=\"api/animations/AnimationQueryOptions#limit\" class=\"code-anchor\">limit</a> to the <a href=\"api/core/Directive#host\" class=\"code-anchor\">host</a> component's instance of the HeroCacheService\nprivate heroCache: HeroCacheService,\n\n@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()     // <a href=\"api/animations/AnimationQueryOptions#limit\" class=\"code-anchor\">limit</a> <a href=\"api/common/PlatformLocation#search\" class=\"code-anchor\">search</a> for logger; hides the application-wide logger\n@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() // ok if the logger doesn't exist\nprivate loggerService: LoggerService\n\n</code-example>\n<p translation-result=\"on\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 函数是构造函数属性 <code>heroCache</code> 的装饰器，确保从其父组件 <code>HeroBioComponent</code> 得到一个缓存服务。如果该父组件不存在这个服务，Angular 就会抛出错误，即使组件树里的再上级有某个组件拥有这个服务，Angular 也会抛出错误。</p><p translation-origin=\"off\">The <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> function decorating the  <code>heroCache</code> constructor property ensures that\nyou get a reference to the cache service from the parent <code>HeroBioComponent</code>.\nAngular throws an error if the parent lacks that service, even if a component higher\nin the component tree includes it.</p>\n\n<p translation-result=\"on\">另一个 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 函数是构造函数属性 <code>loggerService</code> 的装饰器。\n在本应用程序中只有一个在 <code>AppComponent</code> 级提供的 <code>LoggerService</code> 实例。\n该宿主 <code>HeroBioComponent</code> 没有自己的 <code>LoggerService</code> 提供商。</p><p translation-origin=\"off\">A second <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> function decorates the <code>loggerService</code> constructor property.\nThe only <code>LoggerService</code> instance in the app is provided at the <code>AppComponent</code> level.\nThe host <code>HeroBioComponent</code> doesn't have its own <code>LoggerService</code> provider.</p>\n\n<p translation-result=\"on\">如果没有同时使用 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 装饰器的话，Angular 就会抛出错误。当该属性带有 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 标记时，Angular 就会把 <code>loggerService</code> 设置为 null，并继续执行组件而不会抛出错误。</p><p translation-origin=\"off\">Angular throws an error if you haven't also decorated the property with <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>.\nWhen the property is marked as optional, Angular sets <code>loggerService</code> to null and the rest of the component adapts.</p>\n\n<p translation-result=\"on\">下面是 <code>HeroBiosAndContactsComponent</code> 的执行结果：</p><p translation-origin=\"off\">Here's <code>HeroBiosAndContactsComponent</code> in action.</p>\n\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/hero-bios-and-contacts.png\" alt=\"Bios with contact into\" width=\"206\" height=\"393\">\n</figure>\n<p translation-result=\"on\">如果注释掉 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 装饰器，Angular 就会沿着注入器树往上走，直到在 <code>AppComponent</code> 中找到该日志服务。日志服务的逻辑加了进来，所显示的英雄信息增加了 \"!!!\" 标记，这表明确实找到了日志服务。</p><p translation-origin=\"off\">If you comment out the <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> decorator, Angular walks up the injector ancestor tree\nuntil it finds the logger at the <code>AppComponent</code> level.\nThe logger logic kicks in and the hero display updates\nwith the \"!!!\" marker to indicate that the logger was found.</p>\n\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/hero-bio-contact-no-host.png\" alt=\"Without @Host\" width=\"199\" height=\"93\">\n</figure>\n<p translation-result=\"on\">如果你恢复了 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 装饰器，并且注释掉 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> 装饰器，应用就会抛出一个错误，因为它在宿主组件这一层找不到所需的 <code>Logger</code>。<code>EXCEPTION: No provider for LoggerService! (HeroContactComponent -> LoggerService)</code></p><p translation-origin=\"off\">If you restore the <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> decorator and comment out <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code>,\nthe app throws an exception when it cannot find the required logger at the host component level.\n<code>EXCEPTION: No provider for LoggerService! (HeroContactComponent -> LoggerService)</code></p>\n\n<h3 id=\"supply-a-custom-provider-with-codeinjectcode\" translation-result=\"on\">使用 <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> 指定自定义提供商<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#supply-a-custom-provider-with-codeinjectcode\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"supply-a-custom-provider-with-inject\">Supply a custom provider with <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#supply-a-custom-provider-with-inject\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">自定义提供商让你可以为隐式依赖提供一个具体的实现，比如内置浏览器 API。下面的例子使用 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 来提供 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage\">localStorage</a>，将其作为 <code>BrowserStorageService</code> 的依赖项。</p><p translation-origin=\"off\">Using a custom provider allows you to provide a concrete implementation for implicit dependencies, such as built-in browser APIs. The following example uses an <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> to provide the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage\">localStorage</a> browser API as a dependency in the <code>BrowserStorageService</code>. </p>\n\n<code-example path=\"dependency-injection-in-action/src/app/storage.service.ts\" header=\"src/app/storage.service.ts\">\nimport { <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>, <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>, <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a> } from '@angular/core';\n\nexport const BROWSER_STORAGE = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>&#x3C;Storage>('Browser Storage', {\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n  <a href=\"api/core/ResolvedReflectiveFactory#factory\" class=\"code-anchor\">factory</a>: () => localStorage\n});\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root'\n})\nexport class BrowserStorageService {\n  constructor(@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(BROWSER_STORAGE) public storage: Storage) {}\n\n  get(key: string) {\n    this.storage.getItem(key);\n  }\n\n  set(key: string, value: string) {\n    this.storage.setItem(key, value);\n  }\n\n  remove(key: string) {\n    this.storage.removeItem(key);\n  }\n\n  clear() {\n    this.storage.clear();\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\"><code><a href=\"api/core/ResolvedReflectiveFactory#factory\" class=\"code-anchor\">factory</a></code> 函数返回 window 对象上的 <code>localStorage</code> 属性。<code><a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> 装饰器修饰一个构造函数参数，用于为某个依赖提供自定义提供商。现在，就可以在测试期间使用 <code>localStorage</code> 的 Mock API 来覆盖这个提供商了，而不必与真实的浏览器 API 进行交互。</p><p translation-origin=\"off\">The <code><a href=\"api/core/ResolvedReflectiveFactory#factory\" class=\"code-anchor\">factory</a></code> function returns the <code>localStorage</code> property that is attached to the browser window object. The <code><a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> decorator is a constructor parameter used to specify a custom provider of a dependency. This custom provider can now be overridden during testing with a mock API of <code>localStorage</code> instead of interactive with real browser APIs.</p>\n\n<h3 id=\"modify-the-provider-search-with-codeselfcode-and-codeskipselfcode\" translation-result=\"on\">使用 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> 和 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 来修改提供商的搜索方式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#modify-the-provider-search-with-codeselfcode-and-codeskipselfcode\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"modify-the-provider-search-with-self-and-skipself\">Modify the provider search with <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> and <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#modify-the-provider-search-with-self-and-skipself\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">注入器也可以通过构造函数的参数装饰器来指定范围。下面的例子就在 <code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 类的 <code>providers</code> 中使用浏览器的 <code>sessionStorage</code> API 覆盖了 <code>BROWSER_STORAGE</code> 令牌。同一个 <code>BrowserStorageService</code> 在构造函数中使用 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> 和 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 装饰器注入了两次，来分别指定由哪个注入器来提供依赖。</p><p translation-origin=\"off\">Providers can also be scoped by injector through constructor parameter decorators. The following example overrides the <code>BROWSER_STORAGE</code> token in the <code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> class <code>providers</code> with the <code>sessionStorage</code> browser API. The same <code>BrowserStorageService</code> is injected twice in the constructor, decorated with <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> and <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> to define which injector handles the provider dependency.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/storage.component.ts\" header=\"src/app/storage.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/Self\" class=\"code-anchor\">Self</a>, <a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a> } from '@angular/core';\nimport { BROWSER_STORAGE, BrowserStorageService } from './storage.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-storage',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    <a href=\"api/http/ReadyState#Open\" class=\"code-anchor\">Open</a> the inspector to see the local/session storage <a href=\"api/router/ParamMap#keys\" class=\"code-anchor\">keys</a>:\n\n    &#x3C;h3>Session Storage&#x3C;/h3>\n    &#x3C;button (click)=\"setSession()\">Set Session Storage&#x3C;/button>\n\n    &#x3C;h3>Local Storage&#x3C;/h3>\n    &#x3C;button (click)=\"setLocal()\">Set Local Storage&#x3C;/button>\n  `,\n  providers: [\n    BrowserStorageService,\n    { provide: BROWSER_STORAGE, useFactory: () => sessionStorage }\n  ]\n})\nexport class StorageComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n\n  constructor(\n    @<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>() private sessionStorageService: BrowserStorageService,\n    @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() private localStorageService: BrowserStorageService,\n  ) { }\n\n  ngOnInit() {\n  }\n\n  setSession() {\n    this.sessionStorageService.set('hero', 'Mr. Nice - Session');\n  }\n\n  setLocal() {\n    this.localStorageService.set('hero', 'Mr. Nice - Local');\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\">使用 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> 装饰器时，注入器只在该组件的注入器中查找提供商。<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 装饰器可以让你跳过局部注入器，并在注入器树中向上查找，以发现哪个提供商满足该依赖。\n<code>sessionStorageService</code> 实例使用浏览器的 <code>sessionStorage</code> 来跟 <code>BrowserStorageService</code> 打交道，而 <code>localStorageService</code> 跳过了局部注入器，使用根注入器提供的 <code>BrowserStorageService</code>，它使用浏览器的 <code>localStorage</code> API。</p><p translation-origin=\"off\">Using the <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> decorator, the injector only looks at the component's injector for its providers. The <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> decorator allows you to skip the local injector and look up in the hierarchy to find a provider that satisfies this dependency. The <code>sessionStorageService</code> instance interacts with the <code>BrowserStorageService</code> using the <code>sessionStorage</code> browser API, while the <code>localStorageService</code> skips the local injector and uses the root <code>BrowserStorageService</code> that uses the <code>localStorage</code> browswer API.</p>\n\n<a id=\"component-element\"></a>\n<h2 id=\"inject-the-components-dom-element\" translation-result=\"on\">注入组件的 DOM 元素<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#inject-the-components-dom-element\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"inject-the-components-dom-element\">Inject the component's DOM element<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#inject-the-components-dom-element\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">即便开发者极力避免，仍然会有很多视觉效果和第三方工具 (比如 jQuery) 需要访问 DOM。这会让你不得不访问组件所在的 DOM 元素。</p><p translation-origin=\"off\">Although developers strive to avoid it, many visual effects and third-party tools, such as jQuery,\nrequire DOM access.\nAs a result, you might need to access a component's DOM element.</p>\n\n<p translation-result=\"on\">要说明这一点，请在<a href=\"guide/attribute-directives\">属性型指令</a><code>HighlightDirective</code> 的基础上，编写一个简化版。</p><p translation-origin=\"off\">To illustrate, here's a simplified version of <code>HighlightDirective</code> from\nthe <a href=\"guide/attribute-directives\">Attribute Directives</a> page.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/highlight.directive.ts\" header=\"src/app/highlight.directive.ts\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appHighlight]'\n})\nexport class HighlightDirective {\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('appHighlight') highlightColor: string;\n\n  private el: HTMLElement;\n\n  constructor(el: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>) {\n    this.el = el.nativeElement;\n  }\n\n  @<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseenter') onMouseEnter() {\n    this.highlight(this.highlightColor || 'cyan');\n  }\n\n  @<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseleave') onMouseLeave() {\n    this.highlight(null);\n  }\n\n  private highlight(color: string) {\n    this.el.style.backgroundColor = color;\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\">当用户把鼠标移到 DOM 元素上时，指令将指令所在的元素的背景设置为一个高亮颜色。</p><p translation-origin=\"off\">The directive sets the background to a highlight color when the user mouses over the\nDOM element to which the directive is applied.</p>\n\n<p translation-result=\"on\">Angular 把构造函数参数 <code>el</code> 设置为注入的 <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code>，该 <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code> 代表了宿主的 DOM 元素， 它的 <code>nativeElement</code> 属性把该 DOM 元素暴露给了指令。</p><p translation-origin=\"off\">Angular sets the constructor's <code>el</code> parameter to the injected <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code>.\n(An <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code> is a wrapper around a DOM element,\nwhose <code>nativeElement</code> property exposes the DOM element for the directive to manipulate.)</p>\n\n<p translation-result=\"on\">下面的代码把指令的 <code>myHighlight</code> 属性(Attribute)填加到两个 <code>&#x3C;div></code> 标签里，一个没有赋值，一个赋值了颜色。</p><p translation-origin=\"off\">The sample code applies the directive's <code>myHighlight</code> attribute to two <code>&#x3C;div></code> tags,\nfirst without a value (yielding the default color) and then with an assigned color value.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/app.component.html\" region=\"highlight\" header=\"src/app/app.component.html (highlight)\" linenums=\"false\">\n&#x3C;div id=\"highlight\"  class=\"di-component\"  appHighlight>\n  &#x3C;h3>Hero Bios and Contacts&#x3C;/h3>\n  &#x3C;div appHighlight=\"yellow\">\n    &#x3C;app-hero-bios-and-contacts>&#x3C;/app-hero-bios-and-contacts>\n  &#x3C;/div>\n&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\">下图显示了鼠标移到 <code>&#x3C;hero-bios-and-contacts></code> 标签的效果：</p><p translation-origin=\"off\">The following image shows the effect of mousing over the <code>&#x3C;hero-bios-and-contacts></code> tag.</p>\n\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/highlight.png\" alt=\"Highlighted bios\" width=\"318\" height=\"196\">\n</figure>\n<a id=\"providers\"></a>\n<h2 id=\"define-dependencies-with-providers\" translation-result=\"on\">使用提供商来定义依赖<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#define-dependencies-with-providers\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"define-dependencies-with-providers\">Define dependencies with providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#define-dependencies-with-providers\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">本节会示范如何编写提供商来交付被依赖的服务。</p><p translation-origin=\"off\">This section demonstrates how to write providers that deliver dependent services.</p>\n\n<p translation-result=\"on\">为了从依赖注入器中获取服务，你必须传给它一个<a href=\"guide/glossary#token\">令牌</a>。\nAngular 通常会通过指定构造函数参数以及参数的类型来处理它。\n参数的类型可以用作注入器的查阅令牌。\nAngular 会把该令牌传给注入器，并把它的结果赋给相应的参数。</p><p translation-origin=\"off\">In order to get a service from a dependency injector, you have to give it a <a href=\"guide/glossary#token\">token</a>.\nAngular usually handles this transaction by specifying a constructor parameter and its type.\nThe parameter type serves as the injector lookup token.\nAngular passes this token to the injector and assigns the result to the parameter.</p>\n\n<p translation-result=\"on\">下面是一个典型的例子。</p><p translation-origin=\"off\">The following is a typical example.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"ctor\" header=\"src/app/hero-bios.component.ts (component constructor injection)\" linenums=\"false\">\nconstructor(logger: LoggerService) {\n  logger.logInfo('Creating HeroBiosComponent');\n}\n\n</code-example>\n<p translation-result=\"on\">Angular 会要求注入器提供与 <code>LoggerService</code> 相关的服务，并把返回的值赋给 <code>logger</code> 参数。</p><p translation-origin=\"off\">Angular asks the injector for the service associated with <code>LoggerService</code>\nand assigns the returned value to the <code>logger</code> parameter.</p>\n\n<p translation-result=\"on\">如果注入器已经缓存了与该令牌相关的服务实例，那么它就会直接提供此实例。\n如果它没有，它就要使用与该令牌相关的提供商来创建一个。</p><p translation-origin=\"off\">If the injector has already cached an instance of the service associated with the token,\nit provides that instance.\nIf it doesn't, it needs to make one using the provider associated with the token.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">如果注入器无法根据令牌在自己内部找到对应的提供商，它便将请求移交给它的父级注入器，这个过程不断重复，直到没有更多注入器为止。\n如果没找到，注入器就抛出一个错误...除非这个请求是<a href=\"guide/dependency-injection-in-action#optional\">可选的</a>。</p><p translation-origin=\"off\">If the injector doesn't have a provider for a requested token, it delegates the request\nto its parent injector, where the process repeats until there are no more injectors.\nIf the search fails, the injector throws an error—unless the request was <a href=\"guide/dependency-injection-in-action#optional\">optional</a>.</p>\n\n</div>\n<p translation-result=\"on\">新的注入器没有提供商。\nAngular 会使用一组首选提供商来初始化它本身的注入器。\n你必须为自己应用程序特有的依赖项来配置提供商。</p><p translation-origin=\"off\">A new injector has no providers.\nAngular initializes the injectors it creates with a set of preferred providers.\nYou have to configure providers for your own app-specific dependencies. </p>\n\n<a id=\"defining-providers\"></a>\n<h3 id=\"defining-providers\" translation-result=\"on\">定义提供商<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#defining-providers\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"defining-providers\">Defining providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#defining-providers\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">用于实例化类的默认方法不一定总适合用来创建依赖。你可以到<a href=\"guide/dependency-injection-providers\">依赖提供商</a>部分查看其它方法。\n<code>HeroOfTheMonthComponent</code> 例子示范了一些替代方案，展示了为什么需要它们。\n它看起来很简单：一些属性和一些由 logger 生成的日志。</p><p translation-origin=\"off\">A dependency can't always be created by the default method of instantiating a class.\nYou learned about some other methods in <a href=\"guide/dependency-injection-providers\">Dependency Providers</a>.\nThe following <code>HeroOfTheMonthComponent</code> example demonstrates many of the alternatives and why you need them.\nIt's visually simple: a few properties and the logs produced by a logger.</p>\n\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/hero-of-month.png\" alt=\"Hero of the month\" width=\"300\" height=\"165\">\n</figure>\n<p translation-result=\"on\">它背后的代码定制了 DI 框架提供依赖项的方法和位置。\n这个例子阐明了通过<a href=\"guide/dependency-injection-providers#provide\"><em>提供</em>对象字面量</a>来把对象的定义和 DI 令牌关联起来的另一种方式。</p><p translation-origin=\"off\">The code behind it customizes how and where the DI framework provides dependencies.\nThe use cases illustrate different ways to use the <a href=\"guide/dependency-injection-providers#provide\"><em>provide</em> object literal</a> to associate a definition object with a DI token.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"hero-of-the-month\" header=\"hero-of-the-month.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> } from '@angular/core';\n\nimport { DateLoggerService } from './date-logger.service';\nimport { Hero }              from './hero';\nimport { HeroService }       from './hero.service';\nimport { LoggerService }     from './logger.service';\nimport { MinimalLogger }     from './minimal-logger.service';\nimport { RUNNERS_UP,\n         runnersUpFactory }  from './runners-up';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-of-the-month',\n  templateUrl: './hero-of-the-month.component.html',\n  providers: [\n    { provide: Hero,          useValue:    someHero },\n    { provide: TITLE,         useValue:   'Hero of the Month' },\n    { provide: HeroService,   useClass:    HeroService },\n    { provide: LoggerService, useClass:    DateLoggerService },\n    { provide: MinimalLogger, useExisting: LoggerService },\n    { provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), <a href=\"api/core/ConstructorSansProvider#deps\" class=\"code-anchor\">deps</a>: [Hero, HeroService] }\n  ]\n})\nexport class HeroOfTheMonthComponent {\n  logs: string[] = [];\n\n  constructor(\n      logger: MinimalLogger,\n      public heroOfTheMonth: Hero,\n      @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(RUNNERS_UP) public runnersUp: string,\n      @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(TITLE) public title: string)\n  {\n    this.logs = logger.logs;\n    logger.logInfo('starting up');\n  }\n}\n\n</code-example>\n<p translation-result=\"on\"><code>providers</code> 数组展示了你可以如何使用其它的键来定义提供商：<code>useValue</code>、<code>useClass</code>、<code>useExisting</code> 或 <code>useFactory</code>。</p><p translation-origin=\"off\">The <code>providers</code> array shows how you might use the different provider-definition keys;\n<code>useValue</code>, <code>useClass</code>, <code>useExisting</code>, or <code>useFactory</code>.</p>\n\n<a id=\"usevalue\"></a>\n<h4 id=\"value-providers-codeusevaluecode\" translation-result=\"on\">值提供商：<code>useValue</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#value-providers-codeusevaluecode\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"value-providers-usevalue\">Value providers: <code>useValue</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#value-providers-usevalue\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><code>useValue</code> 键让你可以为 DI 令牌关联一个固定的值。\n使用该技巧来进行<em>运行期常量设置</em>，比如网站的基础地址和功能标志等。\n你也可以在单元测试中使用<em>值提供商</em>，来用一个 Mock 数据来代替一个生产环境下的数据服务。</p><p translation-origin=\"off\">The <code>useValue</code> key lets you associate a fixed value with a DI token.\nUse this technique to provide <em>runtime configuration constants</em> such as website base addresses and feature flags.\nYou can also use a value provider in a unit test to provide mock data in place of a production data service.</p>\n\n<p translation-result=\"on\"><code>HeroOfTheMonthComponent</code> 例子中有两个<em>值-提供商</em>。</p><p translation-origin=\"off\">The <code>HeroOfTheMonthComponent</code> example has two value providers.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-value\" header=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" linenums=\"false\">\n{ provide: Hero,          useValue:    someHero },\n{ provide: TITLE,         useValue:   'Hero of the Month' },\n\n</code-example>\n<ul>\n<li>\n<p translation-result=\"on\">  第一处提供了用于 <code>Hero</code> 令牌的 <code>Hero</code> 类的现有实例，而不是要求注入器使用 <code>new</code> 来创建一个新实例或使用它自己的缓存实例。这里令牌就是这个类本身。</p><p translation-origin=\"off\">The first provides an existing instance of the <code>Hero</code> class to use for the <code>Hero</code> token, rather than\nrequiring the injector to create a new instance with <code>new</code> or use its own cached instance.\nHere, the token is the class itself.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">  第二处为 <code>TITLE</code> 令牌指定了一个字符串字面量资源。\n<code>TITLE</code> 提供商的令牌<em>不是一个类</em>，而是一个特别的提供商查询键，名叫<a href=\"guide/dependency-injection-in-action#injection-token\">InjectionToken</a>，表示一个 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 实例。</p><p translation-origin=\"off\">The second specifies a literal string resource to use for the <code>TITLE</code> token.\nThe <code>TITLE</code> provider token is <em>not</em> a class, but is instead a\nspecial kind of provider lookup key called an <a href=\"guide/dependency-injection-in-action#injection-token\">injection token</a>, represented by\nan <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> instance. </p>\n\n</li>\n</ul>\n<p translation-result=\"on\">你可以把 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 用作任何类型的提供商的令牌，但是当依赖是简单类型（比如字符串、数字、函数）时，它会特别有用。</p><p translation-origin=\"off\">You can use an injection token for any kind of provider but it's particularly\nhelpful when the dependency is a simple value like a string, a number, or a function.</p>\n\n<p translation-result=\"on\">一个<em>值-提供商</em>的值必须在指定之前定义。\n比如标题字符串就是立即可用的。\n该例中的 <code>someHero</code> 变量是以前在如下的文件中定义的。\n你不能使用那些要等以后才能定义其值的变量。</p><p translation-origin=\"off\">The value of a <em>value provider</em> must be defined before you specify it here.\nThe title string literal is immediately available.\nThe <code>someHero</code> variable in this example was set earlier in the file as shown below.\nYou can't use a variable whose value will be defined later.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"some-hero\" header=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\">\nconst someHero = new Hero(42, 'Magma', 'Had <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> great month!', '555-555-5555');\n\n</code-example>\n<p translation-result=\"on\">其它类型的提供商都会<em>惰性创建</em>它们的值，也就是说只在需要注入它们的时候才创建。</p><p translation-origin=\"off\">Other types of providers can create their values <em>lazily</em>; that is, when they're needed for injection.</p>\n\n<a id=\"useclass\"></a>\n<h4 id=\"class-providers-codeuseclasscode\" translation-result=\"on\">类提供商：<code>useClass</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#class-providers-codeuseclasscode\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"class-providers-useclass\">Class providers: <code>useClass</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#class-providers-useclass\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><code>useClass</code> 提供的键让你可以创建并返回指定类的新实例。</p><p translation-origin=\"off\">The <code>useClass</code> provider key lets you create and return a new instance of the specified class.</p>\n\n<p translation-result=\"on\">你可以使用这类提供商来为公共类或默认类换上一个<em>替代实现</em>。比如，这个替代实现可以实现一种不同的策略来扩展默认类，或在测试环境中模拟真实类的行为。</p><p translation-origin=\"off\">You can use this type of provider to substitute an <em>alternative implementation</em>\nfor a common or default class.\nThe alternative implementation could, for example, implement a different strategy,\nextend the default class, or emulate the behavior of the real class in a test case.</p>\n\n<p translation-result=\"on\">请看下面 <code>HeroOfTheMonthComponent</code> 里的两个例子：</p><p translation-origin=\"off\">The following code shows two examples in <code>HeroOfTheMonthComponent</code>.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-class\" header=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" linenums=\"false\">\n{ provide: HeroService,   useClass:    HeroService },\n{ provide: LoggerService, useClass:    DateLoggerService },\n\n</code-example>\n<p translation-result=\"on\">第一个提供商是<em>展开了语法糖的</em>，是一个典型情况的展开。一般来说，被新建的类(<code>HeroService</code>)同时也是该提供商的注入令牌。\n通常都选用缩写形式，完整形式可以让细节更明确。</p><p translation-origin=\"off\">The first provider is the <em>de-sugared</em>, expanded form of the most typical case in which the\nclass to be created (<code>HeroService</code>) is also the provider's dependency injection token.\nThe short form is generally preferred; this long form makes the details explicit.</p>\n\n<p translation-result=\"on\">第二个提供商使用 <code>DateLoggerService</code> 来满足 <code>LoggerService</code>。该 <code>LoggerService</code> 在 <code>AppComponent</code> 级别已经被注册。当<em>这个组件</em>要求 <code>LoggerService</code> 的时候，它得到的却是 <code>DateLoggerService</code> 服务的实例。</p><p translation-origin=\"off\">The second provider substitutes <code>DateLoggerService</code> for <code>LoggerService</code>.\n<code>LoggerService</code> is already registered at the <code>AppComponent</code> level.\nWhen this child component requests <code>LoggerService</code>, it receives a <code>DateLoggerService</code> instance instead.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">这个组件及其子组件会得到 <code>DateLoggerService</code> 实例。这个组件树之外的组件得到的仍是 <code>LoggerService</code> 实例。</p><p translation-origin=\"off\">This component and its tree of child components receive <code>DateLoggerService</code> instance.\nComponents outside the tree continue to receive the original <code>LoggerService</code> instance.</p>\n\n</div>\n<p translation-result=\"on\"><code>DateLoggerService</code> 从 <code>LoggerService</code> 继承；它把当前的日期/时间附加到每条信息上。</p><p translation-origin=\"off\"><code>DateLoggerService</code> inherits from <code>LoggerService</code>; it appends the current date/time to each message:</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/date-logger.service.ts\" region=\"date-logger-service\" header=\"src/app/date-logger.service.ts\" linenums=\"false\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root'\n})\nexport class DateLoggerService extends LoggerService\n{\n  logInfo(msg: any)  { super.logInfo(stamp(msg)); }\n  logDebug(msg: any) { super.logInfo(stamp(msg)); }\n  logError(msg: any) { super.logError(stamp(msg)); }\n}\n\nfunction stamp(msg: any) { return msg + ' at ' + new Date(); }\n\n</code-example>\n<a id=\"useexisting\"></a>\n<h4 id=\"alias-providers-codeuseexistingcode\" translation-result=\"on\">别名提供商：<code>useExisting</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#alias-providers-codeuseexistingcode\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"alias-providers-useexisting\">Alias providers: <code>useExisting</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#alias-providers-useexisting\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><code>useExisting</code> 提供了一个键，让你可以把一个令牌映射成另一个令牌。实际上，第一个令牌就是第二个令牌所关联的服务的<em>别名</em>，这样就创建了访问同一个服务对象的两种途径。</p><p translation-origin=\"off\">The <code>useExisting</code> provider key lets you map one token to another.\nIn effect, the first token is an <em>alias</em> for the service associated with the second token,\ncreating two ways to access the same service object.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-existing\" header=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\">\n{ provide: MinimalLogger, useExisting: LoggerService },\n\n</code-example>\n<p translation-result=\"on\">你可以使用别名接口来窄化 API。下面的例子中使用别名就是为了这个目的。</p><p translation-origin=\"off\">You can use this technique to narrow an API through an aliasing interface.\nThe following example shows an alias introduced for that purpose.</p>\n\n<p translation-result=\"on\">想象 <code>LoggerService</code> 有个很大的 API 接口，远超过现有的三个方法和一个属性。你可能希望把 API 接口收窄到只有两个你确实需要的成员。在这个例子中，<code>MinimalLogger</code><a href=\"guide/dependency-injection-in-action#class-interface\"><em>类-接口</em></a>，就这个 API 成功缩小到了只有两个成员：</p><p translation-origin=\"off\">Imagine that <code>LoggerService</code> had a large API, much larger than the actual three methods and a property.\nYou might want to shrink that API surface to just the members you actually need.\nIn this example, the <code>MinimalLogger</code> <a href=\"guide/dependency-injection-in-action#class-interface\">class-interface</a> reduces the API to two members:</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\" header=\"src/app/minimal-logger.service.ts\" linenums=\"false\">\n// Class used as <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> \"narrowing\" interface that exposes <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> minimal logger\n// <a href=\"api/common/Plural#Other\" class=\"code-anchor\">Other</a> members of the actual implementation are invisible\nexport abstract class MinimalLogger {\n  logs: string[];\n  logInfo: (msg: string) => void;\n}\n\n</code-example>\n<p translation-result=\"on\">下面的例子在一个简化版的 <code>HeroOfTheMonthComponent</code> 中使用 <code>MinimalLogger</code>。</p><p translation-origin=\"off\">The following example puts <code>MinimalLogger</code> to use in a simplified version of  <code>HeroOfTheMonthComponent</code>.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.1.ts\" header=\"src/app/hero-of-the-month.component.ts (minimal version)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-of-the-month',\n  templateUrl: './hero-of-the-month.component.html',\n  // TODO: move this aliasing, `useExisting` provider to the AppModule\n  providers: [{ provide: MinimalLogger, useExisting: LoggerService }]\n})\nexport class HeroOfTheMonthComponent {\n  logs: string[] = [];\n  constructor(logger: MinimalLogger) {\n    logger.logInfo('starting up');\n  }\n}\n\n</code-example>\n<p translation-result=\"on\"><code>HeroOfTheMonthComponent</code> 构造函数的 <code>logger</code> 参数是一个 <code>MinimalLogger</code> 类型，支持 TypeScript 的编辑器里，只能看到它的两个成员 <code>logs</code> 和 <code>logInfo</code>：</p><p translation-origin=\"off\">The <code>HeroOfTheMonthComponent</code> constructor's <code>logger</code> parameter is typed as <code>MinimalLogger</code>, so only the <code>logs</code> and <code>logInfo</code> members are visible in a TypeScript-aware editor.</p>\n\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/minimal-logger-intellisense.png\" alt=\"MinimalLogger restricted API\" width=\"532\" height=\"60\">\n</figure>\n<p translation-result=\"on\">实际上，Angular 把 <code>logger</code> 参数设置为注入器里 <code>LoggerService</code> 令牌下注册的完整服务，该令牌恰好是<a href=\"guide/dependency-injection-in-action#useclass\">以前提供的那个</a> <code>DateLoggerService</code> 实例。</p><p translation-origin=\"off\">Behind the scenes, Angular sets the <code>logger</code> parameter to the full service registered under the <code>LoggingService</code> token, which happens to be the <code>DateLoggerService</code> instance that was <a href=\"guide/dependency-injection-in-action#useclass\">provided above</a>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">在下面的图片中，显示了日志日期，可以确认这一点：</p><p translation-origin=\"off\">This is illustrated in the following image, which displays the logging date.</p>\n\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/date-logger-entry.png\" alt=\"DateLoggerService entry\" width=\"300\" height=\"32\">\n</figure>\n</div>\n<a id=\"usefactory\"></a>\n<h4 id=\"factory-providers-codeusefactorycode\" translation-result=\"on\">工厂提供商：<code>useFactory</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#factory-providers-codeusefactorycode\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"factory-providers-usefactory\">Factory providers: <code>useFactory</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#factory-providers-usefactory\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><code>useFactory</code> 提供了一个键，让你可以通过调用一个工厂函数来创建依赖实例，如下面的例子所示。</p><p translation-origin=\"off\">The <code>useFactory</code> provider key lets you create a dependency object by calling a factory function,\nas in the following example.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-factory\" header=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\">\n{ provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), <a href=\"api/core/ConstructorSansProvider#deps\" class=\"code-anchor\">deps</a>: [Hero, HeroService] }\n\n</code-example>\n<p translation-result=\"on\">注入器通过调用你用 <code>useFactory</code> 键指定的工厂函数来提供该依赖的值。\n注意，提供商的这种形态还有第三个键 <code><a href=\"api/core/ConstructorSansProvider#deps\" class=\"code-anchor\">deps</a></code>，它指定了供 <code>useFactory</code> 函数使用的那些依赖。</p><p translation-origin=\"off\">The injector provides the dependency value by invoking a factory function,\nthat you provide as the value of the <code>useFactory</code> key.\nNotice that this form of provider has a third key, <code><a href=\"api/core/ConstructorSansProvider#deps\" class=\"code-anchor\">deps</a></code>, which specifies\ndependencies for the <code>useFactory</code> function.</p>\n\n<p translation-result=\"on\">使用这项技术，可以用包含了一些<strong><em>依赖服务和本地状态</em></strong>输入的工厂函数来<strong><em>建立一个依赖对象</em></strong>。</p><p translation-origin=\"off\">Use this technique to create a dependency object with a factory function\nwhose inputs are a combination of <em>injected services</em> and <em>local state</em>.</p>\n\n<p translation-result=\"on\">这个依赖对象（由工厂函数返回的）通常是一个类实例，不过也可以是任何其它东西。\n在这个例子中，依赖对象是一个表示 \"月度英雄\" 参赛者名称的字符串。</p><p translation-origin=\"off\">The dependency object (returned by the factory function) is typically a class instance,\nbut can be other things as well.\nIn this example, the dependency object is a string of the names of the runners up\nto the \"Hero of the Month\" contest.</p>\n\n<p translation-result=\"on\">在这个例子中，局部状态是数字 <code>2</code>，也就是组件应该显示的参赛者数量。\n该状态的值传给了 <code>runnersUpFactory()</code> 作为参数。\n<code>runnersUpFactory()</code> 返回了<em>提供商的工厂函数</em>，它可以使用传入的状态值和注入的服务 <code>Hero</code> 和 <code>HeroService</code>。</p><p translation-origin=\"off\">In the example, the local state is the number <code>2</code>, the number of runners up that the component should show.\nThe state value is passed as an argument to <code>runnersUpFactory()</code>.\nThe <code>runnersUpFactory()</code> returns the <em>provider factory function</em>, which can use both\nthe passed-in state value and the injected services <code>Hero</code> and <code>HeroService</code>.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/runners-up.ts\" region=\"factory-synopsis\" header=\"runners-up.ts (excerpt)\" linenums=\"false\">\nexport function runnersUpFactory(take: number) {\n  return (winner: Hero, heroService: HeroService): string => {\n    /* ... */\n  };\n};\n\n</code-example>\n<p translation-result=\"on\">由 <code>runnersUpFactory()</code> 返回的提供商的工厂函数返回了实际的依赖对象，也就是表示名字的字符串。</p><p translation-origin=\"off\">The provider factory function (returned by <code>runnersUpFactory()</code>) returns the actual dependency object,\nthe string of names.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">这个返回的函数需要一个 <code>Hero</code> 和一个 <code>HeroService</code> 参数。</p><p translation-origin=\"off\">The function takes a winning <code>Hero</code> and a <code>HeroService</code> as arguments.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">Angular 根据 <code><a href=\"api/core/ConstructorSansProvider#deps\" class=\"code-anchor\">deps</a></code> 数组中指定的两个<em>令牌</em>来获得这些注入参数。</p><p translation-origin=\"off\">Angular supplies these arguments from injected values identified by\nthe two <em>tokens</em> in the <code><a href=\"api/core/ConstructorSansProvider#deps\" class=\"code-anchor\">deps</a></code> array.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">  该函数返回名字的字符串，Angular 可以把它们注入到 <code>HeroOfTheMonthComponent</code> 的 <code>runnersUp</code> 参数中。</p><p translation-origin=\"off\">The function returns the string of names, which Angular than injects into\nthe <code>runnersUp</code> parameter of <code>HeroOfTheMonthComponent</code>.</p>\n\n</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">该函数从 <code>HeroService</code> 中接受候选的英雄，从中取 <code>2</code> 个参加竞赛，并把他们的名字串接起来返回。\n参见 <live-example name=\"dependency-injection-in-action\"></live-example> 查看完整源码。</p><p translation-origin=\"off\">The function retrieves candidate heroes from the <code>HeroService</code>,\ntakes <code>2</code> of them to be the runners-up, and returns their concatenated names.\nLook at the <live-example name=\"dependency-injection-in-action\"></live-example>\nfor the full source code.</p>\n\n</div>\n<a id=\"tokens\"></a>\n<h2 id=\"provider-token-alternatives-class-interface-and-injectiontoken\" translation-result=\"on\">提供替代令牌：类接口与 'InjectionToken'<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#provider-token-alternatives-class-interface-and-injectiontoken\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"provider-token-alternatives-class-interface-and-injectiontoken\">Provider token alternatives: class interface and 'InjectionToken'<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#provider-token-alternatives-class-interface-and-injectiontoken\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">当使用类作为令牌，同时也把它作为返回依赖对象或服务的类型时，Angular 依赖注入使用起来最容易。</p><p translation-origin=\"off\">Angular dependency injection is easiest when the provider token is a class\nthat is also the type of the returned dependency object, or service.</p>\n\n<p translation-result=\"on\">但令牌不一定都是类，就算它是一个类，它也不一定都返回类型相同的对象。这是下一节的主题。</p><p translation-origin=\"off\">However, a token doesn't have to be a class and even when it is a class,\nit doesn't have to be the same type as the returned object.\nThat's the subject of the next section.</p>\n\n<a id=\"class-interface\"></a>\n<h3 id=\"classinterface\" translation-result=\"on\">类-接口<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#classinterface\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"classinterface\">Classinterface<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#classinterface\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">前面的<em>月度英雄</em>的例子使用了 <code>MinimalLogger</code> 类作为 <code>LoggerService</code> 提供商的令牌。</p><p translation-origin=\"off\">The previous <em>Hero of the Month</em> example used the <code>MinimalLogger</code> class\nas the token for a provider of <code>LoggerService</code>.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-existing\" header=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\">\n{ provide: MinimalLogger, useExisting: LoggerService },\n\n</code-example>\n<p translation-result=\"on\">该 <code>MinimalLogger</code> 是一个抽象类。</p><p translation-origin=\"off\"> <code>MinimalLogger</code> is an abstract class.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\" header=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\" linenums=\"false\">\n// Class used as <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> \"narrowing\" interface that exposes <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> minimal logger\n// <a href=\"api/common/Plural#Other\" class=\"code-anchor\">Other</a> members of the actual implementation are invisible\nexport abstract class MinimalLogger {\n  logs: string[];\n  logInfo: (msg: string) => void;\n}\n\n</code-example>\n<p translation-result=\"on\">你通常从一个可扩展的抽象类继承。但这个应用中<em>并没有</em>类会继承 <code>MinimalLogger</code>。</p><p translation-origin=\"off\">An abstract class is usually a base class that you can extend.\nIn this app, however there is no class that inherits from <code>MinimalLogger</code>.</p>\n\n<p translation-result=\"on\"><code>LoggerService</code> 和 <code>DateLoggerService</code><em>本可以</em>从 <code>MinimalLogger</code> 中继承。\n它们也可以实现 <code>MinimalLogger</code>，而不用单独定义接口。\n但它们没有。\n<code>MinimalLogger</code> 在这里仅仅被用作一个 \"依赖注入令牌\"。</p><p translation-origin=\"off\">The <code>LoggerService</code> and the <code>DateLoggerService</code>could have inherited from <code>MinimalLogger</code>,\nor they could have implemented it instead, in the manner of an interface.\nBut they did neither.\n<code>MinimalLogger</code> is used only as a dependency injection token.</p>\n\n<p translation-result=\"on\">当你通过这种方式使用类时，它称作<em>类接口</em>。</p><p translation-origin=\"off\">When you use a class this way, it's called a <em>class interface</em>.</p>\n\n<p translation-result=\"on\">就像 <a href=\"guide/dependency-injection-providers#interface-not-valid-token\">DI 提供商</a>中提到的那样，接口不是有效的 DI 令牌，因为它是 TypeScript 自己用的，在运行期间不存在。使用这种抽象类接口不但可以获得像接口一样的强类型，而且可以像普通类一样把它用作提供商令牌。</p><p translation-origin=\"off\">As mentioned in <a href=\"guide/dependency-injection-providers#interface-not-valid-token\">DI Providers</a>, an interface is not a valid DI token because it is a TypeScript artifact that doesn't exist at run time. Use this abstract class interface to get the strong typing of an interface, and also use it as a provider token in the way you would a normal class.</p>\n\n<p translation-result=\"on\">类接口应该<em>只</em>定义允许它的消费者调用的成员。窄的接口有助于解耦该类的具体实现和它的消费者。</p><p translation-origin=\"off\">A  class interface should define <em>only</em> the members that its consumers are allowed to call.\nSuch a narrowing interface helps decouple the concrete class from its consumers.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">用类作为接口可以让你获得真实 JavaScript 对象中的接口的特性。\n但是，为了最小化内存开销，该类应该是<em>没有实现</em>的。\n对于构造函数，<code>MinimalLogger</code> 会转译成未优化过的、预先最小化过的 JavaScript。</p><p translation-origin=\"off\">Using a class as an interface gives you the characteristics of an interface in a real JavaScript object.\nTo minimize memory cost, however, the class should have <em>no implementation</em>.\nThe <code>MinimalLogger</code> transpiles to this unoptimized, pre-minified JavaScript for a constructor function.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\" region=\"minimal-logger-transpiled\" header=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\" linenums=\"false\">\nvar MinimalLogger = (function () {\n  function MinimalLogger() {}\n  return MinimalLogger;\n}());\n<a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>(\"MinimalLogger\", MinimalLogger);\n\n</code-example>\n<p translation-result=\"on\">注意，<strong><em>只要不实现它</em></strong>，不管添加多少成员，它永远不会增长大小，因为这些成员虽然是有类型的，但却没有实现。你可以再看看 TypeScript 的 <code>MinimalLogger</code> 类，确定一下它是没有实现的。</p><p translation-origin=\"off\">Notice that it doesn't have any members. It never grows no matter how many members you add to the class,\nas long as those members are typed but not implemented. Look again at the TypeScript <code>MinimalLogger</code> class to confirm that it has no implementation.</p>\n\n</div>\n<a id=\"injection-token\"></a>\n<h3 id=\"injectiontoken-objects\" translation-result=\"on\">'InjectionToken' 对象<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#injectiontoken-objects\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"injectiontoken-objects\">'InjectionToken' objects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#injectiontoken-objects\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">依赖对象可以是一个简单的值，比如日期，数字和字符串，或者一个无形的对象，比如数组和函数。</p><p translation-origin=\"off\">Dependency objects can be simple values like dates, numbers and strings, or\nshapeless objects like arrays and functions.</p>\n\n<p translation-result=\"on\">这样的对象没有应用程序接口，所以不能用一个类来表示。更适合表示它们的是：唯一的和符号性的令牌，一个 JavaScript 对象，拥有一个友好的名字，但不会与其它的同名令牌发生冲突。</p><p translation-origin=\"off\">Such objects don't have application interfaces and therefore aren't well represented by a class.\nThey're better represented by a token that is both unique and symbolic,\na JavaScript object that has a friendly name but won't conflict with\nanother token that happens to have the same name.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 具有这些特征。在<em>Hero of the Month</em>例子中遇见它们两次，一个是 <em>title</em> 的值，一个是 <em>runnersUp</em> 工厂提供商。</p><p translation-origin=\"off\"><code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> has these characteristics.\nYou encountered them twice in the <em>Hero of the Month</em> example,\nin the <em>title</em> value provider and in the <em>runnersUp</em> factory provider.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"provide-injection-token\" header=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" linenums=\"false\">\n{ provide: TITLE,         useValue:   'Hero of the Month' },\n{ provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), <a href=\"api/core/ConstructorSansProvider#deps\" class=\"code-anchor\">deps</a>: [Hero, HeroService] }\n\n</code-example>\n<p translation-result=\"on\">这样创建 <code>TITLE</code> 令牌：</p><p translation-origin=\"off\">You created the <code>TITLE</code> token like this:</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"injection-token\" header=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" linenums=\"false\">\nimport { <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a> } from '@angular/core';\n\nexport const TITLE = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>&#x3C;string>('title');\n\n</code-example>\n<p translation-result=\"on\">类型参数，虽然是可选的，但可以向开发者和开发工具传达类型信息。\n而且这个令牌的描述信息也可以为开发者提供帮助。</p><p translation-origin=\"off\">The type parameter, while optional, conveys the dependency's type to developers and tooling.\nThe token description is another developer aid.</p>\n\n<a id=\"di-inheritance\"></a>\n<h2 id=\"inject-into-a-derived-class\" translation-result=\"on\">注入到派生类<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#inject-into-a-derived-class\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"inject-into-a-derived-class\">Inject into a derived class<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#inject-into-a-derived-class\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">当编写一个继承自另一个组件的组件时，要格外小心。如果基础组件有依赖注入，必须要在派生类中重新提供和重新注入它们，并将它们通过构造函数传给基类。</p><p translation-origin=\"off\">Take care when writing a component that inherits from another component.\nIf the base component has injected dependencies,\nyou must re-provide and re-inject them in the derived class\nand then pass them down to the base class through the constructor.</p>\n\n<p translation-result=\"on\">在这个刻意生成的例子里，<code>SortedHeroesComponent</code> 继承自 <code>HeroesBaseComponent</code>，显示一个<em>被排序</em>的英雄列表。</p><p translation-origin=\"off\">In this contrived example, <code>SortedHeroesComponent</code> inherits from <code>HeroesBaseComponent</code>\nto display a <em>sorted</em> list of heroes.</p>\n\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/sorted-heroes.png\" alt=\"Sorted Heroes\" width=\"135\" height=\"107\">\n</figure>\n<p translation-result=\"on\"><code>HeroesBaseComponent</code> 能自己独立运行。它在自己的实例里要求 <code>HeroService</code>，用来得到英雄，并将他们按照数据库返回的顺序显示出来。</p><p translation-origin=\"off\">The <code>HeroesBaseComponent</code> can stand on its own.\nIt demands its own instance of <code>HeroService</code> to get heroes\nand displays them in the order they arrive from the database.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/sorted-heroes.component.ts\" region=\"heroes-base\" header=\"src/app/sorted-heroes.component.ts (HeroesBaseComponent)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-unsorted-heroes',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">{{hero.name}}&#x3C;/div>`,\n  providers: [HeroService]\n})\nexport class HeroesBaseComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private heroService: HeroService) { }\n\n  heroes: Array&#x3C;Hero>;\n\n  ngOnInit() {\n    this.heroes = this.heroService.getAllHeroes();\n    this.afterGetHeroes();\n  }\n\n  // Post-process heroes in derived class override.\n  protected afterGetHeroes() {}\n\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<h3 id=\"keep-constructors-simple\" translation-result=\"on\">让构造函数保持简单<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#keep-constructors-simple\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"keep-constructors-simple\">Keep constructors simple<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#keep-constructors-simple\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">构造函数应该只用来初始化变量。\n这条规则让组件在测试环境中可以放心地构造组件，以免在构造它们时，无意中做出一些非常戏剧化的动作(比如与服务器进行会话)。\n这就是为什么你要在 <code>ngOnInit</code> 里面调用 <code>HeroService</code>，而不是在构造函数中。</p><p translation-origin=\"off\">Constructors should do little more than initialize variables.\nThis rule makes the component safe to construct under test without fear that it will do something dramatic like talk to the server.\nThat's why you call the <code>HeroService</code> from within the <code>ngOnInit</code> rather than the constructor.</p>\n\n</div>\n<p translation-result=\"on\">用户希望看到英雄按字母顺序排序。与其修改原始的组件，不如派生它，新建 <code>SortedHeroesComponent</code>，以便展示英雄之前进行排序。\n<code>SortedHeroesComponent</code> 让基类来获取英雄。</p><p translation-origin=\"off\">Users want to see the heroes in alphabetical order.\nRather than modify the original component, sub-class it and create a\n<code>SortedHeroesComponent</code> that sorts the heroes before presenting them.\nThe <code>SortedHeroesComponent</code> lets the base class fetch the heroes.</p>\n\n<p translation-result=\"on\">可惜，Angular 不能直接在基类里直接注入 <code>HeroService</code>。必须在<em>这个</em>组件里再次提供 <code>HeroService</code>，然后通过构造函数传给基类。</p><p translation-origin=\"off\">Unfortunately, Angular cannot inject the <code>HeroService</code> directly into the base class.\nYou must provide the <code>HeroService</code> again for <em>this</em> component,\nthen pass it down to the base class inside the constructor.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/sorted-heroes.component.ts\" region=\"sorted-heroes\" header=\"src/app/sorted-heroes.component.ts (SortedHeroesComponent)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-sorted-heroes',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">{{hero.name}}&#x3C;/div>`,\n  providers: [HeroService]\n})\nexport class SortedHeroesComponent extends HeroesBaseComponent {\n  constructor(heroService: HeroService) {\n    super(heroService);\n  }\n\n  protected afterGetHeroes() {\n    this.heroes = this.heroes.sort((h1, h2) => {\n      return h1.name &#x3C; h2.name ? -1 :\n            (h1.name > h2.name ? 1 : 0);\n    });\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">现在，请注意 <code>afterGetHeroes()</code> 方法。\n你的第一反应是在 <code>SortedHeroesComponent</code> 组件里面建一个 <code>ngOnInit</code> 方法来做排序。但是 Angular 会先调用<em>派生</em>类的 <code>ngOnInit</code>，后调用基类的 <code>ngOnInit</code>，\n所以可能在<em>英雄到达之前</em>就开始排序。这就产生了一个讨厌的错误。</p><p translation-origin=\"off\">Now take note of the <code>afterGetHeroes()</code> method.\nYour first instinct might have been to create an <code>ngOnInit</code> method in <code>SortedHeroesComponent</code> and do the sorting there.\nBut Angular calls the <em>derived</em> class's <code>ngOnInit</code> <em>before</em> calling the base class's <code>ngOnInit</code>\nso you'd be sorting the heroes array <em>before they arrived</em>. That produces a nasty error.</p>\n\n<p translation-result=\"on\">覆盖基类的 <code>afterGetHeroes()</code> 方法可以解决这个问题。</p><p translation-origin=\"off\">Overriding the base class's <code>afterGetHeroes()</code> method solves the problem.</p>\n\n<p translation-result=\"on\">分析上面的这些复杂性是为了强调<em>避免使用组件继承</em>这一点。</p><p translation-origin=\"off\">These complications argue for <em>avoiding component inheritance</em>.</p>\n\n<a id=\"forwardref\"></a>\n<h2 id=\"break-circularities-with-a-forward-class-reference-emforwardrefem\" translation-result=\"on\">使用一个前向引用(<em>forwardRef</em>)来打破循环<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#break-circularities-with-a-forward-class-reference-emforwardrefem\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"break-circularities-with-a-forward-class-reference-forwardref\">Break circularities with a forward class reference (<em>forwardRef</em>)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#break-circularities-with-a-forward-class-reference-forwardref\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在 TypeScript 里面，类声明的顺序是很重要的。如果一个类尚未定义，就不能引用它。</p><p translation-origin=\"off\">The order of class declaration matters in TypeScript.\nYou can't refer directly to a class until it's been defined.</p>\n\n<p translation-result=\"on\">这通常不是一个问题，特别是当你遵循<em>一个文件一个类</em>规则的时候。\n但是有时候循环引用可能不能避免。当一个类<em>A 引用类 B</em>，同时'B'引用'A'的时候，你就陷入困境了：它们中间的某一个必须要先定义。</p><p translation-origin=\"off\">This isn't usually a problem, especially if you adhere to the recommended <em>one class per file</em> rule.\nBut sometimes circular references are unavoidable.\nYou're in a bind when class 'A' refers to class 'B' and 'B' refers to 'A'.\nOne of them has to be defined first.</p>\n\n<p translation-result=\"on\">Angular 的 <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code> 函数建立一个<em>间接地</em>引用，Angular 可以随后解析。</p><p translation-origin=\"off\">The Angular <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code> function creates an <em>indirect</em> reference that Angular can resolve later.</p>\n\n<p translation-result=\"on\">这个关于<em>父查找器</em>的例子中全都是没办法打破的循环类引用。</p><p translation-origin=\"off\">The <em>Parent Finder</em> sample is full of circular class references that are impossible to break.</p>\n\n<p translation-result=\"on\">当一个类<em>需要引用自身</em>的时候，你面临同样的困境，就像在 <code>AlexComponent</code> 的 <code>provdiers</code> 数组中遇到的困境一样。\n该 <code>providers</code> 数组是一个 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 装饰器函数的一个属性，它必须在类定义<em>之前</em>出现。</p><p translation-origin=\"off\">You face this dilemma when a class makes <em>a reference to itself</em>\nas does <code>AlexComponent</code> in its <code>providers</code> array.\nThe <code>providers</code> array is a property of the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator function which must\nappear <em>above</em> the class definition.</p>\n\n<p translation-result=\"on\">使用 <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a></code> 来打破这种循环：</p><p translation-origin=\"off\">Break the circularity with <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a></code>.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-providers\" header=\"parent-finder.component.ts (AlexComponent providers)\" linenums=\"false\">\nproviders: [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() => AlexComponent) }],\n\n</code-example>\n<!--- Waiting for good examples \n\n<a id=\"directive-level-providers\"></a>\n\n<a id=\"element-level-providers\"></a>\n\n## Element-level providers\n\nA component is a specialization of directive, and the `@Component()` decorator inherits the `providers` property from `@Directive`. The injector is at the element level, so a provider configured with any element-level injector is available to any component, directive, or pipe attached to the same element. \n\nHere's a live example that implements a custom form control, taking advantage of an injector that is shared by a component and a directive on the same element.\n\nhttps://stackblitz.com/edit/basic-form-control\n\nThe component, `custom-control`, configures a provider for the DI token `NG_VALUE_ACCESSOR`. \nIn the template, the `FormControlName` directive is instantiated along with the custom component.\nIt can inject the `NG_VALUE_ACCESSOR` dependency because they share the same injector. \n(Notice that this example also makes use of `forwardRef()` to resolve a circularity in the definitions.)\n\n### Sharing a service among components\n\n__NEED TO TURN THIS INTO FULL EXTERNAL EXAMPLE__\n\nSuppose you want to share the same `HeroCacheService` among multiple components. One way to do this is to create a directive.\n\n```\n<ng-container heroCache>\n  <hero-overview></hero-overview>\n  <hero-details></hero-details>\n</ng-container>\n```\n\nUse the `@Directive()` decorator to configure the provider for the service:\n\n```\n@Directive(providers:[HeroCacheService])\n\nclass heroCache{...}\n```\n\nBecause the injectors for both the overview and details components are children of the injector created from the `heroCache` directive, they can inject things it provides.\nIf the `heroCache` directive provides the `HeroCacheService`, the two components end up sharing them.\n\nIf you want to show only one of them, use the directive to make sure __??of what??__.\n\n`<hero-overview heroCache></hero-overview>`\n\n --->\n\n</div>\n\n<!-- links to this doc:\n - guide/dependency-injection\n - guide/dependency-injection-navtree\n - guide/hierarchical-dependency-injection\n-->\n<!-- links from this doc:\n - api/animations/AnimationQueryOptions#limit\n - api/animations/browser/testing/MockAnimationDriver#log\n - api/common/NgForOf\n - api/common/NgIf\n - api/common/PlatformLocation#search\n - api/common/Plural#Other\n - api/core/Component\n - api/core/Component#template\n - api/core/ConstructorSansProvider#deps\n - api/core/Directive\n - api/core/Directive#host\n - api/core/ElementRef\n - api/core/Host\n - api/core/HostListener\n - api/core/Inject\n - api/core/Injectable\n - api/core/Injectable#providedIn\n - api/core/InjectionToken\n - api/core/Input\n - api/core/NgModule#exports\n - api/core/OnInit\n - api/core/Optional\n - api/core/ResolvedReflectiveFactory#factory\n - api/core/Self\n - api/core/SkipSelf\n - api/core/forwardRef\n - api/forms/DefaultValueAccessor\n - api/forms/NgModel\n - api/http/ReadyState#Open\n - api/router/ParamMap#keys\n - api/router/RouterLinkWithHref\n - guide/attribute-directives\n - guide/dependency-injection-in-action#alias-providers-codeuseexistingcode\n - guide/dependency-injection-in-action#alias-providers-useexisting\n - guide/dependency-injection-in-action#break-circularities-with-a-forward-class-reference-emforwardrefem\n - guide/dependency-injection-in-action#break-circularities-with-a-forward-class-reference-forwardref\n - guide/dependency-injection-in-action#class-interface\n - guide/dependency-injection-in-action#class-providers-codeuseclasscode\n - guide/dependency-injection-in-action#class-providers-useclass\n - guide/dependency-injection-in-action#classinterface\n - guide/dependency-injection-in-action#define-dependencies-with-providers\n - guide/dependency-injection-in-action#defining-providers\n - guide/dependency-injection-in-action#dependency-injection-in-action\n - guide/dependency-injection-in-action#factory-providers-codeusefactorycode\n - guide/dependency-injection-in-action#factory-providers-usefactory\n - guide/dependency-injection-in-action#hero-bios-component\n - guide/dependency-injection-in-action#inject-into-a-derived-class\n - guide/dependency-injection-in-action#inject-the-components-dom-element\n - guide/dependency-injection-in-action#injection-token\n - guide/dependency-injection-in-action#injectiontoken-objects\n - guide/dependency-injection-in-action#keep-constructors-simple\n - guide/dependency-injection-in-action#limit-service-scope-to-a-component-subtree\n - guide/dependency-injection-in-action#make-a-dependency-codeoptionalcode-and-limit-search-with-codehostcode\n - guide/dependency-injection-in-action#make-a-dependency-optional-and-limit-search-with-host\n - guide/dependency-injection-in-action#modify-the-provider-search-with-codeselfcode-and-codeskipselfcode\n - guide/dependency-injection-in-action#modify-the-provider-search-with-self-and-skipself\n - guide/dependency-injection-in-action#multiple-service-instances-sandboxing\n - guide/dependency-injection-in-action#nested-service-dependencies\n - guide/dependency-injection-in-action#optional\n - guide/dependency-injection-in-action#provider-token-alternatives-class-interface-and-injectiontoken\n - guide/dependency-injection-in-action#qualify-dependency-lookup-with-parameter-decorators\n - guide/dependency-injection-in-action#supply-a-custom-provider-with-codeinjectcode\n - guide/dependency-injection-in-action#supply-a-custom-provider-with-inject\n - guide/dependency-injection-in-action#useclass\n - guide/dependency-injection-in-action#value-providers-codeusevaluecode\n - guide/dependency-injection-in-action#value-providers-usevalue\n - guide/dependency-injection-providers\n - guide/dependency-injection-providers#interface-not-valid-token\n - guide/dependency-injection-providers#provide\n - guide/glossary#token\n - https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/dependency-injection-in-action.md?message=docs%3A%20请简述你的修改...\n-->"
}