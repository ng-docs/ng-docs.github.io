{
  "id": "guide/view-encapsulation",
  "title": "View encapsulation",
  "contents": "\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/aio/aio/content/guide/view-encapsulation.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"view-encapsulation\" translation-result=\"on\">视图包装<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#view-encapsulation\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"view-encapsulation\">View encapsulation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#view-encapsulation\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">在 Angular 中，组件的样式可以封装在组件的宿主元素中，这样它们就不会影响应用程序的其余部分。</p><p translation-origin=\"off\">In Angular, a component's styles can be encapsulated within the component's host element so that they don't affect the rest of the application.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 的装饰器提供了 <a href=\"api/core/Component#encapsulation\"><code>encapsulation</code></a> 选项，可用来控制如何基于<em>每个组件</em>应用视图封装。</p><p translation-origin=\"off\">The <code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code>'s decorator provides the <a href=\"api/core/Component#encapsulation\"><code>encapsulation</code></a> option which can be used to control how the encapsulation is applied on a <em>per component</em> basis.</p>\n\n<p translation-result=\"on\">从以下模式中选择：</p><p translation-origin=\"off\">Choose from the following modes:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> ，Angular 使用浏览器内置的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM\">Shadow DOM API</a> 将组件的视图包含在 ShadowRoot（用作组件的宿主元素）中，并以隔离的方式应用所提供的样式。</p><p translation-origin=\"off\"><code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code>, Angular uses the browser's built-in <a href=\"https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM\">Shadow DOM API</a>) to enclose the component's view inside a ShadowRoot (used as the component's host element) and apply the provided styles in an isolated manner.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code>，Angular 会修改组件的 CSS 选择器，使它们只应用于组件的视图，不影响应用程序中的其他元素（<em>模拟 </em>Shadow DOM 行为）。有关更多详细信息，请参阅<a href=\"guide/view-encapsulation#inspect-generated-css\">查看生成的 CSS</a> 。</p><p translation-origin=\"off\"><code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code>, Angular modifies the component's CSS selectors so that they are only applied to the component's view and do not affect other elements in the application (<em>emulating</em> Shadow DOM behavior). For more details, see <a href=\"guide/view-encapsulation#inspect-generated-css\">Inspecting generated CSS</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> ，Angular 不应用任何形式的视图封装，这意味着为组件指定的任何样式实际上都是全局应用的，并且可以影响应用程序中存在的任何 HTML 元素。这种模式本质上与将样式包含在 HTML 本身中是一样的。</p><p translation-origin=\"off\"><code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code>, Angular does not apply any sort of view encapsulation meaning that any styles specified\nfor the component are actually globally applied and can affect any HTML element present within the application.\nThis mode is essentially the same as including the styles into the HTML itself.</p>\n\n</li>\n</ul>\n<div class=\"alert is-important\">\n<p translation-result=\"on\"><code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> 仅适用于内置支持 shadow DOM 的浏览器（请参阅 <a href=\"https://caniuse.com/shadowdomv1\">Can I use - Shadow DOM v1</a> ）。并非所有浏览器都支持它，这就是为什么 <code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code> 是推荐和默认模式的原因。</p><p translation-origin=\"off\">  <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> only works on browsers that have built-in support\nfor the shadow DOM (see <a href=\"https://caniuse.com/shadowdomv1\">Can I use - Shadow DOM v1</a>).\nNot all browsers support it, which is why the <code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code> is the recommended and default mode.</p>\n\n</div>\n<a id=\"inspect-generated-css\"></a>\n<h2 id=\"inspecting-generated-css\" translation-result=\"on\">查看生成的 CSS<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#inspecting-generated-css\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"inspecting-generated-css\">Inspecting generated CSS<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#inspecting-generated-css\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">使用模拟视图封装时，Angular 会预处理所有组件的样式，以便它们仅应用于组件的视图。</p><p translation-origin=\"off\">When using the emulated view encapsulation, Angular pre-processes all the component's styles so that they are only applied to the component's view.</p>\n\n<p translation-result=\"on\">在正运行的 Angular 应用程序的 DOM 中，使用模拟视图封装模式的组件所在的元素附加了一些额外的属性：</p><p translation-origin=\"off\">In the DOM of a running Angular application, elements belonging to components using emulated view encapsulation have some extra attributes attached to them:</p>\n\n<code-example format=\"html\" language=\"html\">\n&#x3C;hero-details _nghost-pmm-5>\n  &#x3C;h2 _ngcontent-pmm-5>Mister Fantastic&#x3C;/h2>\n  &#x3C;hero-team _ngcontent-pmm-5 _nghost-pmm-6>\n    &#x3C;h3 _ngcontent-pmm-6>Team&#x3C;/h3>\n  &#x3C;/hero-team>\n&#x3C;/hero-detail>\n</code-example>\n<p translation-result=\"on\">有两种这样的属性：</p><p translation-origin=\"off\">There are two kinds of such attributes:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>_nghost</code> 属性被添加到包裹组件视图的元素中，这将是本机 Shadow DOM 封装中的 ShadowRoots。组件的宿主元素通常就是这种情况。</p><p translation-origin=\"off\"><code>_nghost</code> attributes are added to elements that enclose a component's view and that would be ShadowRoots in a native Shadow DOM encapsulation. This is typically the case for components' host elements.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>_ngcontent</code> 属性被添加到组件视图中的子元素上，这些属性用于将元素与其各自模拟的 ShadowRoots（具有匹配 <code>_nghost</code> 属性的宿主元素）相匹配。</p><p translation-origin=\"off\"><code>_ngcontent</code> attributes are added to child element within a component's view, those are used to match the elements with their respective emulated ShadowRoots (host elements with a matching <code>_nghost</code> attribute).</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">这些属性的确切值是 Angular 的私有实现细节。它们是自动生成的，你不应在应用程序代码中引用它们。</p><p translation-origin=\"off\">The exact values of these attributes are a private implementation detail of Angular. They are automatically generated and you should never refer to them in application code.</p>\n\n<p translation-result=\"on\">它们以生成的组件样式为目标，这些样式会被注入到 DOM 的 <code>&#x3C;head></code> 部分：</p><p translation-origin=\"off\">They are targeted by the generated component styles, which are injected in the <code>&#x3C;head></code> section of the DOM:</p>\n\n<code-example format=\"css\" language=\"css\">\n[_nghost-pmm-5] {\n  display: block;\n  border: 1px solid black;\n}\n\nh3[_ngcontent-pmm-6] {\n  background-color: white;\n  border: 1px solid #777;\n}\n</code-example>\n<p translation-result=\"on\">这些样式经过后期处理，以便每个 CSS 选择器都使用适当的 <code>_nghost</code> 或 <code>_ngcontent</code> 属性进行扩充。这些修改后的选择器可以确保样式以隔离和有针对性的方式应用于组件的视图。</p><p translation-origin=\"off\">These styles are post-processed so that each CSS selector is augmented with the appropriate <code>_nghost</code> or <code>_ngcontent</code> attribute. These modified selectors make sure the styles to be applied to components' views in an isolated and targeted fashion.</p>\n\n<h2 id=\"mixing-encapsulation-modes\" translation-result=\"on\">混合封装模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#mixing-encapsulation-modes\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"mixing-encapsulation-modes\">Mixing encapsulation modes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#mixing-encapsulation-modes\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">如前所述，你可以在组件的装饰器中针对<em>每个组件</em>指定封装模式，这意味着在你的应用程序中，不同的组件可以使用不同的封装策略。</p><p translation-origin=\"off\">As previously mentioned you specify the encapsulation mode in the Component's decorator on a <em>per component</em> basis, this means that within your application you can have different components using different encapsulation strategies.</p>\n\n<p translation-result=\"on\">尽管可能，但不建议这样做。如果真的需要，你应该知道使用不同封装模式的组件的样式会如何彼此交互：</p><p translation-origin=\"off\">Although possible, this is not recommended. If it is really needed you should be aware of how the styles of components using different encapsulation modes will interact with each other:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">带有 <code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code> 的组件样式会添加到文档的 <code>&#x3C;head></code> 中，使它们在整个应用程序中可用，但它们的选择器只会影响它们各自组件模板中的元素。</p><p translation-origin=\"off\">The styles of components with <code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code> are added to the <code>&#x3C;head></code> of the document, making them available throughout the application, but their selectors only affect elements within their respective components' templates.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">带有 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 的组件样式会添加到文档的 <code>&#x3C;head></code> 中，使它们在整个应用程序中可用，因此是完全全局的，会影响文档中的任何匹配元素。</p><p translation-origin=\"off\">The styles of components with <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> are added to the <code>&#x3C;head></code> of the document, making them available throughout the application, so are completely global and affect any matching elements within the document.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">带有 <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> 的组件样式仅添加到 shadow DOM 宿主中，确保它们仅影响各自组件视图中的元素。</p><p translation-origin=\"off\">The styles of components with <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> are only added to the shadow DOM host, ensuring that they only affect elements within their respective components' views.</p>\n\n</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code> 和 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 组件的样式也会添加到每个 <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> 组件的 shadow DOM 宿主中。</p><p translation-origin=\"off\">  Styles of <code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code> and <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> components are also added to the shadow DOM host of each <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> component.</p>\n\n<p translation-result=\"on\">  这意味着带有 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 的组件的样式将影响 shadow DOM 中的匹配元素。</p><p translation-origin=\"off\">  This means that styles for components with <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> will affect matching elements within shadow DOMs.</p>\n\n<p translation-result=\"on\">  这种方法乍一看似乎有违直觉，但如果没有它，带有 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 的组件将在使用 <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> 的组件内呈现不同的效果，因为其样式将不可用。</p><p translation-origin=\"off\">  This approach may seem counter-intuitive at first, but without it a component with <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> would be rendered differently within a component using <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code>, since its styles would not be available.</p>\n\n</div>\n<h3 id=\"examples\" translation-result=\"on\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#examples\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"examples\">Examples<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#examples\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">本节展示了具有不同 <code><a href=\"api/core/ViewEncapsulation\" class=\"code-anchor\">ViewEncapsulation</a></code> 的组件的样式如何交互的示例。</p><p translation-origin=\"off\">This section shows examples of how the styling of components with different <code><a href=\"api/core/ViewEncapsulation\" class=\"code-anchor\">ViewEncapsulation</a></code> interact.</p>\n\n<p translation-result=\"on\">请参阅 <live-example nodownload=\"\"></live-example> 以自己尝试这些组件。</p><p translation-origin=\"off\">See the <live-example nodownload=\"\"></live-example> to try out these components yourself.</p>\n\n<h4 id=\"no-encapsulation\" translation-result=\"on\">无封装<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#no-encapsulation\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"no-encapsulation\">No encapsulation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#no-encapsulation\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">第一个示例显示了一个具有 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 的组件。此组件将其模板元素着色为红色。</p><p translation-origin=\"off\">The first example shows a component that has <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code>. This component colors its template elements red.</p>\n\n<code-example path=\"view-encapsulation/src/app/no-encapsulation.component.ts\" header=\"src/app/no-encapsulation.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-no-encapsulation',\n  template: `\n    &#x3C;h2>None&#x3C;/h2>\n    &#x3C;div class=\"none-message\">No encapsulation&#x3C;/div>\n  `,\n  styles: ['h2, .none-message { color: red; }'],\n  encapsulation: <a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a>,\n})\nexport class NoEncapsulationComponent { }\n\n\n</code-example>\n<p translation-result=\"on\">Angular 将此组件的样式作为全局样式添加到文档的 <code>&#x3C;head></code> 中。</p><p translation-origin=\"off\">Angular adds the styles for this component as global styles to the <code>&#x3C;head></code> of the document.</p>\n\n<p translation-result=\"on\">如前所述，Angular 还会将这些样式添加到所有 shadow DOM 宿主。因此，样式在整个应用程序中都可用。</p><p translation-origin=\"off\">As already mentioned Angular also adds the styles to all shadow DOM hosts. Therefore, the styles are available throughout the whole application.</p>\n\n<img src=\"generated/images/guide/view-encapsulation/no-encapsulation.png\" alt=\"component with no encapsulation\" width=\"500\" height=\"101\">\n<h4 id=\"emulated-encapsulation\" translation-result=\"on\">模拟封装<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#emulated-encapsulation\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"emulated-encapsulation\">Emulated encapsulation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#emulated-encapsulation\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">第二个示例显示了一个具有 <code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code> 的组件。此组件将其模板元素着色为绿色。</p><p translation-origin=\"off\">The second example shows a component that has <code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code>. This component colors its template elements green.</p>\n\n<code-example path=\"view-encapsulation/src/app/emulated-encapsulation.component.ts\" header=\"src/app/emulated-encapsulation.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-emulated-encapsulation',\n  template: `\n    &#x3C;h2>Emulated&#x3C;/h2>\n    &#x3C;div class=\"emulated-message\">Emulated encapsulation&#x3C;/div>\n    &#x3C;app-no-encapsulation>&#x3C;/app-no-encapsulation>\n  `,\n  styles: ['h2, .emulated-message { color: green; }'],\n  encapsulation: <a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a>,\n})\nexport class EmulatedEncapsulationComponent { }\n\n\n</code-example>\n<blockquote>\n</blockquote>\n<p translation-result=\"on\">与 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 类似，Angular 会将此组件的样式添加到文档的 <code>&#x3C;head></code> 中，但它们是带有“作用域”的样式。</p><p translation-origin=\"off\">Similar to <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code>, Angular adds the styles for this component to the <code>&#x3C;head></code> of the document, but with \"scoped\" styles.</p>\n\n<p translation-result=\"on\">因此，只有直接在该组件模板中的元素才会匹配其样式。由于来自 <code>EmulatedEncapsulationComponent</code> 的样式是非常特化的，因此它们会覆盖来自 <code>NoEncapsulationComponent</code> 的全局样式。</p><p translation-origin=\"off\">Therefore, only the elements directly within this component's template will match its styles.\nSince the \"scoped\" styles from the <code>EmulatedEncapsulationComponent</code> are very specific, they override the global styles from the <code>NoEncapsulationComponent</code>.</p>\n\n<p translation-result=\"on\">在此示例中，<code>EmulatedEncapsulationComponent</code> 包含着 <code>NoEncapsulationComponent</code>， 但 <code>NoEncapsulationComponent</code> 仍然如预期般生效了，因为 <code>EmulatedEncapsulationComponent</code> 的“范围化”样式与其模板中的元素并不匹配。</p><p translation-origin=\"off\">In this example, the <code>EmulatedEncapsulationComponent</code> contains a <code>NoEncapsulationComponent</code>, but <code>NoEncapsulationComponent</code> is still styled as expected since the <code>EmulatedEncapsulationComponent</code>'s \"scoped\" styles do not match elements in its template.</p>\n\n<img src=\"generated/images/guide/view-encapsulation/emulated-encapsulation.png\" alt=\"component with no encapsulation\" width=\"500\" height=\"207\">\n<h4 id=\"shadow-dom-encapsulation\" translation-result=\"on\">Shadow DOM 封装<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#shadow-dom-encapsulation\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"shadow-dom-encapsulation\">Shadow DOM encapsulation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#shadow-dom-encapsulation\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">第三个示例显示了一个具有 <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> 的组件。此组件会将其模板元素着色为蓝色。</p><p translation-origin=\"off\">The third example shows a component that has <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code>. This component colors its template elements blue.</p>\n\n<code-example path=\"view-encapsulation/src/app/shadow-dom-encapsulation.component.ts\" header=\"src/app/shadow-dom-encapsulation.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-shadow-dom-encapsulation',\n  template: `\n    &#x3C;h2>ShadowDom&#x3C;/h2>\n    &#x3C;div class=\"shadow-message\">Shadow DOM encapsulation&#x3C;/div>\n    &#x3C;app-emulated-encapsulation>&#x3C;/app-emulated-encapsulation>\n    &#x3C;app-no-encapsulation>&#x3C;/app-no-encapsulation>\n  `,\n  styles: ['h2, .shadow-message { color: blue; }'],\n  encapsulation: <a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a>,\n})\nexport class ShadowDomEncapsulationComponent { }\n\n\n</code-example>\n<blockquote>\n</blockquote>\n<p translation-result=\"on\">Angular 仅将此组件的样式添加到 shadow DOM 宿主，因此它们在 shadow DOM 之外是不可见的。</p><p translation-origin=\"off\">Angular adds styles for this component only to the shadow DOM host, so they are not visible outside the shadow DOM.</p>\n\n<p translation-result=\"on\">请注意，Angular 还将 <code>NoEncapsulationComponent</code> 和 <code>ViewEncapsulationComponent</code> 的全局样式添加到了 shadow DOM 宿主中，因此这些样式仍然可用于该组件的模板中的元素。</p><p translation-origin=\"off\">Note that Angular also adds the global styles from the <code>NoEncapsulationComponent</code> and <code>ViewEncapsulationComponent</code> to the shadow DOM host, so those styles are still available to the elements in the template of this component.</p>\n\n<p translation-result=\"on\">在这个例子中， <code>ShadowDomEncapsulationComponent</code> 包含一个 <code>NoEncapsulationComponent</code> 和 <code>ViewEncapsulationComponent</code> 。</p><p translation-origin=\"off\">In this example, the <code>ShadowDomEncapsulationComponent</code> contains both a <code>NoEncapsulationComponent</code> and <code>ViewEncapsulationComponent</code>.</p>\n\n<p translation-result=\"on\"><code>ShadowDomEncapsulationComponent</code> 组件添加的样式在该组件的整个 shadow DOM 中都可用，在 <code>NoEncapsulationComponent</code> 和 <code>ViewEncapsulationComponent</code> 中也是如此。</p><p translation-origin=\"off\">The styles added by the <code>ShadowDomEncapsulationComponent</code> component are available throughout the shadow DOM of this component, and so to both the <code>NoEncapsulationComponent</code> and <code>ViewEncapsulationComponent</code>.</p>\n\n<p translation-result=\"on\"><code>EmulatedEncapsulationComponent</code> 具有特化的“范围化”样式，因此该组件模板的样式不受影响。</p><p translation-origin=\"off\">The <code>EmulatedEncapsulationComponent</code> has specific \"scoped\" styles, so the styling of this component's template is unaffected.</p>\n\n<p translation-result=\"on\">但是由于 <code>ShadowDomEncapsulationComponent</code> 中的样式是在全局样式之后添加到 Shadow Host 中的，因此 <code>h2</code> 样式会覆盖 <code>NoEncapsulationComponent</code> 中的样式。结果是 <code>NoEncapsulationComponent</code> 中的 <code>&#x3C;h2></code> 元素被着色为蓝色而不是红色，这可能不是组件作者的本意。</p><p translation-origin=\"off\">But since styles from <code>ShadowDomEncapsulationComponent</code> are added to the shadow host after the global styles, the <code>h2</code> style overrides the style from the <code>NoEncapsulationComponent</code>.\nThe result is that the <code>&#x3C;h2></code> element in the <code>NoEncapsulationComponent</code> is colored blue rather than red, which may not be what the component's author intended.</p>\n\n<img src=\"generated/images/guide/view-encapsulation/shadow-dom-encapsulation.png\" alt=\"component with no encapsulation\" width=\"500\" height=\"413\">\n\n  <div class=\"reviewed\">最后复查时间： 2021/11/10</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/component-styles\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/Component#encapsulation\n - api/core/ViewEncapsulation\n - api/core/ViewEncapsulation#Emulated\n - api/core/ViewEncapsulation#None\n - api/core/ViewEncapsulation#ShadowDom\n - guide/view-encapsulation#emulated-encapsulation\n - guide/view-encapsulation#examples\n - guide/view-encapsulation#inspect-generated-css\n - guide/view-encapsulation#inspecting-generated-css\n - guide/view-encapsulation#mixing-encapsulation-modes\n - guide/view-encapsulation#no-encapsulation\n - guide/view-encapsulation#shadow-dom-encapsulation\n - guide/view-encapsulation#view-encapsulation\n - https://caniuse.com/shadowdomv1\n - https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM\n - https://github.com/ng-docs/angular-cn/edit/aio/aio/content/guide/view-encapsulation.md?message=docs%3A%20请简述你的修改...\n-->"
}